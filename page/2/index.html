<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG={root:"/",algolia:{appId:"RI90VLL69D",apiKey:"20c535e9a1424a7913210eb747d6e67b",indexName:"HexoBlog",hits:{per_page:10},languages:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}.",hits_stats:"${hits} results found in ${time} ms"}},localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">391</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">46</span></a></div></div></div><nav id="nav"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div><div id="site-social-icons"><a class="social-icon" href="https://github.com/charon-cheung"><i class="fa-github fa"></i></a><a class="social-icon search"><i class="fa fa-search"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/29/视觉SLAM/标定D435i的外参数(三)/">标定D435i的外参数 (三)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/视觉SLAM/">视觉SLAM</a></span><div class="content"><ul><li>标定板pattern尽量选择apriltag，尽量不要用纸质的</li><li>选择合适的相机模型</li><li>标定手法看看TUM的</li></ul></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/28/视觉SLAM/realsense D435i安装配置/">realsense D435i安装配置</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/视觉SLAM/">视觉SLAM</a></span><div class="content"><p>realsense D435i终于到手了，打开发现其实很小巧，先做一些配置看看。默认要使用USB3，如果RealSense使用USB2, Output Resolution自动降到<code>480*270 30fbs</code>，而非产品所宣称的1280 x 720 active stereo depth resolution和90fps，且只有Stereo Moudle在工作，无Image Sensor的RGB Moudle菜单项，无法进行3D建模。</p><p>D435i采用了即用型USB供电形式，不仅提供深度传感器模组，还配备了一个IMU单元（惯性测量单元，采用的博世BMI055）。凭借内置的IMU单元，结合视觉数据可实现6DoF追踪功能。其中，IMU将各种线性加速度计和陀螺仪数据结合，可检测X，Y，Z三轴的旋转和平移，以及俯仰、横摇等动作。D435i的2000万像素RGB摄像头和3D传感器可以30帧/秒的速度提供分辨率高达1280 × 720，或者以90帧/秒的速度提供848 × 480的较低分辨率。该摄像头具有全局快门，可以处理快速移动物体，室内室外皆可操作。深度距离在<code>0.1 m~10 m</code>之间，视场角度为85 × 58度</p><p>可以获得RGB图、左右红外摄像图、深度图、IMU数据，并且将深度图数据和RGB图进行对齐。左右红外相机进行测量深度，中间红外点阵投射器相当于补光灯，不打开也能测深度，只是效果不好；最右边的rgb相机用于采集彩色图片，最终可以将彩色视频流与深度流进行对齐.</p><h2 id="librealsense"><a href="#librealsense" class="headerlink" title="librealsense"></a>librealsense</h2><p>先装realsense的驱动，步骤参考网上的，其实不必完全相同，我的步骤如下：</p><ol><li><p>下载<a href="https://github.com/IntelRealSense/librealsense" target="_blank" rel="noopener">驱动</a>，然后解压到根目录</p></li><li><p>执行如下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/librealsense</span><br><span class="line">sudo apt-get install libssl-dev libusb-1.0-0-dev pkg-config libgtk-3-dev libglfw3-dev</span><br><span class="line"><span class="comment"># 许可脚本</span></span><br><span class="line">sudo cp config/99-realsense-libusb.rules /etc/udev/rules.d/</span><br><span class="line">sudo udevadm control --reload-rules &amp;&amp; udevadm trigger</span><br></pre></td></tr></table></figure></li><li><p>开始编译</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/librealsense</span><br><span class="line">mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake ../ -DBUILD_EXAMPLES=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">sudo make uninstall &amp;&amp; make clean &amp;&amp; make  -j8 &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></li></ol><p>j8是根据我电脑的情况选择的，如果不指定核数，编译会很慢。</p><p>运行<code>realsense-viewer</code>验证，看到如下画面<br><img src="https://i.loli.net/2020/06/28/TIEr7MGmfpWXisD.png" alt="RGB Depth Infrared"><br>配置可以修改为常见的黑白深度图以及分辨率等等<br><img src="https://i.loli.net/2020/06/28/3uPdGyh7TlFnS5w.png" alt="配置栏"></p><h2 id="ROS驱动"><a href="#ROS驱动" class="headerlink" title="ROS驱动"></a>ROS驱动</h2><p>从<a href="https://github.com/IntelRealSense/realsense-ros" target="_blank" rel="noopener">这里</a>下载，然后放到某工作空间，编译即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">catkin_make -DCATKIN_ENABLE_TESTING=False -DCMAKE_BUILD_TYPE=Release</span><br><span class="line">catkin_make install</span><br></pre></td></tr></table></figure><p>现在运行<code>roslaunch realsense2_camera rs_camera.launch</code>，打开rqt就能看到realsense的三种图像<br>实际运行了<code>/camera/realsense2_camera</code>和<code>camera/realsense2_camera_manager</code>两个节点，涉及的话题有很多，以后慢慢分析。</p><p>tf关系如图：<br><img src="https://i.loli.net/2020/07/01/5DTI18Hnzdr7qJy.png" alt="frames.png"><br><br></p><p>在rqt中打开深度图时出现了报错，又是图像编码问题<br><img src="https://i.loli.net/2020/06/28/PV9LDck5atvEzMZ.png" alt="launch文件中报错.png"><br><img src="https://i.loli.net/2020/06/28/PYMuOQ7R6zDgvel.png" alt="rqt终端报错.png"><br>在rqt里查看<code>/camera/depth/image_rect_raw/theora</code>，同样没有深度图，但rqt不报警</p><p>在rqt查看RGB和红外的图像，只要选择theora，rqt终端都会报警:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ WARN][/rqt_gui_cpp_node_25764] [TheoraSubscriber::internalCallback] line_170  [theora] Packet was not a Theora header</span><br></pre></td></tr></table></figure><br><p>使用对齐的深度话题信息发布RGBD点云</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch realsense2_camera rs_rgbd.launch</span><br></pre></td></tr></table></figure><p>这一步还没有成功,在rviz里没看到结果</p><p>参考：<br><a href="https://blog.csdn.net/sinat_23853639/article/details/88044019" target="_blank" rel="noopener">realsense D435 驱动安装并嵌入ROS中使用</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/25/激光SLAM/gmapping/(九) 总结/">(九) 总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/gmapping/">gmapping</a></span><div class="content"><p>gmapping源码中不完善的部分：</p><ol><li>drawFromMotion函数是一个十分粗糙的运动模型，只是简单的矢量加减运算。相比于《概率机器人》中提到的速度模型和里程计模型，有很多方面都没有考虑，精度上可能有折扣。</li><li><code>m_angularOdometryReliability</code>和<code>m_linearOdometryReliability</code>用于控制激光评分的增益<code>odo_gain</code>, 实际都是0，所以没有用到，而且无法用参数赋值, 要使用就得修改源码.</li><li>紧接上面的代码，<code>localScore=odo_gain*score(map, localPose, readings);</code>，localScore在之后的<code>likelihoodAndScore</code>函数里实际赋值为0，根本没有用。所以这里有好几行可以删除</li><li>在论文中，粒子的权重不是用最优位姿的似然值来表示的，而是用所有的似然值的和来表示的</li><li>重采样的粒子索引选取用的是轮盘赌算法，有些论文提出了一些更好的算法</li></ol></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/19/激光SLAM/gmapping/OpenMP加速gmapping/">OpenMP加速gmapping</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/gmapping/">gmapping</a></span><div class="content"><p>在CMakeLists里做如下配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FIND_PACKAGE( OpenMP REQUIRED)</span><br><span class="line"><span class="keyword">if</span>(OPENMP_FOUND)</span><br><span class="line">    message(<span class="string">"OPENMP FOUND"</span>)</span><br><span class="line">    <span class="built_in">set</span>(CMAKE_C_FLAGS <span class="string">"<span class="variable">$&#123;CMAKE_C_FLAGS&#125;</span> <span class="variable">$&#123;OpenMP_C_FLAGS&#125;</span>"</span>)</span><br><span class="line">    <span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">"<span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span> <span class="variable">$&#123;OpenMP_CXX_FLAGS&#125;</span>"</span>)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure><p>注意： OpenMP并不适合需要复杂的线程间同步和互斥的场合这种情况下花的时间可能更长</p><p>gmapping使用OpenMP加速的语句: <code>#pragma omp parallel for</code></p><ol><li><p>for循环的drawFromMotion之前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma omp parallel for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_particles.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">    m_particles[i].pose =  m_motionModel.drawFromMotion(m_particles[i].pose, relPose,m_odoPose);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>invalidateActiveArea之前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma omp parallel for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_particles.size(); i++) &#123;</span><br><span class="line">    m_matcher.invalidateActiveArea();</span><br></pre></td></tr></table></figure></li><li><p>scanMatch函数开头，实际就是对整个scanMatch并行化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scanMatch</span><span class="params">(<span class="keyword">double</span> * plainReading)</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_particles.size(); i++) &#123;</span><br></pre></td></tr></table></figure></li><li><p>updateMap函数中</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x &lt; smap.getMapSizeX(); x++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>; y &lt; smap.getMapSizeY(); y++)</span><br><span class="line">    &#123;</span><br></pre></td></tr></table></figure><ol start="5"><li>重采样resample函数</li></ol><p>对于保留下来的粒子进行更新，在并行化操作里面<code>m_particles.push_back()</code>会报错，因此需要把push_back()提出来，在外面的的for循环进行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;tmp_size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对保留下来的粒子数据进行更新</span></span><br><span class="line">        <span class="comment">//每个粒子的权重都设置为相同的值</span></span><br><span class="line">        temp[i].setWeight(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//为每个粒子更新running_scans</span></span><br><span class="line">        <span class="comment">//增加了一帧激光数据 因此需要更新地图</span></span><br><span class="line">        m_matcher.registerScan(temp[i].<span class="built_in">map</span>,temp[i].pose,plainReading);</span><br><span class="line">        <span class="comment">//m_matcher.registerScan(temp[i].lowResolutionMap,temp[i].pose,plainReading);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>为每个粒子更新地图时，同样可以并行化</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/17/激光SLAM/gmapping/(八) 源码分析6  scan match/">(八) 源码分析6 scan match</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/gmapping/">gmapping</a></span><div class="content"><p>先接上篇，不是第一帧激光数据的情况，上来是<code>scanMatch</code>函数，也就是<code>GridSlamProcessor::scanMatch</code>(在文件gridslamprocessor.hxx)。</p><h2 id="主要部分"><a href="#主要部分" class="headerlink" title="主要部分"></a>主要部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> GridSlamProcessor::scanMatch(<span class="keyword">const</span> <span class="keyword">double</span>* plainReading)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// sample a new pose from each scan in the reference</span></span><br><span class="line">    <span class="comment">/* 每个粒子都要进行 scan-match */</span></span><br><span class="line">    <span class="keyword">double</span> sumScore=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> particle_number = m_particles.size();</span><br><span class="line">    <span class="comment">//可以用openMP的方式来进行并行化，因此这里不能用迭代器，只能用下标的方式</span></span><br><span class="line">    <span class="comment">//并行化之后，里面的循环会均匀分到各个不同的核里面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; particle_number; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        OrientedPoint corrected;</span><br><span class="line">        <span class="keyword">double</span> score, l, s;</span><br><span class="line">        <span class="comment">/*进行scan-match 计算粒子的最优位姿，这是gmapping本来的做法*/</span></span><br><span class="line">        score = m_matcher.optimize(corrected, m_particles[i].<span class="built_in">map</span>, m_particles[i].pose, plainReading);</span><br><span class="line">        <span class="comment">/* 匹配成功则更新最优位姿 */</span></span><br><span class="line">	    <span class="keyword">if</span> (score&gt;m_minimumScore)</span><br><span class="line">	    &#123;</span><br><span class="line">	      m_particles[i].pose = corrected;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">/*  扫描匹配不上,则使用里程计的数据,使用里程计数据不进行更新.</span></span><br><span class="line"><span class="comment">	          因为在进行扫描匹配之前 里程计已经更新过了*/</span></span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">	        <span class="keyword">if</span> (m_infoStream)</span><br><span class="line">	        &#123;</span><br><span class="line">	            m_infoStream &lt;&lt; <span class="string">"Scan Matching Failed, using odometry. Likelihood="</span> &lt;&lt; l &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	            m_infoStream &lt;&lt; <span class="string">"lp:"</span> &lt;&lt; m_lastPartPose.x &lt;&lt; <span class="string">" "</span>  &lt;&lt; m_lastPartPose.y &lt;&lt; <span class="string">" "</span>&lt;&lt; m_lastPartPose.theta &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	            m_infoStream &lt;&lt; <span class="string">"op:"</span> &lt;&lt; m_odoPose.x &lt;&lt; <span class="string">" "</span> &lt;&lt; m_odoPose.y &lt;&lt; <span class="string">" "</span>&lt;&lt; m_odoPose.theta;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">// 粒子的最优位姿计算了之后，重新计算粒子的权重,相当于粒子滤波器中的观测步骤</span></span><br><span class="line">	    <span class="comment">/* 计算p(z|x,m)，粒子的权重由粒子的似然来表示, 计算粒子的得分和权重(似然)	</span></span><br><span class="line"><span class="comment">	        注意粒子的权重经过ScanMatch之后已经更新了</span></span><br><span class="line"><span class="comment">	     * 在论文中   粒子的权重不是用最优位姿的似然值来表示的</span></span><br><span class="line"><span class="comment">	     * 是用所有的似然值的和来表示的, s是得分  l是似然,也就是权重 */</span></span><br><span class="line">	    m_matcher.likelihoodAndScore(s, l, m_particles[i].<span class="built_in">map</span>, m_particles[i].pose, plainReading);</span><br><span class="line">	    sumScore+=score;</span><br><span class="line">	    m_particles[i].weight+= l;</span><br><span class="line">	    m_particles[i].weightSum+= l;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">//set up the selective copy of the active area</span></span><br><span class="line">	    <span class="comment">//by detaching the areas that will be updated</span></span><br><span class="line">	    <span class="comment">/*计算出来最优的位姿之后，进行地图的扩充  这里不会进行内存分配</span></span><br><span class="line"><span class="comment">	     *不进行内存分配的原因是这些粒子进行重采样之后有可能会消失掉，因此在后面进行重采样的时候统一进行内存分配。</span></span><br><span class="line"><span class="comment">	     *理论上来说，这里的操作是没有必要的，因为后面的重采样的时候还会进行一遍</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    m_matcher.invalidateActiveArea();</span><br><span class="line">	    m_matcher.computeActiveArea(m_particles[i].<span class="built_in">map</span>, m_particles[i].pose, plainReading);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_infoStream)</span><br><span class="line">        m_infoStream &lt;&lt; <span class="string">"Average Scan Matching Score of all particles="</span> &lt;&lt; sumScore/m_particles.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始的都没意思，直接看<code>ScanMatcher::optimize</code>，在<code>scanmatcher.cpp</code>里，开头又是一个重要函数<code>score</code>，在<code>scanmatcher.h</code>里。它根据地图、激光数据、位姿迭代求解一个最优的新的位姿出来。</p><p>代码比较复杂，直接看整个<code>scan</code>函数(包括了optimize和score)的评分算法的理论：</p><p>对于栅格地图的环境地图模型，一般采用基于似然场模型（likelihood field range finder mode）的扫描匹配算法来进行激光雷达数据与地图的匹配。 该算法通过评估当前时刻位姿的激光雷达数据中每一个激光点与该时刻栅格地图的匹配程度，并将评估得到的每个激光点得分进行累加，得到当前时刻激光雷达数据与地图匹配的总分数，得分越高说明该时刻激光雷达信息与地图匹配程度越高，即机器人位姿越精确。由于该算法能够根据机器人当前时刻状态、 观测值和地图信息直接得到该时刻位姿的匹配程度，因而该算法常与基于粒子滤波的定位算法结合使用，用于选取各粒子中得分最高的位姿，并计算得分， 从而完成机器人位姿的确定，其原理如图：<br><img src="https://i.loli.net/2020/06/17/zGU6bgEwCnlRpr9.png" alt="基于似然场模型的扫描匹配示意图.png"></p><p>黑色的格子代表前一时刻栅格地图中障碍物的位置， 圆形的点表示以里程计运动模型作为提议分布得到的机器人位姿估计为基础，将当前时刻激光雷达数据转换到栅格地图坐标系中的激光点的分布。把激光雷达的坐标转换到世界坐标系: 先旋转到机器人坐标系，然后再转换到世界坐标系。</p><p>该位姿下观测信息与地图匹配得分的具体算法步骤如下：对于当前激光雷达数据中任意一个激光点，设其端点在世界坐标系中坐标为 <code>lp</code> ，则其对应栅格地图中坐标为 <code>phit</code> ，对 <code>phit</code>周围八个栅格进行障碍物判定，并计算这些障碍物的平均坐标 <code>pavr</code>， 求出 <code>pavr</code>与 phit 的距离 dist 。 该激光点的评分可由下式表示<br><img src="https://i.loli.net/2020/06/17/7TFuOJbjxSr9BNA.png" alt="评分公式.png"></p><p>如果设置的<code>minimumScore</code>参数过大，一些粒子的匹配会失败，因为要求太高了，gmapping会出现下列信息：<br><img src="https://i.loli.net/2020/06/18/lDeLROQoaziNZrb.png" alt="scan match失败.png"><br>gmapping变成使用里程计进行位姿估计，这其实是不好的，因为从论文可知<strong>激光精度比里程计精确得多</strong>，但是注意粒子的权重计算还是调用<code>likelihoodAndScore</code>函数。</p><p><code>ε</code>为基于扫描匹配概率的激光方差，对该时刻所有激光点进行上式的计算，并将评分进行求和，分数越高说明该位姿的可信度越高。 对当前时刻所有粒子位姿进行扫描匹配运算， 并根据得分实现粒子的权重更新，最后求出粒子群的平均评分<code>sumScore/m_particles.size()</code></p><h3 id="试验小强的scan-match评分"><a href="#试验小强的scan-match评分" class="headerlink" title="试验小强的scan match评分"></a>试验小强的scan match评分</h3><p>直接修改<code>gridslamprocessor.hxx</code>的scanMatch函数。 小强的gmapping编译有问题，执行<code>catkin_make --pkg gmapping</code>之后，需要 <code>cp /home/xiaoqiang/Documents/ros/devel/lib/gmapping/slam_gmapping /home/xiaoqiang/Documents/ros/src/gmapping/launch</code>，否则roslaunch找不到节点文件</p><p>根据测试，激光评分多数在<code>140~160</code>，有时也会超过160.</p><h2 id="for循环剩下的部分"><a href="#for循环剩下的部分" class="headerlink" title="for循环剩下的部分"></a>for循环剩下的部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*矫正成功则更新位姿*/</span></span><br><span class="line"><span class="keyword">if</span> (score&gt;m_minimumScore)</span><br><span class="line">&#123;</span><br><span class="line">    m_particles[i].pose = corrected;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扫描匹配不上,则使用里程计的数据,使用里程计数据不进行更新,因为扫描匹配之前,里程计已经更新过了</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//输出信息 这个在并行模式下可以会出现错位</span></span><br><span class="line">    <span class="keyword">if</span> (m_infoStream)</span><br><span class="line">    &#123;</span><br><span class="line">        m_infoStream &lt;&lt; <span class="string">"Scan Matching Failed, using odometry. Likelihood="</span> &lt;&lt; l &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        m_infoStream &lt;&lt; <span class="string">"lp:"</span> &lt;&lt; m_lastPartPose.x &lt;&lt; <span class="string">" "</span>  &lt;&lt; m_lastPartPose.y &lt;&lt; <span class="string">" "</span>&lt;&lt; m_lastPartPose.theta &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        m_infoStream &lt;&lt; <span class="string">"op:"</span> &lt;&lt; m_odoPose.x &lt;&lt; <span class="string">" "</span> &lt;&lt; m_odoPose.y &lt;&lt; <span class="string">" "</span>&lt;&lt; m_odoPose.theta &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 粒子的最优位姿计算了之后，重新计算粒子的权重(相当于粒子滤波器中的观测步骤，</span></span><br><span class="line"><span class="comment">   计算p(z|x,m))，粒子的权重由粒子的似然来表示。</span></span><br><span class="line"><span class="comment">* 计算粒子的得分和权重(似然)   注意粒子的权重经过ScanMatch之后已经更新了</span></span><br><span class="line"><span class="comment">* 在论文中,例子的权重不是用最有位姿的似然值来表示的。</span></span><br><span class="line"><span class="comment">* 是用所有的似然值的和来表示的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">m_matcher.likelihoodAndScore(s, l, m_particles[i].<span class="built_in">map</span>, m_particles[i].pose, plainReading);</span><br><span class="line"></span><br><span class="line">sumScore+=score;</span><br><span class="line">m_particles[i].weight+=l;</span><br><span class="line">m_particles[i].weightSum+=l;</span><br><span class="line"><span class="comment">//set up the selective copy of the active area</span></span><br><span class="line"><span class="comment">//by detaching the areas that will be updated</span></span><br><span class="line"><span class="comment">/*计算出来最优的位姿之后，进行地图的扩充  这里不会进行内存分配</span></span><br><span class="line"><span class="comment">*不进行内存分配的原因是这些粒子进行重采样之后有可能会消失掉，因此在后面进行冲采样的时候统一进行内存分配。</span></span><br><span class="line"><span class="comment">*理论上来说，这里的操作是没有必要的，因为后面的重采样的时候还会进行一遍</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">m_matcher.invalidateActiveArea();</span><br><span class="line">m_matcher.computeActiveArea(m_particles[i].<span class="built_in">map</span>, m_particles[i].pose, plainReading);</span><br></pre></td></tr></table></figure><h2 id="重采样"><a href="#重采样" class="headerlink" title="重采样"></a>重采样</h2><p><code>resample</code>函数：该函数在gridslamprocessor.hxx。首先是备份老的粒子的轨迹，即保留叶子的节点。然后是需要重采样还是不需要重采样，如果不需要重采样，则权值不变。只为轨迹创建一个新的节点，每个粒子更新地图。当有效值小于阈值的时候需要重采样，通过resampleIndexes提取到需要删除的粒子。删除粒子后，保留当前的粒子并在保存的粒子的节点里新增一个节点。删除要删除粒子的节点，保留的粒子进行数据更新，将每个粒子的设置同一个权重。最后更新一下地图。</p><p>​<code>resampleIndexes</code>：该函数在particlefilter.h中，使用轮盘赌算法，决定哪些粒子会保留，保留的粒子会返回下标，里面的下标可能会重复，因为有些粒子会重复采样,而另外的一些粒子会消失掉。</p><p>首先计算总的权重，计算平均权重值（interval），根据权值进行采样,target是0-1分布随机选取的一数值，当总权重大于目标权重的，记录该粒子的索引，target在加上一个interval。如果某个粒子的权重比较大的话，就被采样多次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">resampleIndexes</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Particle&gt;&amp; particles, <span class="keyword">int</span> nparticles)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Numeric cweight=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">/*计算总的权重*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Particle&gt;::const_iterator it=particles.begin(); it!=particles.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		cweight+=(Numeric)*it;</span><br><span class="line">		n++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nparticles&gt;<span class="number">0</span>)</span><br><span class="line">		n=nparticles;</span><br><span class="line">	<span class="comment">//compute the interval</span></span><br><span class="line">	Numeric interval=cweight/n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// drand48 返回服从均匀分布的·[0.0, 1.0) 之间的double随机数</span></span><br><span class="line">	Numeric target=interval*::drand48();</span><br><span class="line">    <span class="comment">// 如果某个粒子的区间为4*interval。那么它至少被采样3次。</span></span><br><span class="line">	cweight=<span class="number">0</span>;  n=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; indexes(n);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Particle&gt;::const_iterator it=particles.begin(); it!=particles.end(); ++it, ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cweight+=(Numeric)* it;</span><br><span class="line">		<span class="keyword">while</span>(cweight&gt;target)</span><br><span class="line">		&#123;</span><br><span class="line">			indexes[n++]=i;</span><br><span class="line">			target+=interval;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> indexes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/16/ROS/ROS机器人/小强机器人的说明/">小强机器人的补充说明</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS机器人/">ROS机器人</a></span><div class="content"><h2 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h2><p>将<code>/home/xiaoqiang/Documents/ros/src/ORB_SLAM2</code>中的CMakeLists大部分内容都注释掉了，目前还用不到它．</p><p>注释<code>xqserial_server/CMakeLists.txt</code>的57行，否则出现下面情况：<br><img src="https://i.loli.net/2020/05/21/NBcWdKsP286OAV5.png" alt></p><p><code>nav_test</code>不需要特别编译，它全是py文件，没有cpp。但是需要从网上下载<code>rbx1</code>工程，这是一本教程里用到的，只把其中的<code>rbx1_nav</code>放到当前工作空间里，编译通过。<strong>nav_squared.py</strong>需要它</p><p>将<code>startup.launch</code>注释掉一部分，比如摄像头节点等等。</p><p><code>robot_pose_ekf</code>包很奇怪，它应当是在<code>/home/xiaoqiang/Documents/ros/src/navigation</code>，但是修改相应源码，执行launch没有效果。最后发现实际使用的是<code>R50_Release</code>中的<code>robot_pose_ekf</code>。删掉后者就报错找不到了，可见xiaoqiang中的那个没有生效，不像个package，但是rospd又能找到，很奇怪。</p><h2 id="运动部分"><a href="#运动部分" class="headerlink" title="运动部分"></a>运动部分</h2><p><code>/xqserial_server/Twist</code>疑似无用，只有<code>/motor_driver</code>在一直发布它</p><p><code>xqserial_server/Pose2D</code>的消息是(x,y,theta)，是相对里程计坐标系原点的位姿</p><p>里程计模型也是速度积分的二轮差速，使用编码器读数获得极小时间内的位移，以左右轮的编码器增量的均值计算。</p><p><code>control.py</code>就是从键盘获取方向键，发布速度命令到<code>cmd_vel</code>话题，订阅了<code>/xqserial_server/Odom</code>话题，但是实际没用到。</p><p><code>xqserial_server</code>命名空间包括<code>StatusPublisher</code>和<code>DiffDriverController</code>两个类</p><p><code>xiaoqiang_log</code>话题对应的<code>LogRecored.msg</code>如下，只有缺少串口设备时才发布，record是json形式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string collection_name</span><br><span class="line">time stamp</span><br><span class="line">string record</span><br></pre></td></tr></table></figure><p><code>xiaoqiang_tts/text</code>话题对应语音提示信息，也是在缺少串口设备时才发布</p><p>里程计的更新频率为100Hz,里程计也是切线模型假设，使用编码器推算轨迹</p><h2 id="startup-launch"><a href="#startup-launch" class="headerlink" title="startup.launch"></a>startup.launch</h2><p>开机启动的launch文件是<code>startup</code>包中的startup.launch</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"xqserial_server"</span> <span class="attr">type</span>=<span class="string">"xqserial_server"</span> <span class="attr">name</span>=<span class="string">"motor_driver"</span> <span class="attr">respawn</span>=<span class="string">"true"</span> <span class="attr">respawn_delay</span>=<span class="string">"10"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"debug_flag"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"wheel_separation"</span> <span class="attr">value</span>=<span class="string">"0.360"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"wheel_radius"</span> <span class="attr">value</span>=<span class="string">"0.0625"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"/dev/ttyUSB001"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"r_min"</span> <span class="attr">value</span>=<span class="string">"1.0"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"tf"</span> <span class="attr">type</span>=<span class="string">"static_transform_publisher"</span> <span class="attr">name</span>=<span class="string">"baselink_broadcaster"</span> <span class="attr">args</span>=<span class="string">"0 0 0.15 0 0 0 1 base_footprint base_link 50"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"tf"</span> <span class="attr">type</span>=<span class="string">"static_transform_publisher"</span> <span class="attr">name</span>=<span class="string">"imulink_broadcaster"</span> <span class="attr">args</span>=<span class="string">"-0.1 -0.03 0 0 0 0 1 base_link imu 50"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主要是xqserial_server，然后是静态发布tf变换： <code>base_footprint --&gt; base_link --&gt; imu</code></p><h2 id="urdf"><a href="#urdf" class="headerlink" title="urdf"></a>urdf</h2><h3 id="rviz显示问题"><a href="#rviz显示问题" class="headerlink" title="rviz显示问题"></a>rviz显示问题</h3><p>尝试在远程机上同时启动<code>xiaoqiang_udrf.launch</code>和rviz，先尝试加载<code>urdf.rviz</code>，这种情况下的tf变换都是正常的<br><img src="https://i.loli.net/2020/04/21/p9o8NVRW62OEbcz.png" alt="加载urdf并显示小强机器人.png"></p><p>但是常用方式是远程机启动launch，本地机启动rviz，rviz里做好配置后，发现终端会报错：找不到所需要的所有STL文件，这几个文件在<code>/home/xiaoqiang/Documents/ros/src/xiaoqiang_udrf/meshes</code>。这是因为rviz在本机找这些文件，</p><p>launch文件里加载了<code>xiaoqiang_udrf.URDF</code>，这个文件又加载STL文件，语句是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mesh</span>  <span class="attr">filename</span>=<span class="string">"package://xiaoqiang_udrf/meshes/base_link.STL"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>也就是说本地机需要一个名为xiaoqiang_udrf的package，自己新建一个。</p><p>这时再打开rviz就不会报错了，但还是有问题，整个模型透明发白，这是因为rivz中的全局坐标系“fixed frame”设置的不合适，将map改成base_link后即可正常显示。</p><p>结果机器人并不能动，rviz里仍显示几个wheel和odom没有tf变换，但是<code>rosrun tf tf_echo</code>有正常结果，结果发现就是显示的问题，<font color="blue" size="3">重启rviz就好了</font></p><h3 id="坐标系冲突"><a href="#坐标系冲突" class="headerlink" title="坐标系冲突"></a>坐标系冲突</h3><p>现在urdf中的坐标系叫做<code>lidar_urdf</code>，<code>static_transform_publisher</code>定义的是base_link和laser的关系，在<code>a2.launch</code>里。<br><img src="https://i.loli.net/2020/07/05/LICsGrwtDm3nPVK.png" alt="urdf中的base_link和laser的关系.png"><br><img src="https://i.loli.net/2020/07/05/ErV4Hq3xAPyk7TO.png" alt="static_transform_publisher中base_link和laser的关系.png"><br>可以看到二者的坐标关系有所不同，如果把<code>lidar_urdf</code>也改成<code>laser</code>，那么在rviz可以看到<code>laser</code>坐标系会不断旋转跳动，这是存在两个tf变换造成的。由于urdf只是个显示功能，所以还是用两个坐标系。<code>base_link</code>和<code>laser</code>之间的关系可能不精确，这就需要标定了</p><h2 id="tf变换"><a href="#tf变换" class="headerlink" title="tf变换"></a>tf变换</h2><p><img src="https://i.loli.net/2020/04/20/Izq7PYWlSMBJTkn.png" alt="开机启动下的tf关系图.png"></p><p><img src="https://i.loli.net/2020/04/23/6Jdp2VgYIlPzZwr.png" alt="odom和base_foot坐标系低于地图"></p><p><img src="https://i.loli.net/2020/04/21/fTDlwPs7YIFEuzA.png" alt="雷达扫描的轨迹和地图边缘有一定差距"></p><p><img src="https://i.loli.net/2020/04/23/TM8Vud6EoFshwKb.png" alt="LaserScan未正常显示，但tf正常"></p><p>无地图状态下，以odom为固定坐标系，移动机器人时，base_link会相对移动。但是用rviz里的<code>Odometry</code>可以表达base_link在odom坐标系下的运动</p><h2 id="使用伽利略客户端"><a href="#使用伽利略客户端" class="headerlink" title="使用伽利略客户端"></a>使用伽利略客户端</h2><p>使用最新版本，一开始总连接不成功，最后发现是公用网络的防火墙造成的，但是不知为什么，防火墙已经将它添加例外了，无法修改，只好把防火墙关了<br><img src="https://i.loli.net/2020/05/18/n5EueWIBL3TtQPO.png" alt="防火墙.png"></p><p><img src="https://i.loli.net/2020/05/18/xlGK29yToFkRejq.png" alt="关闭串口.png"></p><h2 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h2><p>gmapping建图： <code>roslaunch gmapping a2.launch</code>，对应<code>rplidar_a2_test.rviz</code></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/15/激光SLAM/gmapping/(七) 源码分析5  updateMap函数/">(七) 源码分析5 updateMap函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/gmapping/">gmapping</a></span><div class="content"><h2 id="第1部分"><a href="#第1部分" class="headerlink" title="第1部分"></a>第1部分</h2><p>这里的更新地图，只是为了可视化。因为真正的地图存储在粒子里面，这里会拿一个权值最大的粒子的地图<strong>发布</strong>出来.</p><p>得到权值最大的粒子，然后遍历这个粒子的整个轨迹，根据轨迹上记录的信息来进行建图，然后把得到的地图发布出去。</p><p>每次addScan()成功了，就会调用这个函数来生成地图，并发布出去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ROS_DEBUG(<span class="string">"Update map"</span>);</span><br><span class="line"><span class="comment">// 更新地图的时候，加了一把锁</span></span><br><span class="line">boost::mutex::<span class="function">scoped_lock <span class="title">map_lock</span> <span class="params">(map_mutex_)</span></span>;</span><br><span class="line"><span class="comment">// 构造函数的解释在下一篇</span></span><br><span class="line">GMapping::ScanMatcher  matcher;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置scanmatcher的各个参数*/</span></span><br><span class="line">matcher.setLaserParameters(scan.ranges.size(), &amp;(laser_angles_[<span class="number">0</span>]),</span><br><span class="line">        gsp_laser_-&gt;getPose() );</span><br><span class="line">matcher.setlaserMaxRange(maxRange_);</span><br><span class="line">matcher.setusableRange(maxUrange_);</span><br><span class="line">matcher.setgenerateMap(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到累计权重(weightSum)最大的粒子，不是当前的最大权重的粒子</span></span><br><span class="line"><span class="comment">// 累计权重即该粒子在各个时刻的权重之和(轨迹上的各个节点的权重之和)</span></span><br><span class="line">GMapping::GridSlamProcessor::Particle best =</span><br><span class="line">        gsp_-&gt;getParticles()[gsp_-&gt;getBestParticleIndex()];</span><br><span class="line"></span><br><span class="line">std_msgs::Float64 entropy;</span><br><span class="line"><span class="comment">// computePoseEntropy 遍历粒子集合计算熵</span></span><br><span class="line">entropy.data = computePoseEntropy();</span><br><span class="line"><span class="comment">//发布位姿的熵</span></span><br><span class="line"><span class="keyword">if</span>(entropy.data &gt; <span class="number">0.0</span>)</span><br><span class="line">    entropy_publisher_.publish(entropy);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有地图，则初始化一个地图</span></span><br><span class="line"><span class="keyword">if</span>(!got_map_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// nav_msgs::GetMap::Response   map_</span></span><br><span class="line">    map_.<span class="built_in">map</span>.info.resolution = delta_;</span><br><span class="line">    map_.<span class="built_in">map</span>.info.origin.position.x = <span class="number">0.0</span>;</span><br><span class="line">    map_.<span class="built_in">map</span>.info.origin.position.y = <span class="number">0.0</span>;</span><br><span class="line">    map_.<span class="built_in">map</span>.info.origin.position.z = <span class="number">0.0</span>;</span><br><span class="line">    map_.<span class="built_in">map</span>.info.origin.orientation.x = <span class="number">0.0</span>;</span><br><span class="line">    map_.<span class="built_in">map</span>.info.origin.orientation.y = <span class="number">0.0</span>;</span><br><span class="line">    map_.<span class="built_in">map</span>.info.origin.orientation.z = <span class="number">0.0</span>;</span><br><span class="line">    map_.<span class="built_in">map</span>.info.origin.orientation.w = <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算位姿的信息熵"><a href="#计算位姿的信息熵" class="headerlink" title="计算位姿的信息熵"></a>计算位姿的信息熵</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> SlamGMapping::computePoseEntropy()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> weight_total=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;GMapping::GridSlamProcessor::Particle&gt;::const_iterator it = gsp_-&gt;getParticles().begin();</span><br><span class="line">        it != gsp_-&gt;getParticles().end();</span><br><span class="line">        ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        weight_total += it-&gt;weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> entropy = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;GMapping::GridSlamProcessor::Particle&gt;::const_iterator it = gsp_-&gt;getParticles().begin();</span><br><span class="line">        it != gsp_-&gt;getParticles().end();</span><br><span class="line">        ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;weight/weight_total &gt; <span class="number">0.0</span>)</span><br><span class="line">            entropy += it-&gt;weight/weight_total * <span class="built_in">log</span>(it-&gt;weight/weight_total);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -entropy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第2部分"><a href="#第2部分" class="headerlink" title="第2部分"></a>第2部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*地图的中点*/</span></span><br><span class="line">GMapping::Point center;</span><br><span class="line">center.x=(xmin_ + xmax_) / <span class="number">2.0</span>;</span><br><span class="line">center.y=(ymin_ + ymax_) / <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化一个scanmatcherMap 创建一个地图 */</span></span><br><span class="line">GMapping::<span class="function">ScanMatcherMap <span class="title">smap</span><span class="params">(center, xmin_, ymin_, xmax_, ymax_,</span></span></span><br><span class="line"><span class="function"><span class="params">                              delta_)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*更新地图*/</span></span><br><span class="line"><span class="comment">//遍历最优粒子的整条轨迹树， 按照轨迹上各个节点存储的信息，计算激活区域更新地图</span></span><br><span class="line">ROS_DEBUG(<span class="string">"Trajectory tree:"</span>);</span><br><span class="line"><span class="keyword">for</span>(GMapping::GridSlamProcessor::TNode* n = best.node;n;n = n-&gt;parent)</span><br><span class="line">&#123;</span><br><span class="line">    ROS_DEBUG(<span class="string">"  %.3f %.3f %.3f"</span>,</span><br><span class="line">              n-&gt;pose.x,</span><br><span class="line">              n-&gt;pose.y,</span><br><span class="line">              n-&gt;pose.theta);</span><br><span class="line">    <span class="keyword">if</span>(!n-&gt;reading)</span><br><span class="line">    &#123;</span><br><span class="line">        ROS_DEBUG(<span class="string">"Reading is NULL"</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行地图更新</span></span><br><span class="line">    <span class="comment">//matcher.invalidateActiveArea();</span></span><br><span class="line">    <span class="comment">//matcher.computeActiveArea(smap, n-&gt;pose, &amp;((*n-&gt;reading)[0]));</span></span><br><span class="line">    <span class="comment">//matcher.registerScan(smap, n-&gt;pose, &amp;((*n-&gt;reading)[0]));</span></span><br><span class="line">    matcher.registerScan(smap, n-&gt;pose, &amp;(n-&gt;reading-&gt;m_dists[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the map may have expanded, so resize ros message as well</span></span><br><span class="line"><span class="comment">// 扩充地图的大小</span></span><br><span class="line"><span class="keyword">if</span>(map_.<span class="built_in">map</span>.info.width != (<span class="keyword">unsigned</span> <span class="keyword">int</span>) smap.getMapSizeX() || map_.<span class="built_in">map</span>.info.height != (<span class="keyword">unsigned</span> <span class="keyword">int</span>) smap.getMapSizeY())</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> The results of ScanMatcherMap::getSize() are different from the parameters given to the constructor</span></span><br><span class="line">    <span class="comment">//       so we must obtain the bounding box in a different way</span></span><br><span class="line">    GMapping::Point wmin = smap.map2world(GMapping::IntPoint(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    GMapping::Point wmax = smap.map2world(GMapping::IntPoint(smap.getMapSizeX(), smap.getMapSizeY()));</span><br><span class="line">    xmin_ = wmin.x; ymin_ = wmin.y;</span><br><span class="line">    xmax_ = wmax.x; ymax_ = wmax.y;</span><br><span class="line"></span><br><span class="line">    ROS_DEBUG(<span class="string">"map size is now %dx%d pixels (%f,%f)-(%f, %f)"</span>, smap.getMapSizeX(), smap.getMapSizeY(),</span><br><span class="line">              xmin_, ymin_, xmax_, ymax_);</span><br><span class="line"></span><br><span class="line">    map_.<span class="built_in">map</span>.info.width = smap.getMapSizeX();</span><br><span class="line">    map_.<span class="built_in">map</span>.info.height = smap.getMapSizeY();</span><br><span class="line">    map_.<span class="built_in">map</span>.info.origin.position.x = xmin_;</span><br><span class="line">    map_.<span class="built_in">map</span>.info.origin.position.y = ymin_;</span><br><span class="line">    map_.<span class="built_in">map</span>.data.resize(map_.<span class="built_in">map</span>.info.width * map_.<span class="built_in">map</span>.info.height);</span><br><span class="line"></span><br><span class="line">    ROS_DEBUG(<span class="string">"map origin: (%f, %f)"</span>, map_.<span class="built_in">map</span>.info.origin.position.x, map_.<span class="built_in">map</span>.info.origin.position.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据地图的信息计算出来各个点的情况:occ、free、noinformation</span></span><br><span class="line"><span class="comment">//这样对地图进行标记主要是方便用RVIZ显示出来</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x &lt; smap.getMapSizeX(); x++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>; y &lt; smap.getMapSizeY(); y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// @todo Sort out the unknown vs. free vs. obstacle thresholding</span></span><br><span class="line">        <span class="comment">/// 得到.xy被占用的概率</span></span><br><span class="line">        GMapping::<span class="function">IntPoint <span class="title">p</span><span class="params">(x, y)</span></span>;</span><br><span class="line">        <span class="keyword">double</span> occ=smap.cell(p);</span><br><span class="line">        assert(occ &lt;= <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//unknown</span></span><br><span class="line">        <span class="keyword">if</span>(occ &lt; <span class="number">0</span>)</span><br><span class="line">            map_.<span class="built_in">map</span>.data[MAP_IDX(map_.<span class="built_in">map</span>.info.width, x, y)] = GMAPPING_UNKNOWN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//占用</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(occ &gt; occ_thresh_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//map_.map.data[MAP_IDX(map_.map.info.width, x, y)] = (int)round(occ*100.0);</span></span><br><span class="line">            map_.<span class="built_in">map</span>.data[MAP_IDX(map_.<span class="built_in">map</span>.info.width, x, y)] = GMAPPING_OCC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//freespace</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            map_.<span class="built_in">map</span>.data[MAP_IDX(map_.<span class="built_in">map</span>.info.width, x, y)] = GMAPPING_FREE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//到了这一步，肯定是有地图了。</span></span><br><span class="line">got_map_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//make sure to set the header information on the map</span></span><br><span class="line"><span class="comment">//把计算出来的地图发布出去</span></span><br><span class="line">map_.<span class="built_in">map</span>.header.stamp = ros::Time::now();</span><br><span class="line">map_.<span class="built_in">map</span>.header.frame_id = tf_.resolve( map_frame_ );</span><br><span class="line"></span><br><span class="line">sst_.publish(map_.<span class="built_in">map</span>);</span><br><span class="line">sstm_.publish(map_.<span class="built_in">map</span>.info);</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/12/SLAM工具/OctoMap安装配置/">OctoMap安装配置</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SLAM工具/">SLAM工具</a></span><div class="content"><p>ROS环境下的安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 也可用与非ROS环境</span></span><br><span class="line">sudo apt-get install ros-kinetic-octomap</span><br><span class="line"><span class="comment"># octomap的查看工具</span></span><br><span class="line">sudo apt-get install ros-kinetic-octovis</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p><code>octomap_ros</code>和<code>octomap_msgs</code>提供了消息文件，封装和转换方法。<code>octomap_server</code>提供建图和服务</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>在<code>package.xml</code>中添加：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;octomap&lt;/build_depend&gt;</span><br><span class="line">&lt;run_depend&gt;octomap&lt;/run_depend&gt;</span><br></pre></td></tr></table></figure><p>因为库提供了CMake的config文件，所以直接这样用：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find_package(octomap REQUIRED)</span><br><span class="line">include_directories(<span class="variable">$&#123;OCTOMAP_INCLUDE_DIRS&#125;</span>)</span><br><span class="line">target_link_libraries(<span class="variable">$&#123;OCTOMAP_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/11/PCL点云/点云滤波/">点云滤波</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/PCL点云/">PCL点云</a></span><div class="content"><p>地图分很多种：稀疏的，稠密的，还有半稀疏的。稀疏的地图放大了看就是一个个离散的空间点，不过我们可以把它变成连续的稠密的网格，这个过程也叫点云的网格化。点云网格化需要对点云进行一系列处理</p><p>一般下面这几种情况需要进行点云滤波处理：</p><ol><li><p>点云数据密度不规则需要平滑</p></li><li><p>因为遮挡等问题造成离群点需要去除</p></li><li><p>大量数据需要下采样</p></li><li><p>噪声数据需要去除</p></li></ol><p>滤波模块主要是调用一些封装好的滤波函数，然后根据需要设定一下参数</p><p>滤波对应的方案有如下几种：</p><ul><li>按照给定的规则限制过滤去除点</li><li>通过常用滤波算法修改点的部分属性</li><li>对数据进行下采样</li></ul><h2 id="滤波程序"><a href="#滤波程序" class="headerlink" title="滤波程序"></a>滤波程序</h2><p><code>package.xml</code>中要添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;libpcl-all-dev&lt;/build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;libpcl-all&lt;/exec_depend&gt;</span><br></pre></td></tr></table></figure><p>CMake按照第一篇里进行配置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sensor_msgs/PointCloud2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl_conversions/pcl_conversions.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_cloud.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="comment">//滤波的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/voxel_grid.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ros::Publisher pub;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cloud_cb</span> <span class="params">(<span class="keyword">const</span> sensor_msgs::PointCloud2ConstPtr&amp; cloud_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 声明存储原始数据与滤波后的数据的点云的格式</span></span><br><span class="line">  pcl::PCLPointCloud2* cloud = <span class="keyword">new</span> pcl::PCLPointCloud2; <span class="comment">//原始的点云的数据格式</span></span><br><span class="line">  pcl::<span class="function">PCLPointCloud2ConstPtr <span class="title">cloudPtr</span><span class="params">(cloud)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ROS消息转化为PCL中的点云数据格式</span></span><br><span class="line">  pcl_conversions::toPCL(*cloud_msg, *cloud);</span><br><span class="line"></span><br><span class="line">  pcl::PCLPointCloud2 cloud_filtered;   <span class="comment">//存储滤波后的数据格式</span></span><br><span class="line">  <span class="comment">// 进行一个滤波处理</span></span><br><span class="line">  pcl::VoxelGrid&lt;pcl::PCLPointCloud2&gt; sor; <span class="comment">//创建滤波对象</span></span><br><span class="line">  sor.setInputCloud (cloudPtr);  <span class="comment">//设置输入的滤波，将需要过滤的点云给滤波对象</span></span><br><span class="line">  sor.setLeafSize (<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>);  <span class="comment">//设置滤波时创建的体素大小为1cm立方体</span></span><br><span class="line">  sor.filter (cloud_filtered);<span class="comment">//执行滤波处理，存储输出cloud_filtered</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 再将滤波后的点云的数据格式转换为ROS下的数据格式发布</span></span><br><span class="line">  sensor_msgs::PointCloud2 output;</span><br><span class="line">  pcl_conversions::moveFromPCL(cloud_filtered, output);<span class="comment">//第一个参数是输入，后面的是输出</span></span><br><span class="line">  pub.publish (output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::init (argc, argv, <span class="string">"filter_cloud"</span>);<span class="comment">//声明节点的名称</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  ros::Subscriber sub = nh.subscribe&lt;sensor_msgs::PointCloud2&gt; (<span class="string">"/camera/depth/points"</span>, <span class="number">1</span>, cloud_cb);</span><br><span class="line">  pub = nh.advertise&lt;sensor_msgs::PointCloud2&gt; (<span class="string">"filtered_cloud"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  ros::spin ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/11/OpenCV/CvBridge的使用/">CvBridge的使用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-11</time><div class="content"><p>CvBridge定义了类<code>CvImage</code>，它包含了OpenCV的图像格式,编码和ROS header. <code>CvImage</code>包含的信息和<code>sensor_msgs/Image</code>相同, 所以二者可以互相转换。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cv_bridge &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CvImage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  std_msgs::Header header;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> encoding;</span><br><span class="line">  cv::Mat image;</span><br><span class="line">  <span class="comment">// 把CvImage转为ROS image 消息</span></span><br><span class="line">  sensor_msgs::<span class="function">ImagePtr <span class="title">toImageMsg</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">toImageMsg</span><span class="params">(sensor_msgs::Image&amp; ros_image)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> boost::<span class="built_in">shared_ptr</span>&lt;CvImage&gt; CvImagePtr;</span><br><span class="line"><span class="keyword">typedef</span> boost::<span class="built_in">shared_ptr</span>&lt;CvImage <span class="keyword">const</span>&gt; CvImageConstPtr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>cv_bridge</code>有两种情况：修改原图像数据和不修改，对应两组重载函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Case 1: Always copy, returning a mutable CvImage</span></span><br><span class="line"><span class="function">CvImagePtr <span class="title">toCvCopy</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr&amp; source,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; encoding = <span class="built_in">std</span>::<span class="built_in">string</span>())</span></span>;</span><br><span class="line"><span class="function">CvImagePtr <span class="title">toCvCopy</span><span class="params">(<span class="keyword">const</span> sensor_msgs::Image&amp; source,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; encoding = <span class="built_in">std</span>::<span class="built_in">string</span>())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Case 2: Share if possible, returning a const CvImage</span></span><br><span class="line"><span class="function">CvImageConstPtr <span class="title">toCvShare</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr&amp; source,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; encoding = <span class="built_in">std</span>::<span class="built_in">string</span>())</span></span>;</span><br><span class="line"><span class="function">CvImageConstPtr <span class="title">toCvShare</span><span class="params">(<span class="keyword">const</span> sensor_msgs::Image&amp; source,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> boost::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">void</span> <span class="keyword">const</span>&gt;&amp; tracked_object,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; encoding = <span class="built_in">std</span>::<span class="built_in">string</span>())</span></span>;</span><br></pre></td></tr></table></figure><p>encoding部分，对于深度图，如果指定编码为BGR8，运行会报错，然后无法显示图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[32FC1] is not a color format. but [bgr8] is. The conversion does not make sense</span><br></pre></td></tr></table></figure><h2 id="把ROS深度图转为OpenCV格式"><a href="#把ROS深度图转为OpenCV格式" class="headerlink" title="把ROS深度图转为OpenCV格式"></a>把ROS深度图转为OpenCV格式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;image_transport/image_transport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cv_bridge/cv_bridge.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sensor_msgs/image_encodings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> OPENCV_WINDOW = <span class="string">"Depth Image"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageConverter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ros::NodeHandle nh_;</span><br><span class="line">  image_transport::ImageTransport  it_;</span><br><span class="line">  image_transport::Subscriber image_sub_;</span><br><span class="line">  image_transport::Publisher image_pub_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ImageConverter()</span><br><span class="line">    : it_(nh_)</span><br><span class="line">  &#123;</span><br><span class="line">    image_sub_ = it_.subscribe(<span class="string">"/camera/depth/image"</span>, <span class="number">1</span>,</span><br><span class="line">      &amp;ImageConverter::imageCb, <span class="keyword">this</span>);</span><br><span class="line">    image_pub_ = it_.advertise(<span class="string">"/image_converter/output"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cv::namedWindow(OPENCV_WINDOW);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~ImageConverter()</span><br><span class="line">  &#123;</span><br><span class="line">    cv::destroyWindow(OPENCV_WINDOW);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">imageCb</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cv_bridge::CvImagePtr cv_ptr;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::TYPE_32FC1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (cv_bridge::Exception&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">      ROS_WARN(<span class="string">"cv_bridge exception: %s"</span>, e.what());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在新的图上画一个圆</span></span><br><span class="line">    <span class="keyword">if</span> (cv_ptr-&gt;image.rows &gt; <span class="number">60</span> &amp;&amp; cv_ptr-&gt;image.cols &gt; <span class="number">60</span>)</span><br><span class="line">          cv::circle(cv_ptr-&gt;image, cv::Point(<span class="number">50</span>, <span class="number">50</span>), <span class="number">10</span>, CV_RGB(<span class="number">238</span>,<span class="number">180</span>,<span class="number">34</span>));</span><br><span class="line"></span><br><span class="line">    cv::imshow(OPENCV_WINDOW, cv_ptr-&gt;image);</span><br><span class="line">    cv::waitKey(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    image_pub_.publish(cv_ptr-&gt;toImageMsg());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::init(argc, argv, <span class="string">"image_converter"</span>);</span><br><span class="line">  ImageConverter ic;</span><br><span class="line">  ros::spin();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种格式的深度图对比：<br><img src="https://i.loli.net/2020/06/11/6LOXG7PbUgYuNqy.png" alt="ROS深度图和转换的OpenCV深度图.png"></p><p>不知为什么OpenCV的深度图变成这样了，不知道会不会有问题。</p><p><code>/image_converter/output</code>对应的深度图跟原来的深度图则毫无二致。</p><p>参考：<a href="https://wiki.ros.org/cv_bridge/Tutorials/UsingCvBridgeToConvertBetweenROSImagesAndOpenCVImages#cv_bridge.2FTutorials.2FUsingCvBridgeCppHydro.An_example_ROS_node" target="_blank" rel="noopener">ROS Wiki - cv_bridge</a></p></div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/40/">40</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>