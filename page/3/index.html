<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG={root:"/",algolia:{appId:"RI90VLL69D",apiKey:"20c535e9a1424a7913210eb747d6e67b",indexName:"HexoBlog",hits:{per_page:10},languages:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}.",hits_stats:"${hits} results found in ${time} ms"}},localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">393</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">46</span></a></div></div></div><nav id="nav" style="background-image:url(https://i.loli.net/2020/07/13/QgyrefaLDxhBWSZ.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div><div id="site-social-icons"><a class="social-icon" href="https://github.com/charon-cheung"><i class="fa-github fa"></i></a><a class="social-icon search"><i class="fa fa-search"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/11/PCL点云/点云滤波/">点云滤波</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/PCL点云/">PCL点云</a></span><div class="content"><p>地图分很多种：稀疏的，稠密的，还有半稀疏的。稀疏的地图放大了看就是一个个离散的空间点，不过我们可以把它变成连续的稠密的网格，这个过程也叫点云的网格化。点云网格化需要对点云进行一系列处理</p><p>一般下面这几种情况需要进行点云滤波处理：</p><ol><li><p>点云数据密度不规则需要平滑</p></li><li><p>因为遮挡等问题造成离群点需要去除</p></li><li><p>大量数据需要下采样</p></li><li><p>噪声数据需要去除</p></li></ol><p>滤波模块主要是调用一些封装好的滤波函数，然后根据需要设定一下参数</p><p>滤波对应的方案有如下几种：</p><ul><li>按照给定的规则限制过滤去除点</li><li>通过常用滤波算法修改点的部分属性</li><li>对数据进行下采样</li></ul><h2 id="滤波程序"><a href="#滤波程序" class="headerlink" title="滤波程序"></a>滤波程序</h2><p><code>package.xml</code>中要添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;libpcl-all-dev&lt;/build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;libpcl-all&lt;/exec_depend&gt;</span><br></pre></td></tr></table></figure><p>CMake按照第一篇里进行配置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sensor_msgs/PointCloud2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl_conversions/pcl_conversions.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_cloud.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="comment">//滤波的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/voxel_grid.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ros::Publisher pub;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cloud_cb</span> <span class="params">(<span class="keyword">const</span> sensor_msgs::PointCloud2ConstPtr&amp; cloud_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 声明存储原始数据与滤波后的数据的点云的格式</span></span><br><span class="line">  pcl::PCLPointCloud2* cloud = <span class="keyword">new</span> pcl::PCLPointCloud2; <span class="comment">//原始的点云的数据格式</span></span><br><span class="line">  pcl::<span class="function">PCLPointCloud2ConstPtr <span class="title">cloudPtr</span><span class="params">(cloud)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ROS消息转化为PCL中的点云数据格式</span></span><br><span class="line">  pcl_conversions::toPCL(*cloud_msg, *cloud);</span><br><span class="line"></span><br><span class="line">  pcl::PCLPointCloud2 cloud_filtered;   <span class="comment">//存储滤波后的数据格式</span></span><br><span class="line">  <span class="comment">// 进行一个滤波处理</span></span><br><span class="line">  pcl::VoxelGrid&lt;pcl::PCLPointCloud2&gt; sor; <span class="comment">//创建滤波对象</span></span><br><span class="line">  sor.setInputCloud (cloudPtr);  <span class="comment">//设置输入的滤波，将需要过滤的点云给滤波对象</span></span><br><span class="line">  sor.setLeafSize (<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>);  <span class="comment">//设置滤波时创建的体素大小为1cm立方体</span></span><br><span class="line">  sor.filter (cloud_filtered);<span class="comment">//执行滤波处理，存储输出cloud_filtered</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 再将滤波后的点云的数据格式转换为ROS下的数据格式发布</span></span><br><span class="line">  sensor_msgs::PointCloud2 output;</span><br><span class="line">  pcl_conversions::moveFromPCL(cloud_filtered, output);<span class="comment">//第一个参数是输入，后面的是输出</span></span><br><span class="line">  pub.publish (output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::init (argc, argv, <span class="string">"filter_cloud"</span>);<span class="comment">//声明节点的名称</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  ros::Subscriber sub = nh.subscribe&lt;sensor_msgs::PointCloud2&gt; (<span class="string">"/camera/depth/points"</span>, <span class="number">1</span>, cloud_cb);</span><br><span class="line">  pub = nh.advertise&lt;sensor_msgs::PointCloud2&gt; (<span class="string">"filtered_cloud"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  ros::spin ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/11/OpenCV/CvBridge的使用/">CvBridge的使用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-11</time><div class="content"><p>CvBridge定义了类<code>CvImage</code>，它包含了OpenCV的图像格式,编码和ROS header. <code>CvImage</code>包含的信息和<code>sensor_msgs/Image</code>相同, 所以二者可以互相转换。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cv_bridge &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CvImage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  std_msgs::Header header;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> encoding;</span><br><span class="line">  cv::Mat image;</span><br><span class="line">  <span class="comment">// 把CvImage转为ROS image 消息</span></span><br><span class="line">  sensor_msgs::<span class="function">ImagePtr <span class="title">toImageMsg</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">toImageMsg</span><span class="params">(sensor_msgs::Image&amp; ros_image)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> boost::<span class="built_in">shared_ptr</span>&lt;CvImage&gt; CvImagePtr;</span><br><span class="line"><span class="keyword">typedef</span> boost::<span class="built_in">shared_ptr</span>&lt;CvImage <span class="keyword">const</span>&gt; CvImageConstPtr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>cv_bridge</code>有两种情况：修改原图像数据和不修改，对应两组重载函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Case 1: Always copy, returning a mutable CvImage</span></span><br><span class="line"><span class="function">CvImagePtr <span class="title">toCvCopy</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr&amp; source,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; encoding = <span class="built_in">std</span>::<span class="built_in">string</span>())</span></span>;</span><br><span class="line"><span class="function">CvImagePtr <span class="title">toCvCopy</span><span class="params">(<span class="keyword">const</span> sensor_msgs::Image&amp; source,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; encoding = <span class="built_in">std</span>::<span class="built_in">string</span>())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Case 2: Share if possible, returning a const CvImage</span></span><br><span class="line"><span class="function">CvImageConstPtr <span class="title">toCvShare</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr&amp; source,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; encoding = <span class="built_in">std</span>::<span class="built_in">string</span>())</span></span>;</span><br><span class="line"><span class="function">CvImageConstPtr <span class="title">toCvShare</span><span class="params">(<span class="keyword">const</span> sensor_msgs::Image&amp; source,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> boost::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">void</span> <span class="keyword">const</span>&gt;&amp; tracked_object,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; encoding = <span class="built_in">std</span>::<span class="built_in">string</span>())</span></span>;</span><br></pre></td></tr></table></figure><p>encoding部分，对于深度图，如果指定编码为BGR8，运行会报错，然后无法显示图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[32FC1] is not a color format. but [bgr8] is. The conversion does not make sense</span><br></pre></td></tr></table></figure><h2 id="把ROS深度图转为OpenCV格式"><a href="#把ROS深度图转为OpenCV格式" class="headerlink" title="把ROS深度图转为OpenCV格式"></a>把ROS深度图转为OpenCV格式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;image_transport/image_transport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cv_bridge/cv_bridge.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sensor_msgs/image_encodings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> OPENCV_WINDOW = <span class="string">"Depth Image"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageConverter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ros::NodeHandle nh_;</span><br><span class="line">  image_transport::ImageTransport  it_;</span><br><span class="line">  image_transport::Subscriber image_sub_;</span><br><span class="line">  image_transport::Publisher image_pub_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ImageConverter()</span><br><span class="line">    : it_(nh_)</span><br><span class="line">  &#123;</span><br><span class="line">    image_sub_ = it_.subscribe(<span class="string">"/camera/depth/image"</span>, <span class="number">1</span>,</span><br><span class="line">      &amp;ImageConverter::imageCb, <span class="keyword">this</span>);</span><br><span class="line">    image_pub_ = it_.advertise(<span class="string">"/image_converter/output"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cv::namedWindow(OPENCV_WINDOW);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~ImageConverter()</span><br><span class="line">  &#123;</span><br><span class="line">    cv::destroyWindow(OPENCV_WINDOW);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">imageCb</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cv_bridge::CvImagePtr cv_ptr;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::TYPE_32FC1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (cv_bridge::Exception&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">      ROS_WARN(<span class="string">"cv_bridge exception: %s"</span>, e.what());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在新的图上画一个圆</span></span><br><span class="line">    <span class="keyword">if</span> (cv_ptr-&gt;image.rows &gt; <span class="number">60</span> &amp;&amp; cv_ptr-&gt;image.cols &gt; <span class="number">60</span>)</span><br><span class="line">          cv::circle(cv_ptr-&gt;image, cv::Point(<span class="number">50</span>, <span class="number">50</span>), <span class="number">10</span>, CV_RGB(<span class="number">238</span>,<span class="number">180</span>,<span class="number">34</span>));</span><br><span class="line"></span><br><span class="line">    cv::imshow(OPENCV_WINDOW, cv_ptr-&gt;image);</span><br><span class="line">    cv::waitKey(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    image_pub_.publish(cv_ptr-&gt;toImageMsg());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::init(argc, argv, <span class="string">"image_converter"</span>);</span><br><span class="line">  ImageConverter ic;</span><br><span class="line">  ros::spin();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种格式的深度图对比：<br><img src="https://i.loli.net/2020/06/11/6LOXG7PbUgYuNqy.png" alt="ROS深度图和转换的OpenCV深度图.png"></p><p>不知为什么OpenCV的深度图变成这样了，不知道会不会有问题。</p><p><code>/image_converter/output</code>对应的深度图跟原来的深度图则毫无二致。</p><p>参考：<a href="https://wiki.ros.org/cv_bridge/Tutorials/UsingCvBridgeToConvertBetweenROSImagesAndOpenCVImages#cv_bridge.2FTutorials.2FUsingCvBridgeCppHydro.An_example_ROS_node" target="_blank" rel="noopener">ROS Wiki - cv_bridge</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/05/视觉SLAM/depthimage_to_laserscan 深度图转scan/">depthimage_to_laserscan 深度图转scan</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/视觉SLAM/">视觉SLAM</a></span><div class="content"><p>Kinect扫描的数据是一个深度图像，即一个二维矩阵。二维平面激光雷达扫描的数据是一行，可以理解为一个行向量。</p><p><code>depthimage_to_laserscan</code>包的原理是从深度图中选择一行深度值作为激光雷达的扫描数据，取每一列中深度值最小的作为该列的代表值，然后将每列的最小值<br>按照原列的顺序进行排序，组成一行，作为二维激光雷达的扫描数据。</p><p>因此，如果深度图中存在很多深度值为0的点，那么势必会对产生的激光雷达数据造成一定的影响。最后转换出的laser scan就会有很多的断点，原因在于深度图中有黑洞和边缘噪点。<br><img src="https://i.loli.net/2020/06/03/zd1PxA9ZRHrcBOV.png" alt="Kinect 的伪激光雷达数据图.png"></p><h2 id="depthimage-to-laserscan"><a href="#depthimage-to-laserscan" class="headerlink" title="depthimage_to_laserscan"></a>depthimage_to_laserscan</h2><h3 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h3><p><code>depthimage_to_laserscan</code>包中有一句：<code>generate_dynamic_reconfigure_options(cfg/Depth.cfg)</code></p><p>编译时出错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/env: ‘python\r’: No such file or directory</span><br><span class="line"></span><br><span class="line">depthimage_to_laserscan/CMakeFiles/depthimage_to_laserscan_gencfg.dir/build.make:63: recipe <span class="keyword">for</span> target <span class="string">'/home/hlhp/plan_ws/devel/include/depthimage_to_laserscan/DepthConfig.h'</span> failed</span><br></pre></td></tr></table></figure><p>去掉这句就可以正常编译，但是不能用动态参数调整了。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>运行：<code>rosrun depthimage_to_laserscan depthimage_to_laserscan</code></p><p>源码中的调用关系如下：<br><code>DepthImageToLaserScan.cpp</code>中的main函数<br>&amp;emsp&amp;emsp&amp;emsp&amp;emsp&amp;emsp丨<br>&amp;emsp&amp;emsp&amp;emsp&amp;emsp&amp;emsp丨<br><code>DepthImageToLaserScanROS</code> 构造函数<br>&amp;emsp&amp;emsp&amp;emsp&amp;emsp&amp;emsp丨<br>&amp;emsp&amp;emsp&amp;emsp&amp;emsp&amp;emsp丨<br><code>pub_ = n.advertise&lt;sensor_msgs::LaserScan&gt;(&quot;scan&quot;, 10, boost::bind(&amp;DepthImageToLaserScanROS::connectCb, this, _1), boost::bind(&amp;DepthImageToLaserScanROS::disconnectCb, this, _1));</code><br>&amp;emsp&amp;emsp&amp;emsp&amp;emsp&amp;emsp丨<br>&amp;emsp&amp;emsp&amp;emsp&amp;emsp&amp;emsp丨<br><code>DepthImageToLaserScanROS::connectCb</code><br>&amp;emsp&amp;emsp&amp;emsp&amp;emsp&amp;emsp丨<br>&amp;emsp&amp;emsp&amp;emsp&amp;emsp&amp;emsp丨<br><code>subscribeCamera(&quot;image&quot;)</code>，这里应当改为<code>/camera/depth/image_raw</code>，或者用remap机制修改。</p><p>算法的核心函数是<code>DepthImageToLaserScan.h</code>中的<code>convert</code><br><br></p><p><code>sensor_msgs/LaserScan</code> overlayed in color on the <code>sensor_msgs/Image</code>. 红色是靠近摄像头，紫色远离摄像头。</p><p><code>depthimage_to_laserscan</code>处理的是深度图(float encoded meters 或者 uint16 encoded millimeters for OpenNI devices)，根据提供的参数产生2D雷达scan. 它使用的是&lt;font size =4,color=blue&gt;lazy 订阅机制 直到其他节点订阅<code>scan</code>，才会订阅<code>image</code>或者<code>camera_info</code>.也就是上面的advertise函数中的bind占位符做参数。</p><p>生成的scan参数如下：<br><img src="https://i.loli.net/2020/06/04/4if8Ww2OnQYXxpT.png" alt="pic_031.png"></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>但是默认<code>depthimage_to_laserscan</code>转化的数据<font color="blue" size="3">实际上还是只能检测到平行kinect的障碍物 </font>，而较低的障碍物或者较高的障碍物检测不到。ranges[]数组体现了横向每个障碍点到kinect距离。但是实际，纵向扫描的高度极为苛刻。</p><p>比如，在距离kinect不到1米处，放一个较低的障碍，图像如下：<br><img src="https://i.loli.net/2020/06/04/v3NGX5LzEYxPRks.png" alt="rgbd.png"><br><img src="https://i.loli.net/2020/06/04/tL5dvSjW7UeZu1D.png" alt="depth.png"><br>但是经过转换，结果没看到低障碍的scan结果，现实世界的实际距离是通过深度图像转化的，而scan_hight是针对深度图像扫描高度。</p><p>这种情况下，节点的动态参数调整机制就发挥作用了，<code>rosrun rqt_reconfigure rqt_reconfigure</code>启动，然后调整<code>scan_height</code><br><img src="https://i.loli.net/2020/06/04/zosRTk8Xgpx3fnQ.png" alt="reconfigure.png"></p><p>发现调到180左右就能扫描到0.8米处的低障碍，但是其他部分的scan会有变化.再大于180，低障碍一直能扫描到，但远处障碍的扫描结果又会变化，很难找到我们需要的<code>scan_heigth</code>。因为<code>scan_hight</code>对扫面的高度影响极小，但对远处的障碍物影响很大，何况kinect还有明显的噪声。<br><img src="https://i.loli.net/2020/06/04/IqpZn1B9oxPu3i7.png" alt="调整scan_height后的scan.png"></p><p>即使障碍物在Kinect水平视角内，可能也因为障碍物离kinect太近，以致不在Kinect的竖直视角内。结果kinect会把障碍物后面的墙当做障碍。修改参数会让机器人和障碍之间的最小距离更小，但最终使地面被当成障碍物了。</p><p>参考：<br><a href="http://wiki.ros.org/depthimage_to_laserscan" target="_blank" rel="noopener">depthimage_to_laserscan</a><br><a href="https://www.cnblogs.com/cv-pr/p/5725831.html" target="_blank" rel="noopener">深度图转激光原理</a><br><a href="https://answers.ros.org/question/187694/depthimage_to_laserscan-choose-which-part-of-the-image-is-scanned/" target="_blank" rel="noopener">1个kinect生成3个scan</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/04/激光SLAM/laser_scan_matcher/">laser_scan_matcher</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/其他/">其他</a></span><div class="content"><p><code>laser_scan_matcher</code>是一个增量式的scan配准工具. 在连续的<code>sensor_msgs/LaserScan</code>消息之间进行<strong>scan match</strong>, 把laser的估计位姿以<code>geometry_msgs/Pose2D</code>消息发布，产生tf变换。</p><p>可以不需要里程计信息的输入，当然也可以提供里程计以提高配准的速度和精度。</p><p>可以支持<code>sensor_msgs/PointCloud2</code>消息，但要保证没有nan值</p><p>包里的demo.bag是手持一个Hokuyo雷达的移动结果，当然没有里程计。</p><h3 id="话题和tf"><a href="#话题和tf" class="headerlink" title="话题和tf"></a>话题和tf</h3><p>订阅:</p><ul><li>scan (sensor_msgs/LaserScan) Scans from a laser range-finder</li><li>cloud (sensor_msgs/PointCloud2) Scans in point cloud form</li><li>imu/data (sensor_msgs/Imu) Imu messages, used for theta prediction. Only used if 参数<code>use_imu</code> is set to true.</li><li>odom (nav_msgs/Odometry) Odometry messages, used for x-, y-, and theta prediction. Only used if 参数<code>use_odom</code> is set to true.</li></ul><p>发布:</p><ul><li><p>pose2D (geometry_msgs/Pose2D) The pose of the base frame, in some fixed (world) frame</p></li><li><p>需要的tf: base_link——laser, the pose of the laser in the base frame.</p></li><li><p>提供的tf: world——base_link, the pose of the robot base in the world frame. Only provided when publish_tf is enabled.</p></li></ul><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><code>~fixed_frame</code> (string, default: “world”): the fixed frame，可以改为odom</li><li><code>~base_frame</code> (string, default: “base_link”): the base frame of the robot</li></ul><h4 id="Motion-prediction"><a href="#Motion-prediction" class="headerlink" title="Motion prediction"></a>Motion prediction</h4><ul><li><p><code>~use_imu</code> (bool, default: true) Whether to use an imu for the theta prediction of the scan registration. Requires input on /imu/data topic.</p></li><li><p><code>~use_odom</code> (bool, default: true) Whether to use wheel odometry for the x-, y-, and theta prediction of the scan registration. Requires input on odom topic.</p></li><li><p><code>~use_vel</code> (bool, default: false) Whether to use constant velocity model for the x-, y-, and theta prediction of the scan registration. Requires input on vel topic.</p></li></ul><p><a href="http://wiki.ros.org/laser_scan_matcher" target="_blank" rel="noopener">官网的剩余参数</a></p><p>首先尝试一下两帧激光匹配,当时我把 processScan函数重构了一下, 现在想想完全没必要．把imu和odom都关掉后,只凭scan就能两帧激光匹配,可以使用这个包作为初始化位姿,代替里程计不准的情况,时间长了会有累计误差,后期用amcl定位,加其他传感器.</p><h2 id="在小强机器人的使用"><a href="#在小强机器人的使用" class="headerlink" title="在小强机器人的使用"></a>在小强机器人的使用</h2><p>注释StatusPublisher.cpp的部分代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mOdomPub = mNH.advertise&lt;nav_msgs::Odometry&gt;(<span class="string">"xqserial_server/Odom"</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">mOdomPub.publish(CarOdom);</span><br><span class="line"></span><br><span class="line">br.sendTransform(tf::StampedTransform(transform, current_time.fromSec(base_time_), <span class="string">"odom"</span>, <span class="string">"base_footprint"</span>));</span><br></pre></td></tr></table></figure><p>注释xqserial.launch部分:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"tf"</span> <span class="attr">type</span>=<span class="string">"static_transform_publisher"</span> <span class="attr">name</span>=<span class="string">"baselink_broadcaster"</span> <span class="attr">args</span>=<span class="string">"0 0 0.15 0 0 0 1 base_footprint base_link 50"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编辑<code>laser_scan_matcher</code>中的<code>rplidar.launch</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"$(find rplidar_ros)/launch/a2.launch"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"laser_scan_matcher"</span> <span class="attr">type</span>=<span class="string">"laser_scan_matcher_node"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">name</span>=<span class="string">"laser_scan_matcher_node"</span> <span class="attr">output</span>=<span class="string">"screen"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"publish_tf"</span> <span class="attr">value</span> = <span class="string">"true"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"fixed_frame"</span> <span class="attr">value</span> = <span class="string">"odom"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"max_iterations"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动<code>startup</code>, <code>roslaunch laser_scan_matcher rplidar.launch</code>. 现在原来的轮式坐标系odom坐标系换成了激光坐标系<font color="blue" size="3"> odom</font></p><p>现在tf变换是: <strong>map —&gt; world —&gt; base_link —&gt; laser</strong></p><p>经过tf_echo测试，发现map到base_link的变换稍微不稳定，不过也可接受，两两坐标系之间的变换比较稳定。</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/03/视觉SLAM/Kinect深度图/">Kinect深度图</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/视觉SLAM/">视觉SLAM</a></span><div class="content"><p>深度图不受阴影、光照、色度的影响。</p><p>深度图的各个像素点和实际中的对应坐标值通过标定矩阵匹配的方法获取环境信息的三维点云。每一帧深度图上的y坐标和z坐标代表深度图中的像素单位，不是实际世界坐标。</p><p>kinect深度在<code>0.5~8</code>米，随着距离的增加而精度下降，推荐深度范围1-4米</p><p>Kinect最显著的缺点就是水平视场角太小。</p><p>深度图的z轴正向为相机前方</p><p>kinect——深度图点云数据——特征提取——特征匹配——建图</p><h2 id="噪声和修复"><a href="#噪声和修复" class="headerlink" title="噪声和修复"></a>噪声和修复</h2><p>深度图中有黑洞和边缘噪点。这就是测量噪声，而且深度相机的测量噪声随着测量距离的变大而变大</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/03/激光SLAM/gmapping/(六) 源码分析4  processScan函数/">(六) 源码分析4 processScan函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/gmapping/">gmapping</a></span><div class="content"><p>当前位姿与上一次位姿做差，计算做累计角度偏差和位移偏差。利用激光雷达测得距离做得分处理。非首帧调用scanMatch，upDateTreeWeight,resample。首帧则调用invalidActiveArea,computeActiveArea,registerScan。</p><h2 id="第1部分"><a href="#第1部分" class="headerlink" title="第1部分"></a>第1部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> GridSlamProcessor::processScan(<span class="keyword">const</span> RangeReading &amp; reading, <span class="keyword">int</span> adaptParticles)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* retireve the position from the reading, and compute the odometry */</span></span><br><span class="line">    <span class="comment">/*当前雷达在里程计坐标系的位置  addScan最后的setPose */</span></span><br><span class="line">    OrientedPoint relPose = reading.getPose();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*m_count表示这个函数被调用的次数，开始为0,如果是第0次调用,则所有的位姿都是一样的*/</span></span><br><span class="line">    <span class="keyword">if</span> (!m_count)</span><br><span class="line">	   m_lastPartPose = m_odoPose = relPose;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*对于每一个粒子，都从里程计运动模型中采样，得到车子的初步估计位置  这一步对应里程计的更新 */</span></span><br><span class="line">    <span class="keyword">int</span> tmp_size = m_particles.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个for循环显然可以用 OpenMP 进行并行化</span></span><br><span class="line">    <span class="keyword">for</span> (ParticleVector::iterator it=m_particles.begin(); it!=m_particles.end(); it++)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="function">OrientedPoint&amp; <span class="title">pose</span><span class="params">(it-&gt;pose)</span></span>;      <span class="comment">// 上一时刻粒子的位姿</span></span><br><span class="line">        <span class="comment">// relPose是里程计记录的最新位姿， m_odoPose是建图引擎记录的上一时刻的位姿</span></span><br><span class="line">        <span class="comment">// pose就是it-&gt;pose加了噪声，由于上面是引用，所以m_particles容器的成员pose全更新为pose</span></span><br><span class="line">        pose=m_motionModel.drawFromMotion(it-&gt;pose, relPose, m_odoPose);</span><br><span class="line">    &#125;</span><br><span class="line">    onOdometryUpdate();  <span class="comment">/*回调函数，什么都没做，可以自己修改*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据两次里程计的数据,计算机器人的线性位移和角度位移的累积值</span></span><br><span class="line">    <span class="comment">// m_odoPose表示上一次的里程计位姿   relPose表示新的里程计的位姿</span></span><br><span class="line">    OrientedPoint move = relPose - m_odoPose;</span><br><span class="line">    move.theta=<span class="built_in">atan2</span>(<span class="built_in">sin</span>(move.theta), <span class="built_in">cos</span>(move.theta));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计机器人在进行激光雷达更新之前， 走了多远的距离  以及　平移了多少的角度</span></span><br><span class="line">    <span class="comment">// 这两个变量最后还是要清零</span></span><br><span class="line">    m_linearDistance+=<span class="built_in">sqrt</span>(move*move);   <span class="comment">// x²+y²的开方</span></span><br><span class="line">    m_angularDistance+=<span class="built_in">fabs</span>(move.theta);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the robot jumps throw a warning</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     如果机器人在走了m_distanceThresholdCheck这么远的距离都没有进行激光雷达的更新</span></span><br><span class="line"><span class="comment">     则需要进行报警。这个误差很可能是里程计或者激光雷达的BUG造成的。</span></span><br><span class="line"><span class="comment">     例如里程计数据出错 或者 激光雷达很久没有数据等等</span></span><br><span class="line"><span class="comment">     每次进行激光雷达的更新之后 m_linearDistance这个参数就会清零</span></span><br><span class="line"><span class="comment">      m_distanceThresholdCheck在开头定义为5 */</span></span><br><span class="line">    <span class="keyword">if</span> (m_linearDistance &gt; m_distanceThresholdCheck)</span><br><span class="line">    &#123;</span><br><span class="line">			<span class="comment">/*------- 一堆报警内容 -------*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新:把当前的位置赋值给旧的位置</span></span><br><span class="line">    m_odoPose = relPose;</span><br><span class="line">     <span class="comment">//先声明为false，最后如果成功就赋值 true</span></span><br><span class="line">    <span class="keyword">bool</span> processed=<span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 只有当机器人走过一定的距离或者旋转过一定的角度,或者过一段指定的时间才处理激光数据</span></span><br><span class="line">    <span class="comment">// 否则太低效了，period_被构造函数写死成5秒，可以考虑修改</span></span><br><span class="line">    <span class="keyword">if</span> ( ! m_count  ||   m_linearDistance &gt;=m_linearThresholdDistance</span><br><span class="line">            || m_angularDistance &gt;=m_angularThresholdDistance</span><br><span class="line">            || (period_ &gt;= <span class="number">0.0</span> &amp;&amp; (reading.getTime() - last_update_time_) &gt; period_) )</span><br><span class="line">    &#123;</span><br><span class="line">   			<span class="comment">/*第2部分*/</span></span><br><span class="line">	&#125;</span><br><span class="line">    m_readingCount++;</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ScanMatcher-构造函数"><a href="#ScanMatcher-构造函数" class="headerlink" title="ScanMatcher 构造函数"></a>ScanMatcher 构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ScanMatcher::ScanMatcher(): m_laserPose(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    line_angle = <span class="number">0.0</span>;</span><br><span class="line">    m_laserBeams=<span class="number">0</span>;</span><br><span class="line">    m_optRecursiveIterations=<span class="number">9</span>;</span><br><span class="line">    m_activeAreaComputed=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5cm解析度的默认参数</span></span><br><span class="line">    <span class="comment">// 这个参数是计算似然位姿的时候使用的，实际的gmapping中没有用到</span></span><br><span class="line">    m_llsamplerange=<span class="number">0.01</span>;</span><br><span class="line">    m_llsamplestep=<span class="number">0.01</span>;</span><br><span class="line">    m_lasamplerange=<span class="number">0.005</span>;</span><br><span class="line">    m_lasamplestep=<span class="number">0.005</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//地图进行拓展的大小</span></span><br><span class="line">    m_enlargeStep=<span class="number">10.</span>;</span><br><span class="line">    m_fullnessThreshold=<span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指示里程计和陀螺仪是否可靠</span></span><br><span class="line">    <span class="comment">//如果可靠的话，那么进行score计算的时候，就需要对离里程计数据比较远的位姿增加惩罚</span></span><br><span class="line">    <span class="comment">//对于我们的应用来说，陀螺仪在短期内还是很可靠的。</span></span><br><span class="line">    m_angularOdometryReliability=<span class="number">0.</span>;</span><br><span class="line">    m_linearOdometryReliability=<span class="number">0.</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//理论上的离激光点的空闲距离 也就是说沿着激光束方向离激光点这么远距离的栅格一定是空闲的。</span></span><br><span class="line">    m_freeCellRatio=<span class="built_in">sqrt</span>(<span class="number">2.</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跳过一帧激光数据的开始几束激光</span></span><br><span class="line">    m_initialBeamsSkip=<span class="number">0</span>;   </span><br><span class="line">    m_linePoints = <span class="keyword">new</span> IntPoint[<span class="number">20000</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全是参数赋值，但是全写死，不能通过ROS修改</p><h3 id="drawFromMotion-里程计运动模型"><a href="#drawFromMotion-里程计运动模型" class="headerlink" title="drawFromMotion 里程计运动模型"></a>drawFromMotion 里程计运动模型</h3><ul><li>p 表示粒子估计的最优位置(机器人上一个时刻的最优位置)</li><li>pnew 表示里程计算出来的新的位置</li><li>pold 表示建图引擎记录的上一时刻的位姿(即上一个里程计的位置)</li></ul><p>不是执行圆加运算，pnew和pold只是用于产生噪声控制量，然后加到p上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">OrientedPoint </span><br><span class="line">MotionModel::drawFromMotion(<span class="keyword">const</span> OrientedPoint&amp; p, <span class="keyword">const</span> OrientedPoint&amp; pnew, <span class="keyword">const</span> OrientedPoint&amp; pold) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> sxy=<span class="number">0.3</span>*srr;</span><br><span class="line">     <span class="comment">// 计算出pnew 相对于 pold走了多少距离，得到控制量</span></span><br><span class="line">     <span class="comment">// 这里的距离表达是相对于车身坐标系来说的</span></span><br><span class="line">    OrientedPoint delta=absoluteDifference(pnew, pold);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*初始化一个点*/</span></span><br><span class="line">    <span class="function">OrientedPoint <span class="title">noisypoint</span><span class="params">(delta)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*走过的三个方向的距离，为控制量添加上噪声项*/</span></span><br><span class="line">    noisypoint.x+=sampleGaussian(srr*<span class="built_in">fabs</span>(delta.x)+str*<span class="built_in">fabs</span>(delta.theta)+sxy*<span class="built_in">fabs</span>(delta.y));</span><br><span class="line">    noisypoint.y+=sampleGaussian(srr*<span class="built_in">fabs</span>(delta.y)+str*<span class="built_in">fabs</span>(delta.theta)+sxy*<span class="built_in">fabs</span>(delta.x));</span><br><span class="line">    noisypoint.theta+=sampleGaussian(stt*<span class="built_in">fabs</span>(delta.theta)+srt*<span class="built_in">sqrt</span>(delta.x*delta.x+delta.y*delta.y));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*限制角度的范围为 -π～π  */</span></span><br><span class="line">    noisypoint.theta=<span class="built_in">fmod</span>(noisypoint.theta, <span class="number">2</span>*M_PI);</span><br><span class="line">    <span class="keyword">if</span> (noisypoint.theta&gt;M_PI)</span><br><span class="line">        noisypoint.theta-=<span class="number">2</span>*M_PI;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*把加入了噪声的控制量 加到粒子估计的最优的位置上，得到新的粒子位姿的预估(根据运动模型推算)*/</span></span><br><span class="line">    <span class="keyword">return</span> absoluteSum(p,noisypoint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的MotionModel是一个十分粗糙的运动模型，只是简单的矢量加减运算。 相比于<code>《Probabilistic Robotics》</code>中提到的速度模型和里程计模型而言，有很多方面都没有考虑，精度上可能有折扣。</p><h2 id="第2部分-if中的处理激光数据"><a href="#第2部分-if中的处理激光数据" class="headerlink" title="第2部分 if中的处理激光数据"></a>第2部分 if中的处理激光数据</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">last_update_time_ = reading.getTime();</span><br><span class="line"><span class="comment">/*复制一帧数据 把激光数据转换为scan-match需要的格式*/</span></span><br><span class="line"><span class="keyword">int</span> beam_number = reading.getSize();</span><br><span class="line"><span class="keyword">double</span> * plainReading = <span class="keyword">new</span> <span class="keyword">double</span>[beam_number];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;beam_number; i++)</span><br><span class="line">&#123;</span><br><span class="line">    plainReading[i]=reading.m_dists[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果不是第一帧数据*/</span></span><br><span class="line"><span class="keyword">if</span> (m_count&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	  为每个粒子进行scanMatch，计算出来每个粒子的最优位姿，同时计算该最优位姿的得分和似然  对应于gmapping论文中的用最近的一次测量计算proposal的算法</span></span><br><span class="line"><span class="comment">	  除了进行scanMatch之外，还对粒子进行了权重的计算，并计算了粒子的有效区域，但不进行内存分配 内存分配在resample()函数中</span></span><br><span class="line"><span class="comment">	  这个函数在gridslamprocessor.hxx里</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    scanMatch(plainReading);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//至此 关于proposal的更新完毕了，接下来是计算权重</span></span><br><span class="line">    onScanmatchUpdate();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	  由于scanMatch中对粒子的权重进行了更新，那么这个时候各个粒子的轨迹上的累计权重都需要重新计算</span></span><br><span class="line"><span class="comment">	  这个函数即更新各个粒子的轨迹上的累计权重是更新</span></span><br><span class="line"><span class="comment">	  GridSlamProcessor::updateTreeWeights(bool weightsAlreadyNormalized) 函数在gridslamprocessor_tree.cpp里面实现</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    updateTreeWeights(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     粒子重采样  根据neff的大小来进行重采样  不但进行了重采样，也对地图进行更新</span></span><br><span class="line"><span class="comment">     GridSlamProcessor::resample 函数在gridslamprocessor.hxx里面实现</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span>&lt;&lt;<span class="string">"plainReading:"</span>&lt;&lt;m_beams&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    resample(plainReading, adaptParticles, reading_copy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果是第一帧激光数据*/</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果是第一帧数据，则可以直接计算activeArea。因为这个时候，对机器人的位置是非常确定的，就是(0,0,0)</span></span><br><span class="line">    <span class="keyword">for</span> (ParticleVector::iterator it=m_particles.begin(); it!=m_particles.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        m_matcher.invalidateActiveArea();</span><br><span class="line">        m_matcher.computeActiveArea(it-&gt;<span class="built_in">map</span>, it-&gt;pose, plainReading);</span><br><span class="line">        m_matcher.registerScan(it-&gt;<span class="built_in">map</span>, it-&gt;pose, plainReading);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为每个粒子创建路径的第一个节点。该节点的权重为0,父节点为it-&gt;node(这个时候为NULL)。</span></span><br><span class="line">        <span class="comment">//因为第一个节点就是轨迹的根，所以没有父节点</span></span><br><span class="line">        TNode* node=<span class="keyword">new</span>	TNode(it-&gt;pose, <span class="number">0.</span>, it-&gt;node,  <span class="number">0</span>);</span><br><span class="line">        node-&gt;reading = reading_copy;</span><br><span class="line">        it-&gt;node=node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//	"Tree: normalizing, resetting and propagating weights at the end..." ;</span></span><br><span class="line"><span class="comment">//进行重采样之后，粒子的权重又会发生变化，因此需要再次更新粒子轨迹的累计权重</span></span><br><span class="line"><span class="comment">//GridSlamProcessor::updateTreeWeights(bool weightsAlreadyNormalized) 函数在gridslamprocessor_tree.cpp里面实现</span></span><br><span class="line">updateTreeWeights(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> [] plainReading;</span><br><span class="line">m_lastPartPose=m_odoPose; <span class="comment">//update the past pose for the next iteration</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//机器人累计行走的多远的路程没有进行里程计的更新 每次更新完毕之后都要把这个数值清零</span></span><br><span class="line">m_linearDistance=<span class="number">0</span>;</span><br><span class="line">m_angularDistance=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">m_count++;</span><br><span class="line">processed=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//keep ready for the next step</span></span><br><span class="line"><span class="keyword">for</span> (ParticleVector::iterator it=m_particles.begin(); it!=m_particles.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    it-&gt;previousPose=it-&gt;pose;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/02/激光SLAM/gmapping/(四) 源码分析2  initMapper 第2部分/">(四) 源码分析2 initMapper 第2部分</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/gmapping/">gmapping</a></span><div class="content"><h2 id="initMapper-第2部分"><a href="#initMapper-第2部分" class="headerlink" title="initMapper 第2部分"></a>initMapper 第2部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 激光的名称必须是"FLASER"</span></span><br><span class="line"><span class="comment">// 传入计算的angle increment绝对值, 因为gmapping接受正的angle increment</span></span><br><span class="line"><span class="comment">// 根据上面得到的激光雷达的数据信息， 初始化一个激光传感器</span></span><br><span class="line">gsp_laser_ = <span class="keyword">new</span> GMapping::RangeSensor(<span class="string">"FLASER"</span>,</span><br><span class="line">                                       gsp_laser_beam_count_,</span><br><span class="line">                                       <span class="built_in">fabs</span>(scan.angle_increment),</span><br><span class="line">                                       gmap_pose,   <span class="comment">// (0,0,0)</span></span><br><span class="line">                                       <span class="number">0.0</span>,</span><br><span class="line">                                       maxRange_);</span><br><span class="line">ROS_ASSERT(gsp_laser_);</span><br><span class="line"><span class="comment">// std::map&lt;std::string, Sensor*&gt;</span></span><br><span class="line">GMapping::SensorMap  smap;</span><br><span class="line"><span class="comment">// getName()就是 FLASER</span></span><br><span class="line">smap.insert(make_pair(gsp_laser_-&gt;getName(), gsp_laser_));</span><br><span class="line">gsp_-&gt;setSensorMap(smap);   <span class="comment">// GMapping::GridSlamProcessor*</span></span><br><span class="line"><span class="comment">// 构造函数里只有变量的赋值</span></span><br><span class="line">gsp_odom_ = <span class="keyword">new</span> GMapping::OdometrySensor(odom_frame_);</span><br><span class="line">ROS_ASSERT(gsp_odom_);</span><br><span class="line"></span><br><span class="line"><span class="comment">///得到里程计的初始位姿，如果没有，则把初始位姿设置为(0,0,0)</span></span><br><span class="line">GMapping::OrientedPoint  initialPose;</span><br><span class="line"><span class="keyword">if</span>(!getOdomPose(initialPose, scan.header.stamp))</span><br><span class="line">&#123;</span><br><span class="line">  ROS_WARN(<span class="string">"Unable to determine inital pose of laser! Starting point will be set to zero."</span>);</span><br><span class="line">  initialPose = GMapping::OrientedPoint(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下全是参数的设置，纯粹变量赋值，不多不少</span></span><br><span class="line">gsp_-&gt;setMatchingParameters(maxUrange_, maxRange_, sigma_,</span><br><span class="line">                            kernelSize_, lstep_, astep_, iterations_,</span><br><span class="line">                            lsigma_, ogain_, lskip_);</span><br><span class="line"></span><br><span class="line">gsp_-&gt;setMotionModelParameters(srr_, srt_, str_, stt_);</span><br><span class="line">gsp_-&gt;setUpdateDistances(linearUpdate_, angularUpdate_, resampleThreshold_);</span><br><span class="line">gsp_-&gt;setUpdatePeriod(temporalUpdate_);</span><br><span class="line">gsp_-&gt;setgenerateMap(<span class="literal">false</span>);</span><br><span class="line">gsp_-&gt;GridSlamProcessor::init(particles_, xmin_, ymin_, xmax_, ymax_,</span><br><span class="line">                              delta_, initialPose);</span><br><span class="line">gsp_-&gt;setllsamplerange(llsamplerange_);</span><br><span class="line">gsp_-&gt;setllsamplestep(llsamplestep_);</span><br><span class="line">gsp_-&gt;setlasamplerange(lasamplerange_);</span><br><span class="line">gsp_-&gt;setlasamplestep(lasamplestep_);</span><br><span class="line">gsp_-&gt;setminimumScore(minimum_score_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成1作为方差，均值为0的高斯分布</span></span><br><span class="line">GMapping::sampleGaussian(<span class="number">1</span>, seed_);</span><br><span class="line"></span><br><span class="line">ROS_INFO(<span class="string">"Mapper Initialization complete"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h3 id="getOdomPose"><a href="#getOdomPose" class="headerlink" title="getOdomPose"></a>getOdomPose</h3><p>获得<code>centered_laser_pose_</code> (laser坐标系的原点, 方向(0,0,angle_center)) 在odom坐标系中的坐标<code>gmap_pose</code>，即scan消息的时间戳时，激光雷达在里程计坐标系中的位姿</p><p>调用： <code>getOdomPose(initialPose, scan.header.stamp)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line">SlamGMapping::getOdomPose(GMapping::OrientedPoint&amp; gmap_pose, <span class="keyword">const</span> ros::Time&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Get the pose of the centered laser at the right time</span></span><br><span class="line">  centered_laser_pose_.stamp_ = t;</span><br><span class="line"></span><br><span class="line">  tf::Stamped&lt;tf::Transform&gt; odom_pose;</span><br><span class="line">  <span class="comment">// 得到centered_laser_pose_ 在odom坐标系中的坐标 odom_pose</span></span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    tf_.transformPose(odom_frame_, centered_laser_pose_, odom_pose);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(tf::TransformException e)</span><br><span class="line">  &#123;</span><br><span class="line">    ROS_WARN(<span class="string">"Failed to compute odom pose, skipping scan (%s)"</span>, e.what());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">double</span> yaw = tf::getYaw(odom_pose.getRotation());</span><br><span class="line">  ROS_INFO(<span class="string">"get centered_laser_pose_'s odom pose: yaw: %f"</span>, yaw);</span><br><span class="line">  ROS_INFO(<span class="string">"centered_laser_pose_'s odom pose:: %f %f %f"</span>,odom_pose.getOrigin().x(), odom_pose.getOrigin().y(), odom_pose.getOrigin().z());</span><br><span class="line">  gmap_pose = GMapping::OrientedPoint(odom_pose.getOrigin().x(),</span><br><span class="line">                                      odom_pose.getOrigin().y(), yaw);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="sampleGaussian"><a href="#sampleGaussian" class="headerlink" title="sampleGaussian"></a>sampleGaussian</h3><p>S是随机数种子，保证每次的高斯分布不同。AMCL源码中是<code>pf_pdf_gaussian_sample</code>函数中调用<code>pf_ran_gaussian</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sampleGaussian</span><span class="params">(<span class="keyword">double</span> sigma, <span class="keyword">unsigned</span> <span class="keyword">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       srand(S);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sigma==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> pf_ran_gaussian (sigma);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="GridSlamProcessor-init"><a href="#GridSlamProcessor-init" class="headerlink" title="GridSlamProcessor::init"></a>GridSlamProcessor::init</h3><p>GridFastSLAM初始化主要是用来初始化各个粒子的一些信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GridSlamProcessor::init(<span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">double</span> xmin, <span class="keyword">double</span> ymin, <span class="keyword">double</span> xmax, <span class="keyword">double</span> ymax, <span class="keyword">double</span> delta, OrientedPoint initialPose)</span><br><span class="line">&#123;</span><br><span class="line">  　　<span class="comment">//设置地图大小和分辨率</span></span><br><span class="line">   　m_xmin=xmin;</span><br><span class="line">    m_ymin=ymin;</span><br><span class="line">    m_xmax=xmax;</span><br><span class="line">    m_ymax=ymax;</span><br><span class="line">    m_delta=delta;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*设置每个粒子的初始值*/</span></span><br><span class="line">    m_particles.clear();    <span class="comment">// vector&lt;Particle&gt;</span></span><br><span class="line">    TNode* node=<span class="keyword">new</span> TNode(initialPose, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//粒子对应的地图进行初始化 用两个地图来进行初始化 一个高分辨率地图 一个低分辨率地图</span></span><br><span class="line">    <span class="comment">//高分辨率地图由自己指定 低分辨率地图固定为0.1m</span></span><br><span class="line">    <span class="comment">//定义最终使用的地图数据类型 cell类型为 PointAccumulator 存储数据类型为HierarchicalArray2D&lt;PointAccumulator&gt;</span></span><br><span class="line">    <span class="comment">// typedef Map&lt;PointAccumulator,HierarchicalArray2D&lt;PointAccumulator&gt; &gt; ScanMatcherMap;</span></span><br><span class="line">    <span class="function">ScanMatcherMap <span class="title">lmap</span><span class="params">(Point(xmin+xmax, ymin+ymax)*<span class="number">.5</span>, xmax-xmin, ymax-ymin, delta)</span></span>;</span><br><span class="line">    <span class="function">ScanMatcherMap <span class="title">lowMap</span><span class="params">(Point(xmin+xmax,ymin+ymax)*<span class="number">0.5</span>,xmax-xmin,ymax-ymin,　<span class="number">0.1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)    <span class="comment">// size是粒子数</span></span><br><span class="line">    &#123;</span><br><span class="line">      m_particles.push_back(Particle(lmap,lowMap));</span><br><span class="line">      <span class="comment">//m_particles.push_back(Particle(lmap));</span></span><br><span class="line">      m_particles.back().pose　=　initialPose;</span><br><span class="line">      <span class="comment">// 开始时，前一帧的粒子位姿也是 initialPose</span></span><br><span class="line">      m_particles.back().previousPose　=　initialPose;</span><br><span class="line">      m_particles.back().setWeight(<span class="number">0</span>);</span><br><span class="line">      m_particles.back().previousIndex=<span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// we use the root directly</span></span><br><span class="line">      m_particles.back().node= node;</span><br><span class="line">    &#125;</span><br><span class="line">    m_neff=(<span class="keyword">double</span>)size;</span><br><span class="line">    m_count=<span class="number">0</span>;</span><br><span class="line">    m_readingCount=<span class="number">0</span>;</span><br><span class="line">    m_linearDistance=m_angularDistance=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/01/视觉SLAM/基于Kinect的机器人导航/">研究融合Kinect+Laser的二维scan导航</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/视觉SLAM/">视觉SLAM</a></span><div class="content"><p>因为二维雷达只能扫描一个平面，所以低于或高于这个平面的障碍物扫描不到，机器人也就难以进行建图和导航。当然可以用3D雷达，但是这个成本一下大了很多，对于室内环境太奢侈了。</p><p>由于kinect具有一定的水平和垂直视角，它的FOV可以覆盖不同高度的障碍。深度图可以转化为scan，这样就可以把障碍物投影到二维地图上了，把kinect和雷达融合，就可以解决这个问题了。</p><p>阅读了几篇论文，把这个方案总结了一下，但是感觉没有多少可行性，那些论文只能用于研究。其实想想，kinect这么廉价的东西，跟雷达相比，它转换出的scan肯定不如雷达，这么一融合，恐怕够呛。</p><p>基本的思路是这样:</p><p><strong>Kinect —— 深度图 —— 降噪滤波 —— 转为scan —— 与雷达scan融合 —— 作为SLAM算法的输入 —— 建图</strong></p><p>这里有两种方案：kinect和laser的安装朝向相同或者相反(呈180°)，结果发现存在以下问题：</p><ol><li>和雷达相同，kinect对透明或高反射性的表面也难以检测</li><li>降噪滤波算法需要反复试验</li><li>转为scan一般使用的是depthimage_to_laserscan包，但这个包存在<a href="https://charon-cheung.github.io/2020/06/05/%E8%A7%86%E8%A7%89SLAM/depthimage_to_laserscan%20%E6%B7%B1%E5%BA%A6%E5%9B%BE%E8%BD%ACscan/">scan_height难以调整的问题</a></li><li>融合scan使用的是ira_laser_tools中的laser_multi_merger包，但是这个包是针对激光scan，不是针对kinect转出的scan，需要做一些修改。</li><li>对于gmapping算法，当两个传感器反向安装时，低处的障碍物开始出现地图里，但是过了一会又消失了，因为雷达scan在Kinect-scan之后检测到了墙，gmapping会把之前的kinect-scan当做错误而把相应的区域又按free space处理。同向安装时，kinect-scan扫描的障碍物会变得不太清晰，原因跟反向安装时还是一样的。</li></ol><p>另外朝向相同时，建图精度不如朝向相反的情况。原因还是里程计误差，朝向相反时，两个传感器融合造成的扫描角度大于朝向相同的时候，所以机器人行走比较少。如果用的是kinect1，因为是基于结构光，所以不适合室外使用，而且不能感知小障碍物，深度的分辨率又太低，建图精度不行，以及FOV不大</p><p>由于以上原因，这个方案的可行性大打折扣，尤其是3和5，除非自己修改现有的包和gmapping算法(降低地图cell被确定为<strong>占用</strong>的概率threshold)，但是这样要做的工作就更多了。</p><p>论文提出了一个折中方案：每个传感器各自建图，把这些地图做一个完整地图的单独一层。我估计就是单独构建导航时的costmap的一层，不建静态地图也行。不过因为其他原因，懒得再试了。</p><h2 id="depth-nav-tools"><a href="#depth-nav-tools" class="headerlink" title="depth_nav_tools"></a>depth_nav_tools</h2><p>ROS另有一套用于kinect的工具包：<a href="https://github.com/mdrwiega/depth_nav_tools" target="_blank" rel="noopener">depth_nav_tools</a>，不过懒得研究了</p><ul><li><p>laserscan_kinect: Converts a depth image coded with uint16 to laser scan 2D (sensor_msgs/LaserScan).</p></li><li><p>cliff_detector: 检测negative障碍物，比如悬崖或下楼</p></li><li><p>depth_sensor_pose: Detects ground plane in depth image and estimates height and tilt angle of depth sensor.</p></li><li><p>nav_layer_from_points: 创建代价地图的一层 based on received points coordinates in robot frame.</p></li><li><p>depth_nav_msgs: 用于其他packages的msg</p></li></ul><p><a href="https://github.com/marshallpowell97/laser_merge" target="_blank" rel="noopener">还有这个第三方融合laser和kinect生成的scan</a></p><h2 id="手持kinect建图"><a href="#手持kinect建图" class="headerlink" title="手持kinect建图"></a>手持kinect建图</h2><p>流程: kinect——深度图——scan——laser_scan_matcher——gmapping</p><p><img src="https://i.loli.net/2020/06/09/9aZfunEO24BTUCQ.png" alt="rqt节点关系图"></p><p>手持kinect没有里程计信息，可以用<code>laser_scan_matcher</code>做里程计估计器，它可以输出一个模拟的里程计信息，实际就是参数<code>fixed_frame</code>的值</p><p>建图时要保证kinect的水平，如果有一定程度的倾斜或翻转，建的地图就有误差。gmapping算法的时间与kinect的移动速度和环境面积有关，所以不要移动太快。</p><p>参考：<br><a href="http://wiki.ros.org/ira_laser_tools" target="_blank" rel="noopener">ira_laser_tools</a><br><a href="https://answers.ros.org/question/295899/use-ira_laser_tools-to-fuse-the-rplidar-a2-and-kinect-laser-scanbut-the-output-of-the-merger-is-only-kinects-data/" target="_blank" rel="noopener">合成二者的scan</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/27/激光SLAM/gmapping/(五) 源码分析3  laserCallback第2部分及addScan/">(五) 源码分析3 laserCallback第2部分及addScan, updateMap</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/gmapping/">gmapping</a></span><div class="content"><h2 id="laserCallback-第2部分"><a href="#laserCallback-第2部分" class="headerlink" title="laserCallback 第2部分"></a>laserCallback 第2部分</h2><p>接<code>initMapper</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">GMapping::OrientedPoint odom_pose;</span><br><span class="line"><span class="comment">// addScan这个函数要转到pf的核心代码了，将调用processScan</span></span><br><span class="line"><span class="keyword">if</span>(addScan(*scan, odom_pose))</span><br><span class="line">&#123;</span><br><span class="line">  ROS_DEBUG(<span class="string">"scan processed done !"</span>);</span><br><span class="line">  <span class="comment">// 从粒子集合中挑选最优的粒子， 以其地图坐标为基准， 计算从激光雷达到地图之间的坐标变换</span></span><br><span class="line">  GMapping::OrientedPoint mpose = gsp_-&gt;getParticles()[gsp_-&gt;getBestParticleIndex()].pose;</span><br><span class="line">  ROS_INFO(<span class="string">"new best pose: %.3f %.3f %.3f"</span>, mpose.x, mpose.y, mpose.theta);</span><br><span class="line">  tf::Transform laser_to_map = tf::Transform(tf::createQuaternionFromRPY(<span class="number">0</span>, <span class="number">0</span>, mpose.theta), tf::Vector3(mpose.x, mpose.y, <span class="number">0.0</span>)).inverse();</span><br><span class="line"></span><br><span class="line">  ROS_INFO(<span class="string">"odom pose: %.3f %.3f %.3f"</span>, odom_pose.x, odom_pose.y, odom_pose.theta);</span><br><span class="line">  tf::Transform odom_to_laser = tf::Transform(tf::createQuaternionFromRPY(<span class="number">0</span>, <span class="number">0</span>, odom_pose.theta), tf::Vector3(odom_pose.x, odom_pose.y, <span class="number">0.0</span>));</span><br><span class="line"></span><br><span class="line">  ROS_WARN(<span class="string">"correction: %.3f %.3f %.3f"</span>, mpose.x - odom_pose.x, mpose.y - odom_pose.y, mpose.theta - odom_pose.theta);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 另一处的lock在 SlamGMapping::publishTransform()， 这里是获得map_to_odom_，前者是发布</span></span><br><span class="line">  map_to_odom_mutex_.lock();</span><br><span class="line">  map_to_odom_ = (odom_to_laser * laser_to_map).inverse();</span><br><span class="line">  map_to_odom_mutex_.unlock();</span><br><span class="line">  <span class="comment">// 如果没有地图则直接更新。 如果有地图了，两次扫描时间差大于参数，才更新地图</span></span><br><span class="line">  <span class="keyword">if</span>(!got_map_ || (scan-&gt;header.stamp - last_map_update) &gt; map_update_interval_)</span><br><span class="line">  &#123;</span><br><span class="line">    updateMap(*scan);</span><br><span class="line">    last_map_update = scan-&gt;header.stamp;</span><br><span class="line">    ROS_DEBUG(<span class="string">"Updated the map"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  ROS_WARN(<span class="string">"cannot process scan"</span>);</span><br></pre></td></tr></table></figure><p>这里如果<code>addScan</code>返回false，就是未向地图添加scan，原因在<code>processScan</code>里，可能是机器人走过的线距离太短或者旋转过角度太少，未达到门槛；或者未达到指定的时间(<code>period_</code>，写死为5秒)，毕竟我们不希望机器人停着不动就更新地图，那太消耗资源了。</p><p><code>updateMap()</code>得到最优的粒子的地图数据，利用占据栅格地图算法，更新地图。</p><h3 id="addScan"><a href="#addScan" class="headerlink" title="addScan"></a>addScan</h3><p>把新的测量值和里程计坐标报告给建图引擎gsp_，让其更新粒子集。 根据激光雷达的安装方式，对角度进行修改。</p><p>然后将ROS的激光雷达采集的信息转换成gmapping能看懂的格式。设置和激光数据时间戳匹配的机器人的位姿。调用<code>processscan</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入一个激光雷达的数据, 里面会调用 processScan()函数,这个函数被laserCallback()函数调用</span></span><br><span class="line"><span class="comment">// gmap_pose为刚定义的里程计的累积位姿</span></span><br><span class="line"><span class="keyword">bool</span> SlamGMapping::addScan(<span class="keyword">const</span> sensor_msgs::LaserScan&amp;  scan, GMapping::OrientedPoint&amp;  gmap_pose)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//得到与激光的时间戳相对应的机器人的里程计的位姿</span></span><br><span class="line">    <span class="keyword">if</span>(!getOdomPose(gmap_pose, scan.header.stamp))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测是否所有帧的数据都是相等的，如果不相等就return</span></span><br><span class="line">    <span class="keyword">if</span>(scan.ranges.size() != gsp_laser_beam_count_)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span>* ranges_double = <span class="keyword">new</span> <span class="keyword">double</span>[scan.ranges.size()];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果激光是反着装的，这激光的顺序需要反过来，这段代码省略</span></span><br><span class="line">    <span class="keyword">if</span> (do_reverse_range_)</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; scan.ranges.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// mapper那里无法过滤掉</span></span><br><span class="line">            <span class="comment">// 排除掉所有激光距离小于range_min的值，它们很可能是噪声数据</span></span><br><span class="line">            <span class="keyword">if</span>(scan.ranges[i] &lt; scan.range_min)</span><br><span class="line">                ranges_double[i] = (<span class="keyword">double</span>)scan.range_max;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ranges_double[i] = (<span class="keyword">double</span>)scan.ranges[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把ROS的激光雷达数据信息 转换为 GMapping算法看得懂的形式</span></span><br><span class="line">    <span class="comment">// 激光传感器gsp_laser_ 在initMapper里定义，ranges数据赋值给m_dists，size给m_beams</span></span><br><span class="line">    GMapping::<span class="function">RangeReading <span class="title">reading</span><span class="params">(scan.ranges.size(),</span></span></span><br><span class="line"><span class="function"><span class="params">                                   ranges_double,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   gsp_laser_,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   scan.header.stamp.toSec())</span></span>;</span><br><span class="line">    <span class="comment">// 上面的初始化是进行深拷贝，因此申请的内存可以直接释放。</span></span><br><span class="line">    <span class="keyword">delete</span>[] ranges_double;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置和激光数据的时间戳匹配的机器人的位姿   不是雷达位姿吗???</span></span><br><span class="line">    reading.setPose(gmap_pose);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用gmapping算法进行处理</span></span><br><span class="line">    <span class="keyword">return</span> gsp_-&gt;processScan(reading);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gmap_pose</code>应当是不同时间戳时，雷达扫描扇形的中心(包含角度)在odom坐标系中的坐标。</p><p>问题：</p><ul><li><code>reading.setPose(gmap_pose);</code> 解释存疑</li></ul><p>最后就是核心算法所在的<code>processScan</code></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/27/ROS/ROS机器人/ROS使用GPS/">ROS使用GPS</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS机器人/">ROS机器人</a></span><div class="content"><p>可以使用创客智造的<code>ublox</code>的GPS，淘宝有卖<br><a href="http://wiki.ros.org/ublox" target="_blank" rel="noopener"></a><br><a href="https://www.ncnynl.com/archives/201905/3053.html" target="_blank" rel="noopener">创客智造的教程</a></p><p>GPS无法完成室内环境的精确定位, 但是发现一种被称为”室内GPS”的产品<code>Marvelmind beacon</code>,其定位精度达到2cm,配合<code>robot_localization</code>实现多传感器融合,可显著提高定位精度, 参考:<a href="https://github.com/methylDragon/ros-sensor-fusion-tutorial" target="_blank" rel="noopener">sensor fusion with robot_localization</a></p></div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/40/">40</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image:url(https://i.loli.net/2020/07/13/QgyrefaLDxhBWSZ.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>