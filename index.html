<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG={root:"/",algolia:{appId:"RI90VLL69D",apiKey:"20c535e9a1424a7913210eb747d6e67b",indexName:"HexoBlog",hits:{per_page:10},languages:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}.",hits_stats:"${hits} results found in ${time} ms"}},localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">383</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">46</span></a></div></div></div><nav id="nav" style="background-image:url(https://live.staticflickr.com/65535/48055510011_577ff62eaf_b.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div><div id="site-social-icons"><a class="social-icon" href="https://github.com/charon-cheung"><i class="fa-github fa"></i></a><a class="social-icon search"><i class="fa fa-search"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/30/23794/">23794</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-30</time><div class="content"></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/29/视觉SLAM/标定D435i的IMU/">标定D435i的IMU</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/视觉SLAM/">视觉SLAM</a></span><div class="content"><p>用imu_utils标定IMU</p><p>A ROS package tool to analyze the IMU performance. C++ version of Allan Variance Tool. The figures are drawn by Matlab, in scripts.</p><p>Actually, just analyze the Allan Variance for the IMU data. Collect the data while the IMU is Stationary, with a two hours duration.</p><ol><li>安装依赖项，不装之后的编译会报错： <code>sudo apt-get -y install libdw-dev</code>，结果可能提示<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The following packages have unmet dependencies:</span><br><span class="line"> libdw-dev : Depends: libelf-dev but it is not going to be installed</span><br><span class="line">             Depends: libdw1 (= 0.165-3ubuntu1) but it is not going to be installed</span><br><span class="line">E: Unable to correct problems, you have held broken packages.</span><br></pre></td></tr></table></figure></li></ol><p>这是因为一个依赖项已经安装了不同版本：<code>Depends: libelf1 (= 0.165-3ubuntu1) but 0.165-3ubuntu1.2 is to be installed</code></p><ol start="2"><li>全局安装ceres库，因为<code>code_imu</code>依赖ceres。code_utils标定IMU的噪音密度和随机游走系数。　不要同时把imu_utils和code_utils一起放到src下进行编译。因为imu_utils 依赖 code_utils，原作者的CMakeLists写的不好，所以先编译code_utils再编译后者。</li><li>在code_utils下面找到sumpixel_test.cpp，修改<code>#include &quot;backward.hpp&quot;</code>为<code>#include&quot;code_utils/backward.hpp&quot;</code>，再编译。</li><li>让IMU静止不动两个小时，录制IMU的bag.</li><li>标定</li></ol><arg name="unite_imu_method" default><arg name="unite_imu_method" default><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosbag play -r 200　imu_utils/imu.bag</span><br><span class="line">roslaunch imu_utils a3.launch</span><br></pre></td></tr></table></figure><p>注意launch文件需要自己模仿现有的写一个:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"imu_utils"</span> <span class="attr">type</span>=<span class="string">"imu_an"</span> <span class="attr">name</span>=<span class="string">"imu_an"</span> <span class="attr">output</span>=<span class="string">"screen"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"imu_topic"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">value</span>= <span class="string">"/djiros/imu"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"imu_name"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">value</span>= <span class="string">"A3"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"data_save_path"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">value</span>= <span class="string">"$(find imu_utils)/data/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"max_time_min"</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>= <span class="string">"120"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"max_cluster"</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>= <span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>max_time_min代表的是标定时间，这里的单位是分钟，意思是填10就是代表10分钟，至少录rosbag十分钟。</p><p>只用到其中四个参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Gyr:</span><br><span class="line">   avg-axis:</span><br><span class="line">      gyr_n: 3.1820671461855504e-03</span><br><span class="line">      gyr_w: 3.0693398103399251e-05</span><br><span class="line">Acc:</span><br><span class="line">   avg-axis:</span><br><span class="line">      acc_n: 2.6449533258549235e-02</span><br><span class="line">      acc_w: 7.2111910796954259e-04</span><br></pre></td></tr></table></figure><p>分别是陀螺仪和加速度计 随机游走和 高斯白噪声的平均值，是IMU噪声模型中的两种噪声</p><p><code>realsense_camera/IMUInfo</code> with the header.frame_id set to either <code>imu_accel</code> or <code>imu_gyro</code> to distinguish between <code>accel</code> and <code>gyro</code> info.<br>成员如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string frame_id</span><br><span class="line">float64[12] data</span><br><span class="line">float64[3] noise_variances</span><br><span class="line">float64[3] bias_variances</span><br></pre></td></tr></table></figure><p>参考: <a href="https://github.com/gaowenliang/imu_utils" target="_blank" rel="noopener">官方Github</a><br><a href="https://www.geek-share.com/detail/2798533390.html" target="_blank" rel="noopener">VIO标定IMU随机误差——Allan方差法</a></p></arg></arg></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/29/视觉SLAM/标定D435i的外参数/">标定D435i的外参数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/视觉SLAM/">视觉SLAM</a></span><div class="content"><p>realsense d435i包含两个红外相机、红外发射器、RGB相机和IMU四个模块，显然四个传感器的空间位置是不同的，我们在处理图像和IMU数据时需要将这些数据都放在统一的坐标系上去。比如我们用d435i运行vins，处理的图像和IMU数据都需要放在同一个坐标系下，因此需要标定IMU相对RGB相机的空间位置（包括旋转和位移）。</p><p>另外，相机固有参数比如焦距、畸变参数等以及IMU的零偏和scale系数等都需要提前知道。前者称为外参，后者称为内参，在运行程序前我们需要标定它们，不论程序是否有自标定功能，毕竟好的初始标定值对于自标定来说也是有利的。</p><p>标定顺序：<strong>IMU标定 –&gt; 相机标定 –&gt; IMU+相机联合标定</strong>. 这么设定顺序是因为最后一步的IMU和相机的联合标定需要 IMU和相机的内参</p><p>Kalibr可以解决以下的标定问题:</p><ul><li>多相机标定: 一个相机系统的内外参标定，这几个相机没有全局性重叠的视角</li><li>视觉惯性标定(camera-IMU): IMU关于相机系统的时空间标定</li><li>Rolling Shutter Camera calibration: full intrinsic calibration (projection, distortion and shutter parameters) of rolling shutter cameras</li></ul><p>我们可以下载Kalibr源码编译生成可执行文件，也可以下载其CDE精简版包。这中间有个坑就是CDE精简包是没有办法标定彩色图片的，而D435输出的是彩色图。所以还是按编译源码的方式</p><h2 id="安装Kalibr"><a href="#安装Kalibr" class="headerlink" title="安装Kalibr"></a>安装Kalibr</h2><ol><li><p>安装依赖项</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-pyx python-setuptools python-rosinstall ipython libeigen3-dev libboost-all-dev doxygen ros-kinetic-vision-opencv ros-kinetic-image-transport-plugins ros-kinetic-cmake-modules python-software-properties software-properties-common libpoco-dev python-matplotlib python-scipy python-git python-pip ipython libtbb-dev libblas-dev liblapack-dev python-catkin-tools libv4l-dev</span><br></pre></td></tr></table></figure></li><li><p>源码放入工作空间进行编译，会花很长时间，所以编译命令要这样:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 视情况取j8</span></span><br><span class="line">catkin_make -DCMAKE_BUILD_TYPE=Release -j4</span><br></pre></td></tr></table></figure></li></ol><p>编译kalibr可能会出现<font color="red"> fatal error: numpy/arrayobject.h: No such file or directory </font>，解决方法： <code>sudo apt-get install --reinstall python-numpy</code></p><p>可能出现catkin_make时，下载suitesparse过久甚至失败的问题。解决方法： 修改<code>～/catkin_ws/src/kalibr/suitesparse</code>中的CMakeLists.txt为<a href="https://raw.githubusercontent.com/charon-cheung/xiaoqiang_robot/master/Calibration/Kalibr_CMakeLists.md" target="_blank" rel="noopener">新CMakeLists.txt</a>, 然后重新catkin_make</p><p>a. 标定板pattern尽量选择apriltag，尽量不要用纸质的；b. 选择合适的相机模型；c. 标定手法看看TUM的</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/28/视觉SLAM/realsense D435i安装配置/">realsense D435i安装配置</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/视觉SLAM/">视觉SLAM</a></span><div class="content"><p>realsense D435i终于到手了，打开发现其实很小巧，先做一些配置看看。默认要使用USB3，如果RealSense使用USB2, Output Resolution自动降到<code>480*270 30fbs</code>，而非产品所宣称的1280 x 720 active stereo depth resolution和90fps，且只有Stereo Moudle在工作，无Image Sensor的RGB Moudle菜单项，无法进行3D建模。</p><p>D435i采用了即用型USB供电形式，不仅提供深度传感器模组，还配备了一个IMU单元（惯性测量单元，采用的博世BMI055）。凭借内置的IMU单元，结合视觉数据可实现6DoF追踪功能。其中，IMU将各种线性加速度计和陀螺仪数据结合，可检测X，Y，Z三轴的旋转和平移，以及俯仰、横摇等动作。D435i的2000万像素RGB摄像头和3D传感器可以30帧/秒的速度提供分辨率高达1280 × 720，或者以90帧/秒的速度提供848 × 480的较低分辨率。该摄像头具有全局快门，可以处理快速移动物体，室内室外皆可操作。深度距离在<code>0.1 m~10 m</code>之间，视场角度为85 × 58度</p><p>可以获得RGB图、左右红外摄像图、深度图、IMU数据，并且将深度图数据和RGB图进行对齐。左右红外相机进行测量深度，中间红外点阵投射器相当于补光灯，不打开也能测深度，只是效果不好；最右边的rgb相机用于采集彩色图片，最终可以将彩色视频流与深度流进行对齐.</p><h2 id="librealsense"><a href="#librealsense" class="headerlink" title="librealsense"></a>librealsense</h2><p>先装realsense的驱动，步骤参考网上的，其实不必完全相同，我的步骤如下：</p><ol><li><p>下载<a href="https://github.com/IntelRealSense/librealsense" target="_blank" rel="noopener">驱动</a>，然后解压到根目录</p></li><li><p>执行如下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/librealsense</span><br><span class="line">sudo apt-get install libssl-dev libusb-1.0-0-dev pkg-config libgtk-3-dev libglfw3-dev</span><br><span class="line"><span class="comment"># 许可脚本</span></span><br><span class="line">sudo cp config/99-realsense-libusb.rules /etc/udev/rules.d/</span><br><span class="line">sudo udevadm control --reload-rules &amp;&amp; udevadm trigger</span><br></pre></td></tr></table></figure></li><li><p>开始编译</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/librealsense</span><br><span class="line">mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake ../ -DBUILD_EXAMPLES=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">sudo make uninstall &amp;&amp; make clean &amp;&amp; make  -j8 &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></li></ol><p>j8是根据我电脑的情况选择的，如果不指定核数，编译会很慢。</p><p>运行<code>realsense-viewer</code>验证，看到如下画面<br><img src="https://i.loli.net/2020/06/28/TIEr7MGmfpWXisD.png" alt="RGB Depth Infrared"><br>配置可以修改为常见的黑白深度图以及分辨率等等<br><img src="https://i.loli.net/2020/06/28/3uPdGyh7TlFnS5w.png" alt="配置栏"></p><h2 id="ROS驱动"><a href="#ROS驱动" class="headerlink" title="ROS驱动"></a>ROS驱动</h2><p>从<a href="https://github.com/IntelRealSense/realsense-ros" target="_blank" rel="noopener">这里</a>下载，然后放到某工作空间，编译即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">catkin_make -DCATKIN_ENABLE_TESTING=False -DCMAKE_BUILD_TYPE=Release</span><br><span class="line">catkin_make install</span><br></pre></td></tr></table></figure><p>现在运行<code>roslaunch realsense2_camera rs_camera.launch</code>，打开rqt就能看到realsense的三种图像<br>实际运行了<code>/camera/realsense2_camera</code>和<code>camera/realsense2_camera_manager</code>两个节点，涉及的话题有很多，以后慢慢分析。</p><p>在rqt中打开深度图时出现了报错，又是图像编码问题<br><img src="https://i.loli.net/2020/06/28/PV9LDck5atvEzMZ.png" alt="launch文件中报错.png"><br><img src="https://i.loli.net/2020/06/28/PYMuOQ7R6zDgvel.png" alt="rqt终端报错.png"><br>在rqt里查看<code>/camera/depth/image_rect_raw/theora</code>，同样没有深度图，但rqt不报警</p><p>在rqt查看RGB和红外的图像，只要选择theora，rqt终端都会报警:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ WARN][/rqt_gui_cpp_node_25764] [TheoraSubscriber::internalCallback] line_170  [theora] Packet was not a Theora header</span><br></pre></td></tr></table></figure><br><p>使用对齐的深度话题信息发布RGBD点云</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch realsense2_camera rs_rgbd.launch</span><br></pre></td></tr></table></figure><p>这一步还没有成功,在rviz里没看到结果</p><p>参考：<a href="https://blog.csdn.net/sinat_23853639/article/details/88044019" target="_blank" rel="noopener">realsense D435 驱动安装并嵌入ROS中使用</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/25/激光SLAM/gmapping/(九) 总结/">(九) 总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/gmapping/">gmapping</a></span><div class="content"><p>gmapping源码中不完善的部分：</p><ol><li>drawFromMotion函数是一个十分粗糙的运动模型，只是简单的矢量加减运算。相比于《概率机器人》中提到的速度模型和里程计模型，有很多方面都没有考虑，精度上可能有折扣。</li><li><code>m_angularOdometryReliability</code>和<code>m_linearOdometryReliability</code>用于控制激光评分的增益<code>odo_gain</code>, 实际都是0，所以没有用到，而且无法用参数赋值, 要使用就得修改源码.</li><li>紧接上面的代码，<code>localScore=odo_gain*score(map, localPose, readings);</code>，localScore在之后的<code>likelihoodAndScore</code>函数里实际赋值为0，根本没有用。所以这里有好几行可以删除</li><li>在论文中，粒子的权重不是用最优位姿的似然值来表示的，而是用所有的似然值的和来表示的</li><li>重采样的粒子索引选取用的是轮盘赌算法，有些论文提出了一些更好的算法</li></ol></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/19/激光SLAM/gmapping/OpenMP加速gmapping/">OpenMP加速gmapping</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/gmapping/">gmapping</a></span><div class="content"><p>在CMakeLists里做如下配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FIND_PACKAGE( OpenMP REQUIRED)</span><br><span class="line"><span class="keyword">if</span>(OPENMP_FOUND)</span><br><span class="line">    message(<span class="string">"OPENMP FOUND"</span>)</span><br><span class="line">    <span class="built_in">set</span>(CMAKE_C_FLAGS <span class="string">"<span class="variable">$&#123;CMAKE_C_FLAGS&#125;</span> <span class="variable">$&#123;OpenMP_C_FLAGS&#125;</span>"</span>)</span><br><span class="line">    <span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">"<span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span> <span class="variable">$&#123;OpenMP_CXX_FLAGS&#125;</span>"</span>)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure><p>注意： OpenMP并不适合需要复杂的线程间同步和互斥的场合这种情况下花的时间可能更长</p><p>gmapping使用OpenMP加速的语句: <code>#pragma omp parallel for</code></p><ol><li><p>for循环的drawFromMotion之前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma omp parallel for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_particles.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">    m_particles[i].pose =  m_motionModel.drawFromMotion(m_particles[i].pose, relPose,m_odoPose);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>invalidateActiveArea之前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma omp parallel for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_particles.size(); i++) &#123;</span><br><span class="line">    m_matcher.invalidateActiveArea();</span><br></pre></td></tr></table></figure></li><li><p>scanMatch函数开头，实际就是对整个scanMatch并行化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scanMatch</span><span class="params">(<span class="keyword">double</span> * plainReading)</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_particles.size(); i++) &#123;</span><br></pre></td></tr></table></figure></li><li><p>updateMap函数中</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x &lt; smap.getMapSizeX(); x++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>; y &lt; smap.getMapSizeY(); y++)</span><br><span class="line">    &#123;</span><br></pre></td></tr></table></figure><ol start="5"><li>重采样resample函数</li></ol><p>对于保留下来的粒子进行更新，在并行化操作里面<code>m_particles.push_back()</code>会报错，因此需要把push_back()提出来，在外面的的for循环进行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;tmp_size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对保留下来的粒子数据进行更新</span></span><br><span class="line">        <span class="comment">//每个粒子的权重都设置为相同的值</span></span><br><span class="line">        temp[i].setWeight(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//为每个粒子更新running_scans</span></span><br><span class="line">        <span class="comment">//增加了一帧激光数据 因此需要更新地图</span></span><br><span class="line">        m_matcher.registerScan(temp[i].<span class="built_in">map</span>,temp[i].pose,plainReading);</span><br><span class="line">        <span class="comment">//m_matcher.registerScan(temp[i].lowResolutionMap,temp[i].pose,plainReading);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>为每个粒子更新地图时，同样可以并行化</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/17/激光SLAM/gmapping/(八) 源码分析6  scan match/">(八) 源码分析6 scan match</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/gmapping/">gmapping</a></span><div class="content"><p>先接上篇，不是第一帧激光数据的情况，上来是<code>scanMatch</code>函数，也就是<code>GridSlamProcessor::scanMatch</code>(在文件gridslamprocessor.hxx)。</p><h2 id="主要部分"><a href="#主要部分" class="headerlink" title="主要部分"></a>主要部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> GridSlamProcessor::scanMatch(<span class="keyword">const</span> <span class="keyword">double</span>* plainReading)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// sample a new pose from each scan in the reference</span></span><br><span class="line">    <span class="comment">/* 每个粒子都要进行 scan-match */</span></span><br><span class="line">    <span class="keyword">double</span> sumScore=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> particle_number = m_particles.size();</span><br><span class="line">    <span class="comment">//可以用openMP的方式来进行并行化，因此这里不能用迭代器，只能用下标的方式</span></span><br><span class="line">    <span class="comment">//并行化之后，里面的循环会均匀分到各个不同的核里面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; particle_number; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        OrientedPoint corrected;</span><br><span class="line">        <span class="keyword">double</span> score, l, s;</span><br><span class="line">        <span class="comment">/*进行scan-match 计算粒子的最优位姿，这是gmapping本来的做法*/</span></span><br><span class="line">        score = m_matcher.optimize(corrected, m_particles[i].<span class="built_in">map</span>, m_particles[i].pose, plainReading);</span><br><span class="line">        <span class="comment">/* 匹配成功则更新最优位姿 */</span></span><br><span class="line">	    <span class="keyword">if</span> (score&gt;m_minimumScore)</span><br><span class="line">	    &#123;</span><br><span class="line">	      m_particles[i].pose = corrected;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">/*  扫描匹配不上,则使用里程计的数据,使用里程计数据不进行更新.</span></span><br><span class="line"><span class="comment">	          因为在进行扫描匹配之前 里程计已经更新过了*/</span></span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">	        <span class="keyword">if</span> (m_infoStream)</span><br><span class="line">	        &#123;</span><br><span class="line">	            m_infoStream &lt;&lt; <span class="string">"Scan Matching Failed, using odometry. Likelihood="</span> &lt;&lt; l &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	            m_infoStream &lt;&lt; <span class="string">"lp:"</span> &lt;&lt; m_lastPartPose.x &lt;&lt; <span class="string">" "</span>  &lt;&lt; m_lastPartPose.y &lt;&lt; <span class="string">" "</span>&lt;&lt; m_lastPartPose.theta &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	            m_infoStream &lt;&lt; <span class="string">"op:"</span> &lt;&lt; m_odoPose.x &lt;&lt; <span class="string">" "</span> &lt;&lt; m_odoPose.y &lt;&lt; <span class="string">" "</span>&lt;&lt; m_odoPose.theta;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">// 粒子的最优位姿计算了之后，重新计算粒子的权重,相当于粒子滤波器中的观测步骤</span></span><br><span class="line">	    <span class="comment">/* 计算p(z|x,m)，粒子的权重由粒子的似然来表示, 计算粒子的得分和权重(似然)	</span></span><br><span class="line"><span class="comment">	        注意粒子的权重经过ScanMatch之后已经更新了</span></span><br><span class="line"><span class="comment">	     * 在论文中   粒子的权重不是用最优位姿的似然值来表示的</span></span><br><span class="line"><span class="comment">	     * 是用所有的似然值的和来表示的, s是得分  l是似然,也就是权重 */</span></span><br><span class="line">	    m_matcher.likelihoodAndScore(s, l, m_particles[i].<span class="built_in">map</span>, m_particles[i].pose, plainReading);</span><br><span class="line">	    sumScore+=score;</span><br><span class="line">	    m_particles[i].weight+= l;</span><br><span class="line">	    m_particles[i].weightSum+= l;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">//set up the selective copy of the active area</span></span><br><span class="line">	    <span class="comment">//by detaching the areas that will be updated</span></span><br><span class="line">	    <span class="comment">/*计算出来最优的位姿之后，进行地图的扩充  这里不会进行内存分配</span></span><br><span class="line"><span class="comment">	     *不进行内存分配的原因是这些粒子进行重采样之后有可能会消失掉，因此在后面进行重采样的时候统一进行内存分配。</span></span><br><span class="line"><span class="comment">	     *理论上来说，这里的操作是没有必要的，因为后面的重采样的时候还会进行一遍</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    m_matcher.invalidateActiveArea();</span><br><span class="line">	    m_matcher.computeActiveArea(m_particles[i].<span class="built_in">map</span>, m_particles[i].pose, plainReading);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_infoStream)</span><br><span class="line">        m_infoStream &lt;&lt; <span class="string">"Average Scan Matching Score of all particles="</span> &lt;&lt; sumScore/m_particles.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始的都没意思，直接看<code>ScanMatcher::optimize</code>，在<code>scanmatcher.cpp</code>里，开头又是一个重要函数<code>score</code>，在<code>scanmatcher.h</code>里。它根据地图、激光数据、位姿迭代求解一个最优的新的位姿出来。</p><p>代码比较复杂，直接看整个<code>scan</code>函数(包括了optimize和score)的评分算法的理论：</p><p>对于栅格地图的环境地图模型，一般采用基于似然场模型（likelihood field range finder mode）的扫描匹配算法来进行激光雷达数据与地图的匹配。 该算法通过评估当前时刻位姿的激光雷达数据中每一个激光点与该时刻栅格地图的匹配程度，并将评估得到的每个激光点得分进行累加，得到当前时刻激光雷达数据与地图匹配的总分数，得分越高说明该时刻激光雷达信息与地图匹配程度越高，即机器人位姿越精确。由于该算法能够根据机器人当前时刻状态、 观测值和地图信息直接得到该时刻位姿的匹配程度，因而该算法常与基于粒子滤波的定位算法结合使用，用于选取各粒子中得分最高的位姿，并计算得分， 从而完成机器人位姿的确定，其原理如图：<br><img src="https://i.loli.net/2020/06/17/zGU6bgEwCnlRpr9.png" alt="基于似然场模型的扫描匹配示意图.png"></p><p>黑色的格子代表前一时刻栅格地图中障碍物的位置， 圆形的点表示以里程计运动模型作为提议分布得到的机器人位姿估计为基础，将当前时刻激光雷达数据转换到栅格地图坐标系中的激光点的分布。把激光雷达的坐标转换到世界坐标系: 先旋转到机器人坐标系，然后再转换到世界坐标系。</p><p>该位姿下观测信息与地图匹配得分的具体算法步骤如下：对于当前激光雷达数据中任意一个激光点，设其端点在世界坐标系中坐标为 <code>lp</code> ，则其对应栅格地图中坐标为 <code>phit</code> ，对 <code>phit</code>周围八个栅格进行障碍物判定，并计算这些障碍物的平均坐标 <code>pavr</code>， 求出 <code>pavr</code>与 phit 的距离 dist 。 该激光点的评分可由下式表示<br><img src="https://i.loli.net/2020/06/17/7TFuOJbjxSr9BNA.png" alt="评分公式.png"></p><p>如果设置的<code>minimumScore</code>参数过大，一些粒子的匹配会失败，因为要求太高了，gmapping会出现下列信息：<br><img src="https://i.loli.net/2020/06/18/lDeLROQoaziNZrb.png" alt="scan match失败.png"><br>gmapping变成使用里程计进行位姿估计，这其实是不好的，因为从论文可知<strong>激光精度比里程计精确得多</strong>，但是注意粒子的权重计算还是调用<code>likelihoodAndScore</code>函数。</p><p><code>ε</code>为基于扫描匹配概率的激光方差，对该时刻所有激光点进行上式的计算，并将评分进行求和，分数越高说明该位姿的可信度越高。 对当前时刻所有粒子位姿进行扫描匹配运算， 并根据得分实现粒子的权重更新，最后求出粒子群的平均评分<code>sumScore/m_particles.size()</code></p><h3 id="试验小强的scan-match评分"><a href="#试验小强的scan-match评分" class="headerlink" title="试验小强的scan match评分"></a>试验小强的scan match评分</h3><p>直接修改<code>gridslamprocessor.hxx</code>的scanMatch函数。 小强的gmapping编译有问题，执行<code>catkin_make --pkg gmapping</code>之后，需要 <code>cp /home/xiaoqiang/Documents/ros/devel/lib/gmapping/slam_gmapping /home/xiaoqiang/Documents/ros/src/gmapping/launch</code>，否则roslaunch找不到节点文件</p><p>根据测试，激光评分多数在<code>140~160</code>，有时也会超过160.</p><h2 id="for循环剩下的部分"><a href="#for循环剩下的部分" class="headerlink" title="for循环剩下的部分"></a>for循环剩下的部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*矫正成功则更新位姿*/</span></span><br><span class="line"><span class="keyword">if</span> (score&gt;m_minimumScore)</span><br><span class="line">&#123;</span><br><span class="line">    m_particles[i].pose = corrected;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扫描匹配不上,则使用里程计的数据,使用里程计数据不进行更新,因为扫描匹配之前,里程计已经更新过了</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//输出信息 这个在并行模式下可以会出现错位</span></span><br><span class="line">    <span class="keyword">if</span> (m_infoStream)</span><br><span class="line">    &#123;</span><br><span class="line">        m_infoStream &lt;&lt; <span class="string">"Scan Matching Failed, using odometry. Likelihood="</span> &lt;&lt; l &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        m_infoStream &lt;&lt; <span class="string">"lp:"</span> &lt;&lt; m_lastPartPose.x &lt;&lt; <span class="string">" "</span>  &lt;&lt; m_lastPartPose.y &lt;&lt; <span class="string">" "</span>&lt;&lt; m_lastPartPose.theta &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        m_infoStream &lt;&lt; <span class="string">"op:"</span> &lt;&lt; m_odoPose.x &lt;&lt; <span class="string">" "</span> &lt;&lt; m_odoPose.y &lt;&lt; <span class="string">" "</span>&lt;&lt; m_odoPose.theta &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 粒子的最优位姿计算了之后，重新计算粒子的权重(相当于粒子滤波器中的观测步骤，</span></span><br><span class="line"><span class="comment">   计算p(z|x,m))，粒子的权重由粒子的似然来表示。</span></span><br><span class="line"><span class="comment">* 计算粒子的得分和权重(似然)   注意粒子的权重经过ScanMatch之后已经更新了</span></span><br><span class="line"><span class="comment">* 在论文中,例子的权重不是用最有位姿的似然值来表示的。</span></span><br><span class="line"><span class="comment">* 是用所有的似然值的和来表示的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">m_matcher.likelihoodAndScore(s, l, m_particles[i].<span class="built_in">map</span>, m_particles[i].pose, plainReading);</span><br><span class="line"></span><br><span class="line">sumScore+=score;</span><br><span class="line">m_particles[i].weight+=l;</span><br><span class="line">m_particles[i].weightSum+=l;</span><br><span class="line"><span class="comment">//set up the selective copy of the active area</span></span><br><span class="line"><span class="comment">//by detaching the areas that will be updated</span></span><br><span class="line"><span class="comment">/*计算出来最优的位姿之后，进行地图的扩充  这里不会进行内存分配</span></span><br><span class="line"><span class="comment">*不进行内存分配的原因是这些粒子进行重采样之后有可能会消失掉，因此在后面进行冲采样的时候统一进行内存分配。</span></span><br><span class="line"><span class="comment">*理论上来说，这里的操作是没有必要的，因为后面的重采样的时候还会进行一遍</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">m_matcher.invalidateActiveArea();</span><br><span class="line">m_matcher.computeActiveArea(m_particles[i].<span class="built_in">map</span>, m_particles[i].pose, plainReading);</span><br></pre></td></tr></table></figure><h2 id="重采样"><a href="#重采样" class="headerlink" title="重采样"></a>重采样</h2><p><code>resample</code>函数：该函数在gridslamprocessor.hxx。首先是备份老的粒子的轨迹，即保留叶子的节点。然后是需要重采样还是不需要重采样，如果不需要重采样，则权值不变。只为轨迹创建一个新的节点，每个粒子更新地图。当有效值小于阈值的时候需要重采样，通过resampleIndexes提取到需要删除的粒子。删除粒子后，保留当前的粒子并在保存的粒子的节点里新增一个节点。删除要删除粒子的节点，保留的粒子进行数据更新，将每个粒子的设置同一个权重。最后更新一下地图。</p><p>​<code>resampleIndexes</code>：该函数在particlefilter.h中，使用轮盘赌算法，决定哪些粒子会保留，保留的粒子会返回下标，里面的下标可能会重复，因为有些粒子会重复采样,而另外的一些粒子会消失掉。</p><p>首先计算总的权重，计算平均权重值（interval），根据权值进行采样,target是0-1分布随机选取的一数值，当总权重大于目标权重的，记录该粒子的索引，target在加上一个interval。如果某个粒子的权重比较大的话，就被采样多次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">resampleIndexes</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Particle&gt;&amp; particles, <span class="keyword">int</span> nparticles)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Numeric cweight=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">/*计算总的权重*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Particle&gt;::const_iterator it=particles.begin(); it!=particles.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		cweight+=(Numeric)*it;</span><br><span class="line">		n++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nparticles&gt;<span class="number">0</span>)</span><br><span class="line">		n=nparticles;</span><br><span class="line">	<span class="comment">//compute the interval</span></span><br><span class="line">	Numeric interval=cweight/n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// drand48 返回服从均匀分布的·[0.0, 1.0) 之间的double随机数</span></span><br><span class="line">	Numeric target=interval*::drand48();</span><br><span class="line">    <span class="comment">// 如果某个粒子的区间为4*interval。那么它至少被采样3次。</span></span><br><span class="line">	cweight=<span class="number">0</span>;  n=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; indexes(n);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Particle&gt;::const_iterator it=particles.begin(); it!=particles.end(); ++it, ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cweight+=(Numeric)* it;</span><br><span class="line">		<span class="keyword">while</span>(cweight&gt;target)</span><br><span class="line">		&#123;</span><br><span class="line">			indexes[n++]=i;</span><br><span class="line">			target+=interval;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> indexes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/15/激光SLAM/gmapping/(七) 源码分析5  updateMap函数/">(七) 源码分析5 updateMap函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/gmapping/">gmapping</a></span><div class="content"><h2 id="第1部分"><a href="#第1部分" class="headerlink" title="第1部分"></a>第1部分</h2><p>这里的更新地图，只是为了可视化。因为真正的地图存储在粒子里面，这里会拿一个权值最大的粒子的地图<strong>发布</strong>出来.</p><p>得到权值最大的粒子，然后遍历这个粒子的整个轨迹，根据轨迹上记录的信息来进行建图，然后把得到的地图发布出去。</p><p>每次addScan()成功了，就会调用这个函数来生成地图，并发布出去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ROS_DEBUG(<span class="string">"Update map"</span>);</span><br><span class="line"><span class="comment">// 更新地图的时候，加了一把锁</span></span><br><span class="line">boost::mutex::<span class="function">scoped_lock <span class="title">map_lock</span> <span class="params">(map_mutex_)</span></span>;</span><br><span class="line"><span class="comment">// 构造函数的解释在下一篇</span></span><br><span class="line">GMapping::ScanMatcher  matcher;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置scanmatcher的各个参数*/</span></span><br><span class="line">matcher.setLaserParameters(scan.ranges.size(), &amp;(laser_angles_[<span class="number">0</span>]),</span><br><span class="line">        gsp_laser_-&gt;getPose() );</span><br><span class="line">matcher.setlaserMaxRange(maxRange_);</span><br><span class="line">matcher.setusableRange(maxUrange_);</span><br><span class="line">matcher.setgenerateMap(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到累计权重(weightSum)最大的粒子，不是当前的最大权重的粒子</span></span><br><span class="line"><span class="comment">// 累计权重即该粒子在各个时刻的权重之和(轨迹上的各个节点的权重之和)</span></span><br><span class="line">GMapping::GridSlamProcessor::Particle best =</span><br><span class="line">        gsp_-&gt;getParticles()[gsp_-&gt;getBestParticleIndex()];</span><br><span class="line"></span><br><span class="line">std_msgs::Float64 entropy;</span><br><span class="line"><span class="comment">// computePoseEntropy 遍历粒子集合计算熵</span></span><br><span class="line">entropy.data = computePoseEntropy();</span><br><span class="line"><span class="comment">//发布位姿的熵</span></span><br><span class="line"><span class="keyword">if</span>(entropy.data &gt; <span class="number">0.0</span>)</span><br><span class="line">    entropy_publisher_.publish(entropy);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有地图，则初始化一个地图</span></span><br><span class="line"><span class="keyword">if</span>(!got_map_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// nav_msgs::GetMap::Response   map_</span></span><br><span class="line">    map_.<span class="built_in">map</span>.info.resolution = delta_;</span><br><span class="line">    map_.<span class="built_in">map</span>.info.origin.position.x = <span class="number">0.0</span>;</span><br><span class="line">    map_.<span class="built_in">map</span>.info.origin.position.y = <span class="number">0.0</span>;</span><br><span class="line">    map_.<span class="built_in">map</span>.info.origin.position.z = <span class="number">0.0</span>;</span><br><span class="line">    map_.<span class="built_in">map</span>.info.origin.orientation.x = <span class="number">0.0</span>;</span><br><span class="line">    map_.<span class="built_in">map</span>.info.origin.orientation.y = <span class="number">0.0</span>;</span><br><span class="line">    map_.<span class="built_in">map</span>.info.origin.orientation.z = <span class="number">0.0</span>;</span><br><span class="line">    map_.<span class="built_in">map</span>.info.origin.orientation.w = <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算位姿的信息熵"><a href="#计算位姿的信息熵" class="headerlink" title="计算位姿的信息熵"></a>计算位姿的信息熵</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> SlamGMapping::computePoseEntropy()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> weight_total=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;GMapping::GridSlamProcessor::Particle&gt;::const_iterator it = gsp_-&gt;getParticles().begin();</span><br><span class="line">        it != gsp_-&gt;getParticles().end();</span><br><span class="line">        ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        weight_total += it-&gt;weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> entropy = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;GMapping::GridSlamProcessor::Particle&gt;::const_iterator it = gsp_-&gt;getParticles().begin();</span><br><span class="line">        it != gsp_-&gt;getParticles().end();</span><br><span class="line">        ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;weight/weight_total &gt; <span class="number">0.0</span>)</span><br><span class="line">            entropy += it-&gt;weight/weight_total * <span class="built_in">log</span>(it-&gt;weight/weight_total);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -entropy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第2部分"><a href="#第2部分" class="headerlink" title="第2部分"></a>第2部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*地图的中点*/</span></span><br><span class="line">GMapping::Point center;</span><br><span class="line">center.x=(xmin_ + xmax_) / <span class="number">2.0</span>;</span><br><span class="line">center.y=(ymin_ + ymax_) / <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化一个scanmatcherMap 创建一个地图 */</span></span><br><span class="line">GMapping::<span class="function">ScanMatcherMap <span class="title">smap</span><span class="params">(center, xmin_, ymin_, xmax_, ymax_,</span></span></span><br><span class="line"><span class="function"><span class="params">                              delta_)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*更新地图*/</span></span><br><span class="line"><span class="comment">//遍历最优粒子的整条轨迹树， 按照轨迹上各个节点存储的信息，计算激活区域更新地图</span></span><br><span class="line">ROS_DEBUG(<span class="string">"Trajectory tree:"</span>);</span><br><span class="line"><span class="keyword">for</span>(GMapping::GridSlamProcessor::TNode* n = best.node;n;n = n-&gt;parent)</span><br><span class="line">&#123;</span><br><span class="line">    ROS_DEBUG(<span class="string">"  %.3f %.3f %.3f"</span>,</span><br><span class="line">              n-&gt;pose.x,</span><br><span class="line">              n-&gt;pose.y,</span><br><span class="line">              n-&gt;pose.theta);</span><br><span class="line">    <span class="keyword">if</span>(!n-&gt;reading)</span><br><span class="line">    &#123;</span><br><span class="line">        ROS_DEBUG(<span class="string">"Reading is NULL"</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行地图更新</span></span><br><span class="line">    <span class="comment">//matcher.invalidateActiveArea();</span></span><br><span class="line">    <span class="comment">//matcher.computeActiveArea(smap, n-&gt;pose, &amp;((*n-&gt;reading)[0]));</span></span><br><span class="line">    <span class="comment">//matcher.registerScan(smap, n-&gt;pose, &amp;((*n-&gt;reading)[0]));</span></span><br><span class="line">    matcher.registerScan(smap, n-&gt;pose, &amp;(n-&gt;reading-&gt;m_dists[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the map may have expanded, so resize ros message as well</span></span><br><span class="line"><span class="comment">// 扩充地图的大小</span></span><br><span class="line"><span class="keyword">if</span>(map_.<span class="built_in">map</span>.info.width != (<span class="keyword">unsigned</span> <span class="keyword">int</span>) smap.getMapSizeX() || map_.<span class="built_in">map</span>.info.height != (<span class="keyword">unsigned</span> <span class="keyword">int</span>) smap.getMapSizeY())</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> The results of ScanMatcherMap::getSize() are different from the parameters given to the constructor</span></span><br><span class="line">    <span class="comment">//       so we must obtain the bounding box in a different way</span></span><br><span class="line">    GMapping::Point wmin = smap.map2world(GMapping::IntPoint(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    GMapping::Point wmax = smap.map2world(GMapping::IntPoint(smap.getMapSizeX(), smap.getMapSizeY()));</span><br><span class="line">    xmin_ = wmin.x; ymin_ = wmin.y;</span><br><span class="line">    xmax_ = wmax.x; ymax_ = wmax.y;</span><br><span class="line"></span><br><span class="line">    ROS_DEBUG(<span class="string">"map size is now %dx%d pixels (%f,%f)-(%f, %f)"</span>, smap.getMapSizeX(), smap.getMapSizeY(),</span><br><span class="line">              xmin_, ymin_, xmax_, ymax_);</span><br><span class="line"></span><br><span class="line">    map_.<span class="built_in">map</span>.info.width = smap.getMapSizeX();</span><br><span class="line">    map_.<span class="built_in">map</span>.info.height = smap.getMapSizeY();</span><br><span class="line">    map_.<span class="built_in">map</span>.info.origin.position.x = xmin_;</span><br><span class="line">    map_.<span class="built_in">map</span>.info.origin.position.y = ymin_;</span><br><span class="line">    map_.<span class="built_in">map</span>.data.resize(map_.<span class="built_in">map</span>.info.width * map_.<span class="built_in">map</span>.info.height);</span><br><span class="line"></span><br><span class="line">    ROS_DEBUG(<span class="string">"map origin: (%f, %f)"</span>, map_.<span class="built_in">map</span>.info.origin.position.x, map_.<span class="built_in">map</span>.info.origin.position.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据地图的信息计算出来各个点的情况:occ、free、noinformation</span></span><br><span class="line"><span class="comment">//这样对地图进行标记主要是方便用RVIZ显示出来</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x &lt; smap.getMapSizeX(); x++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>; y &lt; smap.getMapSizeY(); y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// @todo Sort out the unknown vs. free vs. obstacle thresholding</span></span><br><span class="line">        <span class="comment">/// 得到.xy被占用的概率</span></span><br><span class="line">        GMapping::<span class="function">IntPoint <span class="title">p</span><span class="params">(x, y)</span></span>;</span><br><span class="line">        <span class="keyword">double</span> occ=smap.cell(p);</span><br><span class="line">        assert(occ &lt;= <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//unknown</span></span><br><span class="line">        <span class="keyword">if</span>(occ &lt; <span class="number">0</span>)</span><br><span class="line">            map_.<span class="built_in">map</span>.data[MAP_IDX(map_.<span class="built_in">map</span>.info.width, x, y)] = GMAPPING_UNKNOWN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//占用</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(occ &gt; occ_thresh_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//map_.map.data[MAP_IDX(map_.map.info.width, x, y)] = (int)round(occ*100.0);</span></span><br><span class="line">            map_.<span class="built_in">map</span>.data[MAP_IDX(map_.<span class="built_in">map</span>.info.width, x, y)] = GMAPPING_OCC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//freespace</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            map_.<span class="built_in">map</span>.data[MAP_IDX(map_.<span class="built_in">map</span>.info.width, x, y)] = GMAPPING_FREE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//到了这一步，肯定是有地图了。</span></span><br><span class="line">got_map_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//make sure to set the header information on the map</span></span><br><span class="line"><span class="comment">//把计算出来的地图发布出去</span></span><br><span class="line">map_.<span class="built_in">map</span>.header.stamp = ros::Time::now();</span><br><span class="line">map_.<span class="built_in">map</span>.header.frame_id = tf_.resolve( map_frame_ );</span><br><span class="line"></span><br><span class="line">sst_.publish(map_.<span class="built_in">map</span>);</span><br><span class="line">sstm_.publish(map_.<span class="built_in">map</span>.info);</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/12/SLAM工具/OctoMap安装配置/">OctoMap安装配置</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SLAM工具/">SLAM工具</a></span><div class="content"><p>ROS环境下的安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 也可用与非ROS环境</span></span><br><span class="line">sudo apt-get install ros-kinetic-octomap</span><br><span class="line"><span class="comment"># octomap的查看工具</span></span><br><span class="line">sudo apt-get install ros-kinetic-octovis</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p><code>octomap_ros</code>和<code>octomap_msgs</code>提供了消息文件，封装和转换方法。<code>octomap_server</code>提供建图和服务</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>在<code>package.xml</code>中添加：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;octomap&lt;/build_depend&gt;</span><br><span class="line">&lt;run_depend&gt;octomap&lt;/run_depend&gt;</span><br></pre></td></tr></table></figure><p>因为库提供了CMake的config文件，所以直接这样用：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find_package(octomap REQUIRED)</span><br><span class="line">include_directories(<span class="variable">$&#123;OCTOMAP_INCLUDE_DIRS&#125;</span>)</span><br><span class="line">target_link_libraries(<span class="variable">$&#123;OCTOMAP_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/11/PCL点云/点云滤波/">点云滤波</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/PCL点云/">PCL点云</a></span><div class="content"><p>地图分很多种：稀疏的，稠密的，还有半稀疏的。稀疏的地图放大了看就是一个个离散的空间点，不过我们可以把它变成连续的稠密的网格，这个过程也叫点云的网格化。点云网格化需要对点云进行一系列处理</p><p>一般下面这几种情况需要进行点云滤波处理：</p><ol><li><p>点云数据密度不规则需要平滑</p></li><li><p>因为遮挡等问题造成离群点需要去除</p></li><li><p>大量数据需要下采样</p></li><li><p>噪声数据需要去除</p></li></ol><p>滤波模块主要是调用一些封装好的滤波函数，然后根据需要设定一下参数</p><p>滤波对应的方案有如下几种：</p><ul><li>按照给定的规则限制过滤去除点</li><li>通过常用滤波算法修改点的部分属性</li><li>对数据进行下采样</li></ul><h2 id="滤波程序"><a href="#滤波程序" class="headerlink" title="滤波程序"></a>滤波程序</h2><p><code>package.xml</code>中要添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;libpcl-all-dev&lt;/build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;libpcl-all&lt;/exec_depend&gt;</span><br></pre></td></tr></table></figure><p>CMake按照第一篇里进行配置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sensor_msgs/PointCloud2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl_conversions/pcl_conversions.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_cloud.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="comment">//滤波的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/voxel_grid.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ros::Publisher pub;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cloud_cb</span> <span class="params">(<span class="keyword">const</span> sensor_msgs::PointCloud2ConstPtr&amp; cloud_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 声明存储原始数据与滤波后的数据的点云的格式</span></span><br><span class="line">  pcl::PCLPointCloud2* cloud = <span class="keyword">new</span> pcl::PCLPointCloud2; <span class="comment">//原始的点云的数据格式</span></span><br><span class="line">  pcl::<span class="function">PCLPointCloud2ConstPtr <span class="title">cloudPtr</span><span class="params">(cloud)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ROS消息转化为PCL中的点云数据格式</span></span><br><span class="line">  pcl_conversions::toPCL(*cloud_msg, *cloud);</span><br><span class="line"></span><br><span class="line">  pcl::PCLPointCloud2 cloud_filtered;   <span class="comment">//存储滤波后的数据格式</span></span><br><span class="line">  <span class="comment">// 进行一个滤波处理</span></span><br><span class="line">  pcl::VoxelGrid&lt;pcl::PCLPointCloud2&gt; sor; <span class="comment">//创建滤波对象</span></span><br><span class="line">  sor.setInputCloud (cloudPtr);  <span class="comment">//设置输入的滤波，将需要过滤的点云给滤波对象</span></span><br><span class="line">  sor.setLeafSize (<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>);  <span class="comment">//设置滤波时创建的体素大小为1cm立方体</span></span><br><span class="line">  sor.filter (cloud_filtered);<span class="comment">//执行滤波处理，存储输出cloud_filtered</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 再将滤波后的点云的数据格式转换为ROS下的数据格式发布</span></span><br><span class="line">  sensor_msgs::PointCloud2 output;</span><br><span class="line">  pcl_conversions::moveFromPCL(cloud_filtered, output);<span class="comment">//第一个参数是输入，后面的是输出</span></span><br><span class="line">  pub.publish (output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::init (argc, argv, <span class="string">"filter_cloud"</span>);<span class="comment">//声明节点的名称</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  ros::Subscriber sub = nh.subscribe&lt;sensor_msgs::PointCloud2&gt; (<span class="string">"/camera/depth/points"</span>, <span class="number">1</span>, cloud_cb);</span><br><span class="line">  pub = nh.advertise&lt;sensor_msgs::PointCloud2&gt; (<span class="string">"filtered_cloud"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  ros::spin ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/39/">39</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image:url(https://live.staticflickr.com/65535/48055510011_577ff62eaf_b.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>