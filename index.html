<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG={root:"/",algolia:{appId:"RI90VLL69D",apiKey:"20c535e9a1424a7913210eb747d6e67b",indexName:"HexoBlog",hits:{per_page:10},languages:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}.",hits_stats:"${hits} results found in ${time} ms"}},localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">423</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">49</span></a></div></div></div><nav id="nav" style="background-image:url(https://i.loli.net/2020/07/13/QgyrefaLDxhBWSZ.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div><div id="site-social-icons"><a class="social-icon" href="https://github.com/charon-cheung"><i class="fa-github fa"></i></a><a class="social-icon search"><i class="fa fa-search"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/18/路径规划/TEB源码/">TEB源码</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/">路径规划</a></span><div class="content"><p><code>MoveBase::executeCycle()</code> —&gt; <code>computeVelocityCommands</code> —&gt; <code>planner_-&gt;plan</code> —&gt;</p><p>调用local_planner的函数主要是<code>tc_-&gt;computeVelocityCommands(cmd_vel)</code>，就是这个函数开始调用TEB算法，下面转入<code>teb_local_planner_ros.cpp</code>文件中。</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/18/ROS/ROS机器人/rqt_robot_steering/">rqt_robot_steering</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS机器人/">ROS机器人</a></span><div class="content"><p><img src="https://i.loli.net/2020/10/14/mWBL6c7pu9nDjF4.png" alt="rqt_robot_steering"><br>一个带界面的节点，只要一启动，就不断发布<code>geometry_msgs/Twist</code>消息，调节滑条做配置</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/18/视觉SLAM/从ROS配置realsense的参数/">从ROS配置realsense的参数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/视觉SLAM/">视觉SLAM</a></span><div class="content"><h2 id="使用json配置realsense的参数-非rosparam"><a href="#使用json配置realsense的参数-非rosparam" class="headerlink" title="使用json配置realsense的参数(非rosparam)"></a>使用json配置realsense的参数(非rosparam)</h2><p>今天使用realsense时，发现有个参数需要修改<br><img src="https://i.loli.net/2020/10/15/lWn3xzM1CiyZtQX.png" alt="Set Point.png"><br>这个参数可以修正因反光而导致的错误，也就是把稍微凸起的地面当做障碍物，适当减小这个参数可以实现。</p><p>这个界面在realsense viewer中，但问题是如何在ROS中做到，它在rosparam中没有对应的参数。查来查去，在github的issue里发现了解决方法。realsense已经提供了一种<code>visual preset</code>文件，其实是个json文件，可以对很多参数设置，而且realsense的launch文件中已经定义了json文件的路径，比如<code>rs_camera.launch</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"json_file_path"</span>      <span class="attr">default</span>=<span class="string">""</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>realsense提供的所有json文件在<a href="https://github.com/IntelRealSense/librealsense/wiki/D400-Series-Visual-Presets" target="_blank" rel="noopener">这里</a>，我们需要的参数在<a href="https://raw.githubusercontent.com/wiki/IntelRealSense/librealsense/d400_presets/DefaultPreset_D435.json" target="_blank" rel="noopener">DefaultPreset_D435.json</a>，也就是第一个参数：<code>&quot;aux-param-autoexposure-setpoint&quot;: &quot;400&quot;</code>，修改它的值后，把json文件的路径填到上面launch参数那里，启动launch就可以实现了。不过不能动态调整参数。</p><h2 id="配置点云的滤波器"><a href="#配置点云的滤波器" class="headerlink" title="配置点云的滤波器"></a>配置点云的滤波器</h2><p><code>rs_camera.launch</code>的参数是比较全的，<code>demo_pointcloud.launch</code>比较少。</p><p>现在介绍<code>filters</code>这个参数，在launch中没有赋值:<code>&lt;arg name=&quot;filters&quot; default=&quot;&quot;/&gt;</code></p><p>pointcloud: 点云话题是<code>/camera/depth/color/points</code>. 点云的texture可以在<code>rqt_reconfigure</code>里修改，或者用参数<code>pointcloud_texture_stream</code>和<code>pointcloud_texture_index</code>修改</p><p>The depth FOV and the texture FOV are not similar. By default, pointcloud is limited to the section of depth containing the texture. You can have a full depth to pointcloud, coloring the regions beyond the texture with zeros, by setting allow_no_texture_points to true.</p><p>可以配置的滤波器如下:</p><ul><li>disparity, convert depth to disparity before applying other filters and back.</li><li>spatial，filter the depth image spatially.</li><li>temporal，filter the depth image temporally.</li><li>hole_filling，apply hole-filling filter.</li><li>decimation，reduces depth scene complexity.</li></ul><p>所有滤波器的说明在<a href="https://github.com/IntelRealSense/librealsense/blob/master/doc/post-processing-filters.md" target="_blank" rel="noopener">这里</a></p><p>给参数<code>filters</code>赋值，必须有<code>pointcloud</code>，再增加滤波器，用逗号隔开。比如 <code>disparity,spatial,pointcloud</code></p><p>滤波器的相关的源码在<code>base_realsense_node.cpp</code></p><ul><li><p><code>BaseRealSenseNode::setupFilters()</code>, 读取参数<code>filters</code>，把所有滤波器名称都插入容器<code>_filters</code></p></li><li><p><code>BaseRealSenseNode::publishPointCloud()</code>, 发布滤波后的点云</p></li></ul><p>参考:<br><a href="https://github.com/IntelRealSense/realsense-ros" target="_blank" rel="noopener">realsense-ros 滤波器</a><br><a href="https://blog.csdn.net/Dontla/article/details/103574458" target="_blank" rel="noopener">CSDN Realsense D435 Post-processing filters</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/18/路径规划/stage的使用心得/">stage的使用心得</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/">路径规划</a></span><div class="content"><p>Stage 可以模拟里程计噪声</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun stage_ros stageros /opt/ros/melodic/share/stage_ros/world/willow-erratic.world</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/18/路径规划/TEB算法/">TEB算法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/">路径规划</a></span><div class="content"><p>drive robot 依据自由度的可控性(controllable)划分为<code>nonholonomic</code>或者<code>holonomic robot</code></p><ul><li><p>holonomic robot: 在所有的自由度上都可控的，比如基于万向轮的机器人（robot built on Omni-wheels）</p></li><li><p>nonholonomic robot: 差速车或阿克曼车。可控的自由度维数小于机器人自身的自由度，比如car自身有3个自由度（x，y，theta），即平面坐标和车身朝向，但car可控的自由度是2（加减速度，转动方向盘，不能随意的漂移运动）</p></li></ul><p>从另一个直观通俗的角度可以理解为：如果机器人可以在N维空间中朝任意方向移动，则对于N维空间是完整性的。而机器人在N维空间中不能朝任意方向移动，则认为是非完整性约束。</p><p>TEB算法明确考虑运动的时间方面的动态约束，如有限的机器人速度和加速度。在加权多目标优化框架下，建立了“TEB”问题。大多数目标都是局部的，因为它们依赖于一些相邻的中间状态配置。结果得到一个稀疏系统矩阵，其中存在有效的大规模约束最小二乘优化方法。</p><p>teb_local_planner是2D导航堆栈的<code>base_local_planner</code>的插件。实现了一个在线优化的本地轨迹规划器，对全局规划器生成的初始轨迹在运行时期间进行优化，最小化轨迹执行时间（时间最优目标）， 与障碍物分离并符合动力学约束，例如满足最大速度和加速度。当前的实施符合非完整机器人（差动驱动和类似汽车的机器人）的运动学。</p><p><code>dwa_local_planner</code>算法前瞻更短，小车基本会保持运行在全局路径左右，而<code>teb_local_planner</code>算法前瞻相对较长在遇到障碍时，局部路径会自动规划避过障碍物，但是如果小车处在比较复杂的环境下，局部路径会比较容易出现混乱的现象。</p><p>由于TEB使用了 a local optimization scheme, the trajectory cannot transit across obstacles.</p><p>如果计算机性能不好，调节以下参数以提高优化：</p><ul><li><p>减小no_inner_iterations</p></li><li><p>减小<code>no_outer_iterations</code></p></li><li><p>增大<code>dt_ref</code></p></li><li><p>减小<code>obstacle_poses_affected</code></p></li></ul><ul><li>observation_persistence: 2.0. If you set that value to zero, the costmap will only account for the most recent observation data.</li></ul><p><code>observation_persistence</code> is broken. Setting it to 0 does not only keep keep the most recent reading.</p><p>如果障碍层的<code>max_obstacle_height</code>设置为大于全局max_obstacle_height参数的值将会失效。 设置为小于全局<code>max_obstacle_height</code>的值将过滤掉传感器上大于该高度以的点。</p><p>minimizing the trajectory execution time (time-optimal objective), separation from obstacles and compliance with kinodynamic constraints such as satisfying maximum velocities and accelerations.</p><p>The current implementation complies with the kinematics of non-holonomic robots (differential drive and car-like robots). Support of holonomic robots is included since Kinetic.</p><p>TEB有时会因为无法穿过障碍物，而卡在一个局部的优化路径上。 A subset of admissible trajectories of distinctive topologies is optimized in parallel. The local planner is able to switch to the current globally optimal trajectory among the candidate set. Distinctive topologies are obtained by utilizing the concept of <code>homology / homotopy</code> classes. The following papers are describing the approach</p><ul><li>Add and improve safety functions in case of unavoidable obstacles (e.g. for obstacles that are located really close to the goal).</li><li>Implementation of suitable escape behaviors.</li><li>Improvements/Solutions for cases in which the planner oscillates between multiple locally optimal solutions (not on a topologic basis, but due to occuring noise etc.).</li></ul><p><img src="https://i.loli.net/2020/10/18/iNb3gr1PkyHOpTz.png" alt="凸函数定义.png"></p><h3 id="HomotopyClass"><a href="#HomotopyClass" class="headerlink" title="HomotopyClass"></a>HomotopyClass</h3><p>teb_local_planner包中实现了两种规划器，一个就是普通的TebOptimalPlanner，另一个是<code>HomotopyClassPlanner</code>，HomotopyClassPlanner是一种同时优化多个轨迹的方法，由于目标函数的非凸性(非凸函数)会生成一系列最优的候选轨迹，最终在备选局部解的集合中寻求总体最佳候选轨迹，对应论文：<code>《Integrated online trajectory planning and optimization in distinctive topologies》</code></p><p><code>Homotopy Class Planner</code>部分的参数与HomotopyClass规划器相关，<code>enable_homotopy_class_planning</code>设置False则不启用<br><img src="https://i.loli.net/2020/10/18/XaWO6bcFpiyvQRq.png" alt="不用homotopy.png"></p><h3 id="weight-viapoint"><a href="#weight-viapoint" class="headerlink" title="weight_viapoint"></a>weight_viapoint</h3><p><img src="https://i.loli.net/2020/10/18/tpyvb2nC95iYeA6.png" alt="weight_viapoint=10.png"><br><img src="https://i.loli.net/2020/10/18/uvxf2nsrmiU7OXS.png" alt="weight_viapoint=1.png"></p><h2 id="costmap-converter"><a href="#costmap-converter" class="headerlink" title="costmap_converter"></a>costmap_converter</h2><p>参数<code>costmap_converter_plugin</code>，决定是否使用costmap_converter插件，原始costmap中障碍物全部以<strong>点</strong>来表示，计算机器人到障碍物的距离实际需要计算机器人到每一个“障碍物点”的距离，当环境非常复杂时计算代价会非常大。costmap_converter插件可以将障碍物预先表示成线段或多边形的形式，在一定程度上减轻后续计算距离的压力</p><ul><li>min_obstacle_dist</li><li>obstacle_poses_affected</li><li>dt_ref</li></ul></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/18/ROS/ROS Kinetic知识/ROS版本不兼容产生的TransformListenerWrapper问题/">ROS版本不兼容产生的TransformListenerWrapper问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-18</time><div class="content"><p><code>AmclNode</code>类中有这样一段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use a child class to get access to tf2::Buffer class inside of tf_</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TransformListenerWrapper</span> :</span> <span class="keyword">public</span> tf::TransformListener</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">inline</span> tf2_ros::<span class="function">Buffer &amp;<span class="title">getBuffer</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> tf2_buffer_;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是Kinetic的版本，但是在Melodic里没有这一段了，这是ROS版本兼容问题，在Kinetic里用不了这个结构体了。搜索发现<code>getBuffer</code>只有在<code>AmclNode::runFromBag</code>里调用，因为平时不用bag仿真时测试AMCL，所以这句话可以注释掉。</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/25/激光SLAM/ICP/csm包的源码解读 (二)/">csm包的源码解读 (二)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/ICP/">ICP</a></span><div class="content"><p><img src="https://i.loli.net/2020/09/25/6sJwMcTGiyY9Ztb.png" alt="smart algorithm.png"></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/21/激光SLAM/Cartographer/源码解读/(七) 处理里程计和IMU数据的流程/">(七) 处理里程计和IMU数据的流程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/Cartographer/源码解读/">源码解读</a></span><div class="content"><p><img src="https://i.loli.net/2020/09/21/rGYzJWLIel85FMw.png" alt="处理里程计数据的流程.png"></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/20/数学基础/坐标系空间转换/">坐标系空间转换</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/数学基础/">数学基础</a></span><div class="content"><p><img src="https://i.loli.net/2020/09/20/hsubLed7priFZmS.jpg" alt="坐标系示意图.jpg"><br><img src="https://i.loli.net/2020/09/20/YzpFTi8yEwqHhf5.jpg" alt="圆加和圆减.jpg"><br><img src="https://i.loli.net/2020/09/20/WbSvxUlGwCHNzgF.png" alt="1.png"></p><p><a href="https://www.pianshen.com/article/17351558785/" target="_blank" rel="noopener">cartographer中公式的推导</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/19/激光SLAM/ICP/laser_scan_matcher 源码解读/">laser_scan_matcher 源码解读</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/ICP/">ICP</a></span><div class="content"><p>主要是<code>LaserScanMatcher</code>的构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ros::init(argc, argv, <span class="string">"LaserScanMatcher"</span>);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">ros::<span class="function">NodeHandle <span class="title">nh_private</span><span class="params">(<span class="string">"~"</span>)</span></span>;</span><br><span class="line">scan_tools::<span class="function">LaserScanMatcher <span class="title">laser_scan_matcher</span><span class="params">(nh, nh_private)</span></span>;</span><br><span class="line">ros::spin();</span><br></pre></td></tr></table></figure><p>构造函数里初始化一系列参数，重点就是回调函数<code>scanCallback</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一帧scan, cache the tf from base to the scanner</span></span><br><span class="line"><span class="keyword">if</span> (!initialized_)</span><br><span class="line">&#123;</span><br><span class="line">  createCache(scan_msg);    <span class="comment">// caches the sin and cos of all angles</span></span><br><span class="line">  <span class="comment">// cache the static tf from base to laser</span></span><br><span class="line">  <span class="keyword">if</span> (!getBaseToLaserTf(scan_msg-&gt;header.frame_id))</span><br><span class="line">  &#123;</span><br><span class="line">    ROS_WARN(<span class="string">"Skipping scan"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 保存scan数据到  LDP  prev_ldp_scan_;</span></span><br><span class="line">  laserScanToLDP(scan_msg, prev_ldp_scan_);</span><br><span class="line">  last_icp_time_ = scan_msg-&gt;header.stamp;</span><br><span class="line">  initialized_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二帧及以后的scan</span></span><br><span class="line">index++;		<span class="comment">// static unsigned int index;</span></span><br><span class="line">ROS_INFO(<span class="string">"scan index: %d"</span>, index);</span><br><span class="line">LDP  curr_ldp_scan;</span><br><span class="line">laserScanToLDP(scan_msg, curr_ldp_scan);</span><br><span class="line">processScan(curr_ldp_scan, scan_msg-&gt;header.stamp);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/20/VTNfbxGYmPqK3Li.png" alt="流程.png"></p><h2 id="公式计算"><a href="#公式计算" class="headerlink" title="公式计算"></a>公式计算</h2><h2 id="newKeyframeNeeded"><a href="#newKeyframeNeeded" class="headerlink" title="newKeyframeNeeded"></a>newKeyframeNeeded</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(tf::getYaw(d.getRotation())) &gt; kf_dist_angular_)</span><br><span class="line">   <span class="keyword">return</span>   <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">double</span> x = d.getOrigin().getX();</span><br><span class="line"><span class="keyword">double</span> y = d.getOrigin().getY();</span><br><span class="line"><span class="keyword">if</span> (x*x + y*y &gt; kf_dist_linear_sq_)</span><br><span class="line">   <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>优先判断相对旋转</p><p>调用是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交换新旧frame, key frame 的意思应该是当前配准时的参考帧</span></span><br><span class="line"><span class="comment">// 这个在机器人一直走直线或原地旋转时很难发生</span></span><br><span class="line"><span class="keyword">if</span> (newKeyframeNeeded(corr_ch))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// generate  a  keyframe</span></span><br><span class="line">	ld_free(prev_ldp_scan_);</span><br><span class="line">	prev_ldp_scan_ = curr_ldp_scan;</span><br><span class="line">	<span class="comment">// 更新下一个时间段的 f2b_kf</span></span><br><span class="line">	f2b_kf_ = f2b_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>prev_ldp_scan_</code>之前是第一帧scan的数据，只有需要 key frame时，才会更新它，但在<code>processScan</code>开头又会把估计位姿和真值初始化为0。 如果没有达到运动阈值，<code>prev_ldp_scan_</code>还是第一帧scan，时间也是第一帧的时间，仍以第一帧为基准进行ICP配准</p></div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/43/">43</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image:url(https://i.loli.net/2020/07/13/QgyrefaLDxhBWSZ.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>