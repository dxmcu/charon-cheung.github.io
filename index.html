<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>教练，我想当程序员 | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG={root:"/",algolia:{appId:"RI90VLL69D",apiKey:"20c535e9a1424a7913210eb747d6e67b",indexName:"HexoBlog",hits:{per_page:10},languages:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}.",hits_stats:"${hits} results found in ${time} ms"}},localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">314</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">41</span></a></div></div></div><nav id="nav" style="background-image:url(https://live.staticflickr.com/65535/48055510011_577ff62eaf_b.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">教练，我想当程序员</div><div id="site-social-icons"><a class="social-icon" href="https://github.com/charon-cheung"><i class="fa-github fa"></i></a><a class="social-icon search"><i class="fa fa-search"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/04/SLAM工具/PCL点云/(二) ICP算法/">(二) ICP算法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SLAM工具/">SLAM工具</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SLAM工具/PCL点云/">PCL点云</a></span><div class="content"><p>ICP算法采用最小二乘估计计算变换矩阵，原理简单且具有较好的精度，但是由于采用了迭代计算，导致算法计算速度较慢，而且采用ICP进行配准计算时，其对待配准点云的初始位置有一定要求，若所选初始位置不合理，则会导致算法陷入局部最优。</p><p>IterativeClosestPoint类提供了标准ICP算法的实现（The transformation is estimated based on SVD），算法迭代结束条件有如下几个:</p><ul><li>最大迭代次数： 最大迭代次数。 <code>setMaximumIterations (100)</code></li><li>两次变化矩阵之间的差值：前一个变换矩阵和当前变换矩阵的差异小于阈值时，就认为已经收敛了。 <code>setTransformationEpsilon(1e-10)</code></li><li>均方误差（MSE）：均方误差和小于给定阈值， 停止迭代。 <code>setEuclideanFitnessEpsilon(0.01)</code></li></ul><p><code>align</code>函数是配准，<strong>在使用之前至少给定上面三个条件</strong>，还有<code>setMaxCorrespondenceDistance</code>等其他函数。PCL的ICP里的transformation estimation就是基于SVD分解实现的。</p><p>如果从一个好的<strong>初始猜想变换矩阵</strong>开始迭代，那么算法将会在比较少的迭代之后就收敛，配准结果也较好，当像我们这里没有指定初始guess时，就默认使用单位阵<code>Matrix4::Identity()</code></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/03/SLAM工具/PCL点云/(三)杂项/">(二) 杂项</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/PCL点云/">PCL点云</a></span><div class="content"><h3 id="计时"><a href="#计时" class="headerlink" title="计时"></a>计时</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pcl::console::TicToc time;</span><br><span class="line">time.tic ();</span><br><span class="line"><span class="comment">//需要记录执行多长时间的代码</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;time.toc () &lt;&lt; <span class="string">" ms :&lt;&lt; endl;</span></span><br></pre></td></tr></table></figure><h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><p>同ROS类似，就是把ROS换成了PCL: PCL_DEBUG, PCL_INFO, PCL_WARN, PCL_ERROR</p><p>参考：<a href="http://pointclouds.org/documentation/tutorials/pcl_visualizer.php#pcl-visualizer" target="_blank" rel="noopener"></a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/02/激光SLAM/深蓝学院-激光SLAM理论与实践/第4章 前端配准I/">第4章 前端配准I</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/深蓝学院-激光SLAM理论与实践/">深蓝学院-激光SLAM理论与实践</a></span><div class="content"><p>前端匹配又叫帧间匹配</p><p>SLAM前端匹配，是构建方程的过程。后端优化是求解方程的过程。一个好的SLAM算法重点在前端。</p><ul><li>ICP：迭代最近点</li><li>PL-ICP：点到线的ICP</li><li>NICP：法向量的ICP</li><li>IMLS-ICP：implicit moving least square，隐式移动最小二乘</li></ul><p>四种方法，依次精度更高，计算量更大。</p><p><img src="https://i.loli.net/2020/03/02/JTq3rFOoXwU4Zlu.png" alt></p><h3 id="ICP"><a href="#ICP" class="headerlink" title="ICP"></a>ICP</h3><p>R,t就是相邻两帧激光对应的机器人位置的欧氏变换，以此类推，根据很多帧的点云，就能求出一系列的机器人位姿变换关系。<br>ICP有二维和三维。<br>由于两个点云对应同一个实体，那么理论上配准后的距离应该为0，由于误差的存在，我们要求距离的最小值。</p><p>对于已知对应点的情况(已知R)，我们可以求出解析解，而不必用迭代方法：<br><img src="https://i.loli.net/2020/03/02/A4yZXVaoPLjkuQT.png" alt></p><p>实际中不知道对应点匹配，不能直接算出R和t，要进行迭代计算：寻找对应点，根据对应点计算R,t；对点云转换再计算误差；不断迭代直至误差足够小。</p><p>ICP的一个明显缺陷：两帧激光点云数据中的点不可能表示的是空间中相同的位置。所以用点到点的距离作为误差方程势必会引入随机误差。</p><ul><li>依赖初始值，初始值不好时，迭代次数增加；对于较大的初始误差，可能会出现错误的迭代结果</li><li>ICP是一阶收敛，收敛速度慢。（所以会用kd-tree来加快搜索效率）</li><li>会有离群点及噪声</li></ul><p>所以原始的ICP太粗糙，不足以应用实践。</p><h3 id="PL-ICP"><a href="#PL-ICP" class="headerlink" title="PL-ICP"></a>PL-ICP</h3><p>这一段视频又讲的不好，对censi论文中的PL-ICP示意图讲解不到位，对红色和蓝色的点，同心圆没有说明，而且数学公式怀疑有问题，看的云里雾里。</p><p>Point to Line-ICP修改的是误差尺度，思想和之后的ICP类似。</p><p>雷达的激光点是对实际环境中曲面的离散采样。重要的不是激光点，而是曲面。最好的误差尺度为当前激光点到实际<br>曲面的距离；所以关键的问题在于如何恢复曲面</p><p>PL-ICP：用分段线性的方法（折线）来对实际曲面进行近似，从而定义当前帧激光点到曲面的距离</p><ol><li>ICP对点对点的距离作为误差，PL-ICP为点到线的距离作为误差；PL-ICP的误差形式更符号实际情况。</li><li>收敛速度不同，ICP为一阶收敛，PL-ICP为二阶收敛。</li><li>PL-ICP的求解精度高于ICP，特别是在结构化环境中。不适合室外</li><li>PL-ICP对初始值更敏感。不单独使用，其容易陷入局部循环。与里程计、CSM等一起使用，通常用里程计得到一个初始转换矩阵q0给到PL-ICP算法</li></ol><p>ros的csm包实现了ICP和PL-ICP算法。作者给出了一个该功能包的操作说明文件（csm_manual.pdf）。里面详细描述了各项配置参数的含义。其中sm/app文件夹中的sm0.c sm1.c sm2.c sm3.c 相当于是几个使用示例。 主要的算法实现是在csm/icp文件夹中的几个文件里。论文中的所有算法步骤完整的体现在了icp_loop.c文件中的icp_loop函数里。</p><h3 id="NICP"><a href="#NICP" class="headerlink" title="NICP"></a>NICP</h3><p>normal ICP，法向量ICP</p><p>旋转带入比较大的平移误差，但平移不会带来很大旋转误差</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/25/lua学习/">lua学习</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/谷歌Cartographer学习/">谷歌Cartographer学习</a></span><div class="content"><p>从官网下载压缩包后，解压再执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd lua-5.3.0</span><br><span class="line">make linux test</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><code>lua -v</code>显示版本，接下来创建一个<code>test.lua</code>文件，代码如下:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello World!"</span>)</span><br></pre></td></tr></table></figure><p>执行命令<code>lua test.lua</code>得到输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/25/第三方库/matlab画等高线/">matlab画等高线</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/第三方库/">第三方库</a></span><div class="content"><p><img src="https://i.loli.net/2020/02/25/HD4GbkKmSudNgvE.png" alt="2020-02-25_130103.png"></p><p>matlab的操作步骤：</p><ol><li>产生独立变量，为带有两个变量 x 和 y 的集合，meshgrid是一个可以建立独立变量的函数，产生矩阵元素，元素x和y按照指定的范围和增量来产生。</li><li>输入要使用的函数</li><li>调用contour(x,y,w)命令，contour函数是画一个多维函数的等高线</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[x,y] = <span class="built_in">meshgrid</span>(<span class="number">-5</span>:<span class="number">0.05</span>:<span class="number">5</span>,<span class="number">-5</span>:<span class="number">0.05</span>:<span class="number">5</span>)</span><br><span class="line">w = x.^<span class="number">2</span>+y.^<span class="number">2</span></span><br><span class="line">contour(x,y,w, <span class="string">'showText'</span>, <span class="string">'on'</span>)</span><br><span class="line"><span class="comment">% surf(x,y,w), title('等高线')</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/25/jkSvBFGabXLyCKp.png" alt="等高线.png"></p><p>surf函数用于画三维的等高线<br><img src="https://i.loli.net/2020/02/25/sNKnCUXlHVGPbJB.png" alt="三维的等高线.png"></p><p>高维高斯分布的概率密度函数和等高线图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">u=[<span class="number">0</span>;<span class="number">0</span>];<span class="comment">%均值</span></span><br><span class="line">v=[<span class="number">4</span>,<span class="number">3</span>;<span class="number">3</span>,<span class="number">9</span>];<span class="comment">%协方差阵</span></span><br><span class="line">x=<span class="number">-7</span>:<span class="number">0.05</span>:<span class="number">7</span>;</span><br><span class="line">y=<span class="number">-7</span>:<span class="number">0.05</span>:<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">[X,Y]=<span class="built_in">meshgrid</span>(x,y);</span><br><span class="line">s2x=v(<span class="number">1</span>,<span class="number">1</span>)      <span class="comment">%x的方差</span></span><br><span class="line">s2y=v(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">sx=<span class="built_in">sqrt</span>(s2x)    <span class="comment">%标准差多个</span></span><br><span class="line">sy=<span class="built_in">sqrt</span>(s2y)</span><br><span class="line">Cov=v(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">r=Cov/(sx*sy)</span><br><span class="line">a=<span class="number">1</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*sx*sy*<span class="built_in">sqrt</span>(<span class="number">1</span>-r^<span class="number">2</span>));</span><br><span class="line">b1=<span class="number">-1</span>/(<span class="number">2</span>*(<span class="number">1</span>-r^<span class="number">2</span>));</span><br><span class="line">b2=((X-u(<span class="number">1</span>))./sx).^<span class="number">2</span>;</span><br><span class="line">b3=((Y-u(<span class="number">2</span>))./sy).^<span class="number">2</span>;</span><br><span class="line">b4=<span class="number">2</span>*r.*(X-u(<span class="number">1</span>)).*(Y-u(<span class="number">2</span>))./(sx*sy)</span><br><span class="line">Z=a*<span class="built_in">exp</span>(b1*(b2+b3-b4));     <span class="comment">%也就是f(x1,x2)的表达式</span></span><br><span class="line"></span><br><span class="line">mesh(X,Y,Z),title(<span class="string">'密度函数图'</span>)</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">contour(X,Y,Z,<span class="string">'showText'</span>,<span class="string">'on'</span>),title(<span class="string">'等高线图'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/25/tWFAlsfpZD2iwvr.png" alt="等高线图.png"><br><img src="https://i.loli.net/2020/02/25/aQbV5KUmonJLg7i.png" alt="密度图.png"></p><p>参考： <a href="https://zlearning.netlify.com/communication/matlab/matlab-surface-contour.html" target="_blank" rel="noopener">使用surface 和 contour 画图</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/23/英语单词收集/">英语单词收集</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/其他/">其他</a></span><div class="content"><p>culprit 责任人，罪魁祸首<br>stroll 漫步<br>commend 表彰，称赞<br>stop and frisk 拦截盘查<br>eerie 怪异的<br>fahrenheit 华氏温度<br>voter turnout 投票人数; 投票率<br>conman 骗子<br>philanthropist 慈善家<br>weigh in 加入比赛或辩论<br>toss-up 焦灼的情况<br>disown 否认，声明同。。。脱离关系<br>moderator 调解人；仲裁人<br>jurisdiction 管辖权；司法权<br>jeopardy 危险境地； 被告在法庭上有被判罪的危险；<br>reinstate 使复原； 使恢复<br>tax code 税制<br>perpetuate 使永存； 使不朽<br>underdog 落后者<br>maverick 特立独行的人<br>give me a break (表示不信对方胡诌的感叹语)得了吧!我不会相信的<br>trash 猛烈抨击<br>litigate 提起诉讼<br>level at 将…的矛头指向（某人）<br>add up 合乎情理<br>cat out of the bag 在不小心的情况下泻露了秘密<br>expunge 刪去,抹去<br>nostalgia 怀旧<br>heckler 用不友好的言辞打断公开演讲或表演的人</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/22/第三方库/ceres库/">ceres库</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/第三方库/">第三方库</a></span><div class="content"><p>ceres是google库，首先安装相关依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install liblapack-dev libsuitesparse-dev libcxsparse3.1.2 libgflags-dev </span><br><span class="line">sudo apt-get install libgoogle-glog-dev libgtest-dev</span><br></pre></td></tr></table></figure><p>如果安装时找不到 cxsparse 或者其他的lib，需要添加下面的源</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>把下面的源粘贴到source.list的最上方: <code>deb http://cz.archive.ubuntu.com/ubuntu trusty main universe</code><br>更新一下: <code>sudo apt-get update</code>， 然后再进行第一步的安装。</p><p>从<a href="https://github.com/ceres-solver/ceres-solver" target="_blank" rel="noopener">github</a>上下载，这里要注意ceres的版本和Eigen是搭配的，ceres版本越新，对Eigen的版本要求也越新，它的<code>CMakeLists</code>里有提示，所以不要安装最新的。</p><p>下载解压后执行老一套命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make </span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/21/SLAM工具/Eigen/线性代数库Eigen（二）/">(二) 欧氏变换，最小二乘，SVD</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SLAM工具/">SLAM工具</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SLAM工具/Eigen/">Eigen</a></span><div class="content"><h2 id="欧氏变换"><a href="#欧氏变换" class="headerlink" title="欧氏变换"></a>欧氏变换</h2><p>欧氏变换(Isometry Transform)可以看作是维持任意两点距离不变的变换，在实际场景中使用比较多。在Eigen中已经内置好了一些常用的欧氏变换:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Transform&lt;<span class="keyword">float</span>,<span class="number">2</span>,Isometry&gt; Isometry2f;</span><br><span class="line"><span class="keyword">typedef</span> Transform&lt;<span class="keyword">float</span>,<span class="number">3</span>,Isometry&gt; Isometry3f;</span><br><span class="line"><span class="keyword">typedef</span> Transform&lt;<span class="keyword">double</span>,<span class="number">2</span>,Isometry&gt; Isometry2d;</span><br><span class="line"><span class="keyword">typedef</span> Transform&lt;<span class="keyword">double</span>,<span class="number">3</span>,Isometry&gt; Isometry3d;</span><br></pre></td></tr></table></figure><p>欧氏变换必须初始化，如果没初始化，Isometry3d中的元素全为0，一般初始化为单位矩阵，也可以初始化为Quaternion。 赋值可以通过它的成员函数.rotate()和.translate()完成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AngleAxisd <span class="title">rotation</span><span class="params">(<span class="number">3.1415926</span> / <span class="number">4</span>, Vector3d(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>).normalized())</span></span>;</span><br><span class="line"><span class="function">Vector3d <span class="title">translation</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">Isometry3d T= Isometry3d::Identity();</span><br><span class="line"><span class="comment">// 先平移后旋转</span></span><br><span class="line">T.translate(translation);</span><br><span class="line">T.rotate(rotation);</span><br></pre></td></tr></table></figure><p>A.translate(B)等价于A×B，而A.pretranslate(B)等价于B×A，对应于左乘和右乘的区别。凡是前面带pre的函数，其变化都是相对于上一步变化之前的状态进行的。举例说我要新建一个按固定轴先平移后旋转的变换。但我首先设置了旋转，然后再设置平移。这个时候设置平移就不能用<code>translate()</code>了，而应该用<code>pretranslate()</code>。因为第一步已经对坐标系进行了旋转，后面的平移是在旋转后的坐标系中进行的，所以最好不要用pre开头的函数</p><h2 id="线性方程组的最小二乘解"><a href="#线性方程组的最小二乘解" class="headerlink" title="线性方程组的最小二乘解"></a>线性方程组的最小二乘解</h2><p>如果一个线性方程组是超定的(overdeterminated，未知数个数&gt;方程数)，这时候常规方法无解，就需要用最小二乘拟合最优结果。最精确的解法是SVD分解。SVD也有多种解法，官方推荐的是BDCSVD方法。</p><p>如下超定方程组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">	x+y=0\\</span><br><span class="line">	x+2y=4\\</span><br><span class="line">	x+3y=10</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$\frac&#123;\partial u&#125;&#123;\partial t&#125;</span><br><span class="line">= h^2 \left( \frac&#123;\partial^2 u&#125;&#123;\partial x^2&#125; +</span><br><span class="line">\frac&#123;\partial^2 u&#125;&#123;\partial y^2&#125; +</span><br><span class="line">\frac&#123;\partial^2 u&#125;&#123;\partial z^2&#125;\right)$$</span><br></pre></td></tr></table></figure><p>最小二乘求解代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXf <span class="title">A</span><span class="params">(<span class="number">3</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Vector3f b;</span><br><span class="line">Vector2f x;</span><br><span class="line">A &lt;&lt; <span class="number">1</span>,<span class="number">1</span>, <span class="number">1</span>,<span class="number">2</span>, <span class="number">1</span>,<span class="number">3</span> ;</span><br><span class="line">b &lt;&lt; <span class="number">0</span>,<span class="number">4</span>,<span class="number">10</span>;</span><br><span class="line">x = A.bdcSvd(ComputeThinU | ComputeThinV).solve(b);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Vector3f error = (A*x - b).cwiseAbs();</span><br><span class="line"><span class="keyword">double</span> mean_error = error.mean();</span><br></pre></td></tr></table></figure><p>程序运行需要一点时间，最后得到的x就是通过最小二乘算出来的。这里.bcdScd()函数里面的参数ComputeThinU | ComputeThinV必须要写(可以先记住)，否则会报错。</p><p>将得到的解带回方程会发现其并不是严格成立的，有时可能还会相差较大。这是因为对于超定方程，采用最小二乘法得出的解并不一定对每一个方程都严格成立，其确保的是当前解在所有方程上的总误差最小。得到解以后我们可以反算出其解的整体精度</p><h2 id="SVD分解"><a href="#SVD分解" class="headerlink" title="SVD分解"></a>SVD分解</h2><p><img src="https://i.loli.net/2020/03/03/ElH9B538daugNXo.png" alt><br><img src="https://i.loli.net/2020/03/03/ImOeKSksfDFlG87.png" alt></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix3f A;</span><br><span class="line">A &lt;&lt; <span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,</span><br><span class="line">     <span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,</span><br><span class="line">     <span class="number">8</span>,<span class="number">0</span>,<span class="number">1</span>;</span><br><span class="line"><span class="comment">// SVD分解</span></span><br><span class="line">Eigen::JacobiSVD&lt;Eigen::Matrix3f&gt; svd(A, Eigen::ComputeFullU | Eigen::ComputeFullV);</span><br><span class="line">Eigen::Matrix3f U = svd.matrixU();</span><br><span class="line">Eigen::Matrix3f V = svd.matrixV();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; U &lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; V.transpose() &lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 从对角线元素组成的向量</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; svd.singularValues() &lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// U和V都是正交矩阵（酉矩阵），和转置的乘积为单位矩阵</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; U.isUnitary() &lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; V.isUnitary() &lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"***********************"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 推荐方法，从对角线元素组成的向量直接构造对角矩阵</span></span><br><span class="line">Eigen::Matrix3f diag = svd.singularValues().asDiagonal();</span><br><span class="line"><span class="comment">// 从公式推导出的对角矩阵，有误差</span></span><br><span class="line">Eigen::Matrix3f S = U.inverse() * A * V.transpose().inverse();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; diag&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; S &lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大致等于原矩阵A</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; U *S *V.transpose()&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>参考：<br><a href="http://zhaoxuhui.top/blog/2019/09/03/eigen-note-4.html#5%E5%8F%98%E6%8D%A2" target="_blank" rel="noopener">Eigen学习与使用笔记</a><br><a href="http://zhaoxuhui.top/blog/2019/08/22/eigen-note-2.html#2%E8%AE%A1%E7%AE%97%E7%89%B9%E5%BE%81%E5%80%BC%E4%B8%8E%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F" target="_blank" rel="noopener">Eigen学习与使用笔记2</a><br><a href="https://eigen.tuxfamily.org/dox/classEigen_1_1AngleAxis.html" target="_blank" rel="noopener">Eigen官方文档-AngleAxis</a><br><a href="https://zhuanlan.zhihu.com/p/31386807" target="_blank" rel="noopener">矩阵的特征分解与奇异值分解</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/19/OpenCV/初识OpenCV/">初识OpenCV</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/OpenCV/">OpenCV</a></span><div class="content"><p>在计算机内存中，数字图像是已矩阵的形式保存的。OpenCV2中，数据结构Mat是保存图像像素信息的矩阵，它主要包含两部分：矩阵头和一个指向像素数据的矩阵指针。</p><p>矩阵头主要包含，矩阵尺寸、存储方法、存储地址和引用次数等。</p><p>矩阵头的大小是一个常数，不会随着图像的大小而改变，但是保存图像像素数据的矩阵则会随着图像的大小而改变，通常数据量会很大，比矩阵头大几个数量级。这样，在图像复制和传递过程中，主要的开销是由存放图像像素的矩阵而引起的。因此，OpenCV使用了引用次数，当进行图像复制和传递时，不再复制整个Mat数据，而只是复制矩阵头和指向像素矩阵的指针。这个<code>std::shared_ptr</code>很像：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat a ;<span class="comment">//创建矩阵头</span></span><br><span class="line">a = cv::imread(<span class="string">"xxx.jpg"</span>);<span class="comment">//读入图像</span></span><br><span class="line">cv::Mat b = a ;<span class="comment">//复制</span></span><br></pre></td></tr></table></figure><p>a，b有各自的矩阵头，但是其矩阵指针指向同一个矩阵，也就是其中任何一个改变了矩阵数据都会影响另外一个。那么，多个Mat共用一个矩阵数据，最后谁来释放矩阵数据呢？</p><p>　　这就是引用计数的作用，当Mat对象每被复制一次时，就会将引用计数加1，而每销毁一个Mat对象（共用同一个矩阵数据）时引用计数会被减1，当引用计数为0时，矩阵数据会被清理。</p><ul><li>OpenCV中的内存分配是自动完成的（不是特别指定的话）</li><li>使用OpenCV的C++ 接口时不需要考虑内存释放问题</li><li>Mat的赋值运算和拷贝构造函数只会拷贝矩阵头，仍然共同同一个矩阵</li><li>如果要复制矩阵数据，可以使用clone和copyTo函数</li></ul><h2 id="Mat的常见属性"><a href="#Mat的常见属性" class="headerlink" title="Mat的常见属性:"></a>Mat的常见属性:</h2><ul><li>data<br>　　uchar型的指针。Mat类分为了两个部分:矩阵头和指向矩阵数据部分的指针，data就是指向矩阵数据的指针。</li><li>dims<br>　　矩阵的维度，例如<code>5*6</code>矩阵是二维矩阵，则dims=2，三维矩阵dims=3.</li><li>rows<br>　　矩阵的行数</li><li>cols<br>　　矩阵的列数</li><li>size<br>　　矩阵的大小，size(cols,rows),如果矩阵的维数大于2，则是size(-1,-1)</li><li>channels<br>　　矩阵元素拥有的通道数，例如常见的彩色图像，每一个像素由RGB三部分组成，则channels = 3。</li><li>type()<br>　　表示了矩阵中元素的类型以及矩阵的通道个数，它是一系列的预定义的常量，其命名规则为<strong>CV_(位数)+（数据类型）+（通道数）</strong>。它是一系列的枚举值：<br><img src="https://i.loli.net/2020/02/20/CnKbH6dl8qGtvF7.png" alt="2020-02-19_221249.png"></li></ul><p>这里U（unsigned integer）表示的是无符号整数，S（signed integer）是有符号整数，F（float）是浮点数。</p><p>在opencv中，使用RNG产生随机数，<code>cv::RNG</code>是一个类，首先要产生一个对象rng, next可以取出下一个随机数，uniform函数可以返回指定范围的随机数，gaussian函数返回一个高斯随机数，fill则用随机数填充矩阵。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">cv::<span class="function">RNG <span class="title">rng</span><span class="params">( cv::getTickCount() )</span></span>;	   <span class="comment">//产生对象rng, 随时间每次产生的随机数都不同</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; rng.gaussian(<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>; 		  <span class="comment">// 产生均值为0，方差为1的高斯随机数</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; rng.uniform(<span class="number">0.f</span>, <span class="number">1.f</span>); 		 <span class="comment">// 产生U(0,1)的均值分布的随机数</span></span><br><span class="line"></span><br><span class="line">cv::<span class="function">Mat <span class="title">RandMap</span><span class="params">(row, col, CV_32FC3)</span></span>;	   <span class="comment">//创建矩阵，用来装随机数</span></span><br><span class="line"><span class="comment">//用fill命令把随机数装进去</span></span><br><span class="line"><span class="comment">//第一个参数：装随机数的矩阵; 第二个参数取cv::RNG::UNIFORM：均匀分布的随机数或者cv::RNG::GAUSSIAN高斯分布的随机数</span></span><br><span class="line"><span class="comment">// 第三个参数：产生的随机数的范围，上面的例子表示float型：0~1，不要int，否则最后的随机数都是0</span></span><br><span class="line">rng.fill(RandMap_R, cv::RNG::UNIFORM, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br></pre></td></tr></table></figure><p>参考：<br><a href="http://blog.afantree.com/machinelearning/the-introduction-of-opencv-mat-classes.html" target="_blank" rel="noopener">OpenCV中Mat类的介绍</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/15/视觉SLAM/KinectV1运行ORB_SLAM2/">KinectV1运行 ORB_SLAM2</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/视觉SLAM/">视觉SLAM</a></span><div class="content"><p>ORB_SLAM2是一个基于深度相机、Pose graph （图优化）的程序，后端用的是g2o。第一个版本仅仅是单目SLAM，第二个版本在原来的单目基础上增加了双目和RGBD的接口，尽管地图还是单目常见的稀疏特征点图，但是我们能通过各种传感器来玩ORB_SLAM2了</p><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>只要按照<a href="https://github.com/raulmur/ORB_SLAM2" target="_blank" rel="noopener">Github上的安装指导</a>进行就可以</p><p>需要先安装Eigen3和Pangolin，后者也按Github上的说明安装即可，不必安装Recommended Dependencies和Optional Dependencies，只要执行<code>Building</code>就行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/raulmur/ORB_SLAM2.git ORB_SLAM2</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ORB_SLAM2</span><br><span class="line">chmod +x build.sh</span><br><span class="line">./build.sh</span><br></pre></td></tr></table></figure><p>这会编译产生<code>libORB_SLAM2.so</code>到<code>lib</code>文件夹，以及<code>Examples/Monocular</code>文件夹中生成<code>mono_euroc</code>,<code>mono_tum</code>, <code>mono_kitti</code>; <code>RGB-D</code>文件夹中生成<code>rgbd_tum</code>; <code>Stereo</code>文件夹中生成<code>stereo_kitti</code>和<code>stereo_euroc</code></p><p>第一次编译忘了<code>build_ros.sh</code>，也就是少编译了几个核心文件，结果无法运行运行后又产生了问题</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>编译报错<code>ros_rgbd.cc.o: undefined reference to symbol &#39;_ZN5boost6system15system_categoryEv&#39;</code>，解决方法是在<code>/ORB_SLAM2/Examples/ROS/ORB_SLAM2/CMakeLists.txt</code>中添加boost_system库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set(LIBS</span><br><span class="line">	$&#123;OpenCV_LIBS&#125;</span><br><span class="line">	$&#123;EIGEN3_LIBS&#125;</span><br><span class="line">	$&#123;Pangolin_LIBRARIES&#125;</span><br><span class="line">	$&#123;PROJECT_SOURCE_DIR&#125;/../../../Thirdparty/DBoW2/lib/libDBoW2.so</span><br><span class="line">	$&#123;PROJECT_SOURCE_DIR&#125;/../../../Thirdparty/g2o/lib/libg2o.so</span><br><span class="line">	$&#123;PROJECT_SOURCE_DIR&#125;/../../../lib/libORB_SLAM2.so</span><br><span class="line">	-lboost_system</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="RGB-D例子"><a href="#RGB-D例子" class="headerlink" title="RGB-D例子"></a>RGB-D例子</h2><p>从<a href="http://vision.in.tum.de/data/datasets/rgbd-dataset/download" target="_blank" rel="noopener">序列下载</a>下载一个序列并解压。</p><p>使用<code>associate.py</code> associate RGB images and depth images. We already provide associations for some of the sequences in Examples/RGB-D/associations/. 你可以生成自己的associations文件:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python associate.py PATH_TO_SEQUENCE/rgb.txt PATH_TO_SEQUENCE/depth.txt &gt; associations.txt</span><br></pre></td></tr></table></figure><p>将<code>TUMX.yaml</code>换成TUM1.yaml,TUM2.yaml or TUM3.yaml for freiburg1, freiburg2 and freiburg3 sequences respectively. 填好<code>PATH_TO_SEQUENCE_FOLDER</code>和<code>ASSOCIATIONS_FILE</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Examples/RGB-D/rgbd_tum Vocabulary/ORBvoc.txt Examples/RGB-D/TUMX.yaml PATH_TO_SEQUENCE_FOLDER ASSOCIATIONS_FILE</span><br></pre></td></tr></table></figure><h2 id="运行自己的RGBD节点"><a href="#运行自己的RGBD节点" class="headerlink" title="运行自己的RGBD节点"></a>运行自己的RGBD节点</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun ORB_SLAM2 RGBD ORB_SLAM2/Vocabulary/ORBvoc.txt ~/path/kinect_calibration.yaml</span><br></pre></td></tr></table></figure><p><code>ORBvoc.txt</code>还是下载的那个，<code>kinect_calibration.yaml</code>就是我们自己的相机标定文件，这里有个问题，之前标定得到的yaml文件和这里要求的yaml文件格式不同，我们需要的可以参考<code>~/ORB_SLAM2-master/Examples/ROS/ORB_SLAM2/Asus.yaml</code>，只需要修改相机矩阵和畸变系数即可。</p><p>之前标定的yaml文件部分：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">camera_matrix:</span><br><span class="line">  rows: <span class="number">3</span></span><br><span class="line">  cols: <span class="number">3</span></span><br><span class="line">  data: [<span class="number">519.7959964940057</span>, <span class="number">0</span>, <span class="number">311.8351165024031</span>, <span class="number">0</span>, <span class="number">520.264653178918</span>, <span class="number">260.4976776521158</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">distortion_model: plumb_bob</span><br><span class="line">distortion_coefficients:</span><br><span class="line">  rows: <span class="number">1</span></span><br><span class="line">  cols: <span class="number">5</span></span><br><span class="line">  data: [<span class="number">0.1316145046090376</span>, <span class="number">-0.2008704147933575</span>, <span class="number">0.002009131405045224</span>, <span class="number">0.0002143881752906817</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>参数解释如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#内参数矩阵</span></span><br><span class="line">|        fx          0             cx     |</span><br><span class="line">|         0          fy            cy     |</span><br><span class="line">|         0          0             1      |</span><br><span class="line"></span><br><span class="line">fx : focal length <span class="keyword">in</span> direction of camera<span class="string">'s x axis </span></span><br><span class="line"><span class="string">fy : focal length in direction of camera'</span>s y axis </span><br><span class="line">cx,cy  : Principal point <span class="keyword">in</span> image</span><br><span class="line"></span><br><span class="line">distortion_coefficients (1x5):   <span class="comment">#畸变相关系数，是一个1x5的矩阵</span></span><br><span class="line">[k1    k2     p1     p2     k3]</span><br><span class="line"></span><br><span class="line">k1,k2,k3 : Radial distortion coefficients    <span class="comment"># 径向畸变</span></span><br><span class="line">p1, p2 : Tangential distortion coefficinets  <span class="comment"># 切向畸变</span></span><br><span class="line">k3 - <span class="built_in">set</span> to zero (only applicable <span class="keyword">for</span> fish-eyed lens)</span><br></pre></td></tr></table></figure><p>根据说明将需要的参数对<code>Asus.yaml</code>进行修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Camera calibration and distortion parameters (OpenCV) </span><br><span class="line">Camera.fx: 519.7959964940057</span><br><span class="line">Camera.fy: 520.264653178918</span><br><span class="line">Camera.cx: 311.8351165024031</span><br><span class="line">Camera.cy: 260.4976776521158</span><br><span class="line"></span><br><span class="line">Camera.k1: 0.1316145046090376</span><br><span class="line">Camera.k2: -0.2008704147933575</span><br><span class="line">Camera.p1: 0.002009131405045224</span><br><span class="line">Camera.p2: 0.0002143881752906817</span><br></pre></td></tr></table></figure><p>现在运行节点，终端一切正常，出现两个窗口<code>Current Frame</code>和<code>Map Viewer</code>，但是前者一片黑，后者没有内容。发现<code>Current Frame</code>状态是<code>Waiting for images</code>，节点需要的是话题<code>/camera/rgb/image_raw</code>和<code>/camera/depth_registered/image_raw</code>，使用<code>rostopic info</code>发现话题发布订阅都正常，但是<code>rostopic echo</code>后者却没有数据。</p><p>默认情况下，对于深度图，选择<code>/camera/depth/XXXX</code>的话题才会显示出来图像，因为没有设置<code>depth_registered</code>，如果在显示的过程中，在新的终端里使用<code>rosrun rqt_reconfiguration rqt_reconfiguration</code>，之后在<strong>camera-&gt;driver</strong>中勾选了<em>depth_registered</em>，此时rqt窗口就不会进行图像刷新了，此时切换至<code>/camera/depth_registered/XXXX</code>的话题后，继续会刷新图像。 <strong>但问题是好像重启freenect之后又要设置</strong><br><img src="https://i.loli.net/2020/02/19/wHf4Kgm2eQ7LBpl.png" alt="rqt_reconfigure"><br>再次启动节点，就能看到结果了。在<code>MapViewer</code>上，鼠标左键是移动，右键旋转，滚轮放大缩小。</p><h2 id="SLAM-和-Localization-模式"><a href="#SLAM-和-Localization-模式" class="headerlink" title="SLAM 和 Localization 模式"></a>SLAM 和 Localization 模式</h2><p>你可以使用<code>map viewer</code>在SLAM和Localization模式之间切换</p><p>SLAM Mode：默认模式，有三个线程: Tracking, Local Mapping 和 Loop Closing. 对相机定位，建立新地图并close loops</p><p>Localization Mode：如果当前区域一个比较好的地图，可以用这个模式。Local Mapping 和 Loop Closing 线程没有启动. 定位地图中的相机(which is no longer updated), 有必要的话会重定位</p></div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image:url(https://live.staticflickr.com/65535/48055510011_577ff62eaf_b.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>