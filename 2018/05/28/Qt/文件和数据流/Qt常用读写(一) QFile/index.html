<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Qt常用读写(一) QFile"><meta name="keywords" content><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>Qt常用读写(一) QFile | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG={root:"/",algolia:{appId:"RI90VLL69D",apiKey:"20c535e9a1424a7913210eb747d6e67b",indexName:"HexoBlog",hits:{per_page:10},languages:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}.",hits_stats:"${hits} results found in ${time} ms"}},localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本函数"><span class="toc-number">2.</span> <span class="toc-text">基本函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读写字符"><span class="toc-number">3.</span> <span class="toc-text">读写字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt读函数"><span class="toc-number">4.</span> <span class="toc-text">Qt读函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt写函数"><span class="toc-number">5.</span> <span class="toc-text">Qt写函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他常用函数"><span class="toc-number">6.</span> <span class="toc-text">其他常用函数</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">268</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">27</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://live.staticflickr.com/65535/48055510011_577ff62eaf_b.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Qt常用读写(一) QFile</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-05-28</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Qt/">Qt</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2018/05/28/Qt/文件和数据流/Qt常用读写(一) QFile/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2018/05/28/Qt/文件和数据流/Qt常用读写(一) QFile/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2.1k</span><span class="post-meta__separator">|</span><span>Reading time: 7 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>相关类的继承关系图<br><img src="https://lh3.googleusercontent.com/AHxBlJhZ8u72VY1YddlkNXQi-OxSoZMDW5alXklWNh3lK3ZR3JZc4naX5P_-TUlmNIaGJjIZSeqx77_3eqCvEyyaNs_ZJDF66FOdeWgCLhlDewWfZRcLeTg5aG1VL-PVhblchqk2mf17rxYCMzsGRttPBWYnhB6cGsPJcQIH5bazcD_tDcWL6UIipeAM-x4iEs82b5TPYACVubsBP8z3UFYrGSaUFmozYOi-bNexhX0rALa88y-QUz6jvalYL_dmgrQgl77JcKKIuB1DX8kLOqg2ygfaqt95UdAQWZQ5UiAEhWMU7EVZHy2mRXBArEEUyhC8tW4HVCcNSSCom3LIQGm1Ut8AFYUUatAHOcY5s96Iu1v2rQH70DEMbols7qSKbTf1QZqjQpRxyn_HVw8J0UtqEhyOLv1wWicojGZgx-mL6aeNhWuJGWM0HEZaEp231UiOEH1FRlP7IwfNucMS1DyTYzrITQ7IYA3B0N-zBcMtl7EQcTczsBEZAlCuD27U8yuHGzkztD-oG9geOd8TW2jFakjS6sGxj0HvmqOTnArorNoldE7iACYXXrPjPRK92fzT8KtinmboOVUNTmp1gw5o2eT4k_fM=w1346-h725-no" alt><br>虽然QFile自己有读写文件中字节、字节数组的函数，但是直接用 QFile 类的接口函数读写文件的情况是相对少见的，因为 QFile 的读写函数功能比较简单，就是面向字节数据进行读写。</p><p>QFile的基类<strong>QFileDevice</strong>是对文件设备的抽象，其实在 Unix 和 Linux 系统中所有东西都是文件设备，就连硬件设备也抽象成文件设备，一切皆文件嘛，QFileDevice 就是描述文件设备的类，QFileDevice 这一层基类的接口函数比较少，可以不用管。</p><p><strong>QSaveFile</strong>是保存文件类，就为了安全地保存文件而设计的，因为程序运行时可能有 bug 导致崩溃，如果崩溃时正在写入文件，那么文件被改写了一部分，但又没修改完全，会导致原始文件的损坏。QSaveFile 解决了文件的不安全读写，避免出现半吊子问题，QSaveFile 有两个重要函数：cancelWriting() 函数取消写入操作，commit() 提交所有写入操作</p><h2 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h2><p>QFile的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QFile();</span><br><span class="line">QFile(const QString &amp;name);  // fileName()返回文件名		</span><br><span class="line">QFile(QObject *parent);		// 配合setFileName()</span><br><span class="line">QFile(const QString &amp;name, QObject *parent);</span><br></pre></td></tr></table></figure><p>打开函数有3个，但基本只用1个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool open(OpenMode flags) Q_DECL_OVERRIDE;</span><br></pre></td></tr></table></figure><p>其中<code>OpenMode</code>枚举类型是在基类 QIODevice 定义的，有如下打开模式：<br><img src="https://lh3.googleusercontent.com/thvlCAwthFaQYoPbr-NDfX2XdFzfrwliQjB2SKIYjbbRyujnQ4XIXWs9-R9ZBahTGFwN9NC9fdlJkoA72UoOwb-OESBqEhu-kSH2cTTgGiCvjcG4yMqlTPXrCHxL_oeybsSCDxSKg6Br5leOegHTwcYPrvlSehNjCTO8cXPSc-9u7xSvlDRyQ0hCxHx2p3u5WN43AofsMgL-XHmjGNrwuG0W7VxWtVaRmmaW_fgbtdzzmdBJ5XXcXz7kk7totBvfU3HqbAf3HwYzJve01kAIQrhpw9P-AQuMmVLFDQWnmhDhpNQXaRtdTxGOwu7mSimvo60X9XgimlVvea1942GyxkcCqmb8mbZ8EU1aFWp3rCzQ3pTctnt2nJ7Z4M6WG6KJ8UxufoOD-lMCdOho0Pop9bE-U_3HtMNr85Ol-8nOkqvT9JWOCUeofFv-Ovn1boiLeun-Jy0MtAsHns-o8X-zo2wzKBWBAzaF0tZFPR_LxiYzBJZ7KuNiwQmV_R-hpkhMGeYsbO1gQr4RAMFGlYTc_B6ngtRrDU-3eihQEC5qGAFl4lXn-ZeCZvdCUtI7LaX-u2_G2ZoRSn4nfdk_MUpRl6lAi_MB-N5k=w1749-h498-no" alt><br>文件读取时，常见组合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file.open(QIODevice::ReadOnly);    //以只读方式打 开文件</span><br><span class="line">file.open(QIODevice::ReadOnly | QIODevice::Text);    //确定是读取文本文件，并且自动把换行符修改为 &apos;\n&apos;</span><br></pre></td></tr></table></figure><p><font color="red" size="3">注意以<code>QIODevice::Text</code>模式打开文件时，读写的数据不一定是原始数据 </font>，因为 QFile 自动把换行符做了转换，读取得到的缓冲区数据与原始文件是可能不一样的，比如 Windows 文本，换行符是 “\r\n” 两个字符，用 QIODevice::Text 读取时只会看到 ‘\n’ 一个字符；写入时就反过来，代码写入一个 ‘\n’，实际文件就是两个连续字符 “\r\n”，所以要注意 QIODevice::Text 模式读写的不一定是原始数据。</p><p>对于文件写入时，其常用打开模式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file.open(QIODevice::WriteOnly);    //以只写模式打开，会清空旧数据</span><br><span class="line">file.open(QIODevice::WriteOnly | QIODevice::Truncate);    //只写模式，清空旧数据</span><br><span class="line">file.open(QIODevice::WriteOnly | QIODevice::Append);     //只写和追加模式，不会清空旧数据</span><br></pre></td></tr></table></figure><p>如果文件打开时既要读，又要写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.open(QIODevice::ReadWrite);    //读写模式，旧数据不会清空，可以读出来</span><br></pre></td></tr></table></figure><h2 id="读写字符"><a href="#读写字符" class="headerlink" title="读写字符"></a>读写字符</h2><p>首先是简单的字节读写函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool QIODevice::​getChar(char * c)</span><br></pre></td></tr></table></figure><p>参数指针 c 就是读取的一个字节将要存到的变量指针，程序员需要自己先定义一个 char 变量，把这个变量地址传递给 ​getChar() 函数，如果读取一字节成功就返回 true；如果之前已经到了文件末尾，没有字节可以读了，就返回 false。</p><p>写入一个字节到文件中，应该使用函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool QIODevice::​putChar(char c)</span><br></pre></td></tr></table></figure><p>这个函数会把字节 c 写入文件，并将文件游标加一。</p><p>这里我们专门讲一下文件游标，文件在读写时，共同使用一个唯一的游标（QFile内部有），我们这里随便取个名字叫 pos（Position），这个 pos 在文件刚打开时一般处于文件开头位置0：<br><img src="https://lh3.googleusercontent.com/zRVU0Zv0l3xDr9sUs3AAehvwisldduhJ2V4WEmAn-UI6k4wJLXpEzE4A3yNnQI_MpwwSOgXWdT0Zv4zrQT0aJDyU17MFpdhqVKRQzRgflFtA1sPVnT3Quh4qWiDO35eiZSfxzIkgFobtteT1NNq6MyCma82rv5D1AOqPSOuxacjo9UxHe5CMP9FCTI28LcNUQrLusYpHsuy3jYUfVxnB17ShkgD3twOJL3YUrE7GUEMb3pweTUKfpCZlhAPK_-oT3l1NKj4OvjM6Oy7LcjTx_ith1zWO7H7dGMtajJ8uw_yBIywdkFse14Rn1P_Awk87lnBJc_MDK4m_QHYeswrqKWl1xPwo6l93Yf68owI_LiqIQd2Pww66UrWq8HxFzwDS3quDe-v6XJqcdjSMTDOhz_eSkc4WxocAW2qqDaAXH2BU3WLRRv4VwH05Ii3GzqXLxxB-GBr5Le8zracsaUDmelaiiF-pTc0GhogbulpyqMo2kUsL4kEhTy6vCZpAoXlcaTbQFcYt_PzW_cTybn2yl5vTo5pAkXiY3-xasSVWyhiAihRcIAnZyBal_T6-uetSskn3bus8bhoqB17D2PIQLP_hOIBKPa6H=w1092-h302-no" alt><br>对于函数 <code>​getChar()</code>和<code>putChar()</code>，每调用一次，文件游标就加 1，如果连续调用了 N 次，游标 pos 就会移动到位置N。<code>ungetChar()</code>函数如果操作正确，那么会使 pos 自动减一，这个游标都是 QFile 自动控制，一般不需要手动移动游标。读到文件末尾位置就无法再读数据了。</p><p>QFile 基类有快捷函数判断文件游标是否已到达文件末尾：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool QFileDevice::​atEnd() const</span><br></pre></td></tr></table></figure><h2 id="Qt读函数"><a href="#Qt读函数" class="headerlink" title="Qt读函数"></a>Qt读函数</h2><p>对于字节读取函数，文件游标是按一字节移动的，如果要读取大段数据块，那么可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qint64 QIODevice::​read(char * data, qint64 maxSize)</span><br></pre></td></tr></table></figure><p>data 通常是程序员手动分配的缓冲区，比如 <code>char *buff = new char[256];</code><br><code>maxSize</code>就是最多读取的字节数目，一般是手动分配的缓冲区大小，比如 256。<br>该函数返回值一般就是正确读取的字节数目，因为当前游标之后可能没有 256 字节，那么有几个字节读几个字节。如果 read() 函数在读取之前就到了文件末尾或者读取错误，那么返回值是 -1 。注意<code>OpenFlag</code>不要是只读的。</p><p>更常用的函数是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QByteArray QIODevice::​read(qint64 maxSize)</span><br></pre></td></tr></table></figure><p>这里的 read() 函数会把读取的字节数组存到 QByteArray 对象并返回，参数里的 maxSize 就是最多读取的字节数目。返回的 QByteArray 对象里面，可以用 QByteArray 自己的 <code>QByteArray::​size()</code> 函数判断读了多少字节，如果文件后面没字节可读或读取错误，那么 QByteArray 的size就是 0 。</p><p>其他常用函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QByteArray QIODevice::​readAll()</span><br><span class="line"></span><br><span class="line">qint64 QIODevice::​readLine(char * data, qint64 maxSize)</span><br><span class="line"></span><br><span class="line">QByteArray QIODevice::​readLine(qint64 maxSize = 0)</span><br></pre></td></tr></table></figure><p>第一个<code>readLine()</code>是程序员手动分配缓冲区，第二个不需要手动分配缓冲区。<br><code>readLine()</code>是从文件或设备里面读取一行 ASCII 字符，最多读取 maxSize-1 字节，因为最后一个字节预留给字符串结尾NULL字符。该函数返回值是真实读取的字节数目，如果读取出错或无数据可读就返回-1，它总会在实际读取的字符串末尾会自动添加一个字符串终结符 0 。</p><p>​readLine() 会一直读取数据直到如下三个条件之一满足：<br>① 第一个 ‘\n’ 字符读取到缓冲区。<br>② maxSize - 1 字节数已读取，最后一个字节预留给 0 。<br>③ 文件或设备读取已经到末尾。</p><h2 id="Qt写函数"><a href="#Qt写函数" class="headerlink" title="Qt写函数"></a>Qt写函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qint64 QIODevice::​write(const char * data, qint64 maxSize)</span><br></pre></td></tr></table></figure><p>data 就是缓冲区数据指针，maxSize 是最多写入的字节数。 返回值是真实写入的字节数，因为可能出现磁盘不够的情况。 如果返回值是 -1，那么可能是写入出错或者无写入权限。这个写函数不区分 data 缓冲区里面的 ‘\0’ 字符和普通字符串字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qint64 QIODevice::​write(const char * data)</span><br></pre></td></tr></table></figure><p>函数没指定缓冲区大小，会将参数里的data当作’\0’结尾的普通字符串，写入该字符串。这个函数等价于下面这句代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QIODevice::write(data, qstrlen(data));</span><br></pre></td></tr></table></figure><p>第三个写函数也很常用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qint64 QIODevice::​write(const QByteArray &amp; byteArray)</span><br></pre></td></tr></table></figure><p>byteArray 里面有多少字节就写入多少，这个也是不区分 ‘\0’ 字符和普通字符串字符。写操作函数也都会移动文件游标 pos，具体是看实际写入了多少字节。</p><h2 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h2><p>手动移游标pos，那么通过下面函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool QFileDevice::​seek(qint64 pos)</span><br></pre></td></tr></table></figure><p>​如果成功移动游标，那么会返回 true，否则返回 false。最好不要用 seek 函数移动游标到超出文件尺寸的位置，这样会导致无法预料 的结果。</p><p>如果希望设置文件尺寸，提前在磁盘上分配空间，可以用如下函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool QFile::​resize(qint64 sz)</span><br></pre></td></tr></table></figure><p>参数 sz 就是新的文件大小，如果新大小比旧的大，那么新增空间内容是随机的，需要程序员以后手动填充数据。重置大小成功就返回 true，否则返回 false。</p><p>文件打开和读写操作结束之后，就可以关闭文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void QFileDevice::​close()</span><br></pre></td></tr></table></figure><p>结束后，如果不关闭文件，文件大小是0，但是能正常打开；如果删除文件，会报警：文件被占用。</p><p>在写操作过程中，如果需要立即把 Qt 内部写缓冲区的数据写入磁盘，可以调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool QFileDevice::​flush()    //这个函数很少用到，文件 关闭时自动会执行 flush</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool QFile::​exists() 或 QFileInfo::exists	// 判断文件或同名文件夹是否存在 (最好不用)</span><br><span class="line">bool QFileInfo::isFile()	// 判断文件是否存在</span><br><span class="line">bool QFileInfo::isDir() 或 QDir::exists		// 判断文件夹是否存在</span><br><span class="line"></span><br><span class="line">bool QFile::​remove()	// 删除当前文件，删除之前文件会自动被关闭，然后删除</span><br><span class="line"></span><br><span class="line">bool QFile::​rename(const QString &amp; newName)//重命名为新名字newName，重命名之前，该文件会自动关闭</span><br><span class="line"></span><br><span class="line">Permissions QFile::​permissions() const	//获取文件权限的函数, 详见枚举值</span><br><span class="line"></span><br><span class="line">bool QFile::​setPermissions(Permissions permissions)	  // 设置文件权限的函数</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Charon Cheung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://charon-cheung.github.io/2018/05/28/Qt/文件和数据流/Qt常用读写(一) QFile/">https://charon-cheung.github.io/2018/05/28/Qt/文件和数据流/Qt常用读写(一) QFile/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/05/28/Qt/文件和数据流/Qt常用读写(三) QDataStream/"><i class="fa fa-chevron-left"></i><span>Qt常用读写(三) QDataStream</span></a></div><div class="next-post pull-right"><a href="/2018/05/28/Qt/文件和数据流/解析QDataStream操作QString/"><span>解析QDataStream操作QString</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused=null,disqus_config=function(){this.page.url="https://charon-cheung.github.io/2018/05/28/Qt/文件和数据流/Qt常用读写(一) QFile/",this.page.identifier="2018/05/28/Qt/文件和数据流/Qt常用读写(一) QFile/",this.page.title="Qt常用读写(一) QFile"},d=document,s=d.createElement("script");s.src="https://charon-cheung-github-io.disqus.com/embed.js",s.setAttribute("data-timestamp",""+ +new Date),(d.head||d.body).appendChild(s)</script><script id="dsq-count-scr" src="https://charon-cheung-github-io.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image:url(https://live.staticflickr.com/65535/48055510011_577ff62eaf_b.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>