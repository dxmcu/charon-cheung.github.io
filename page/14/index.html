<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG={root:"/",algolia:{appId:"RI90VLL69D",apiKey:"20c535e9a1424a7913210eb747d6e67b",indexName:"HexoBlog",hits:{per_page:10},languages:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}.",hits_stats:"${hits} results found in ${time} ms"}},localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">457</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">52</span></a></div></div></div><nav id="nav" style="background-image:url(https://i.loli.net/2020/07/13/QgyrefaLDxhBWSZ.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div><div id="site-social-icons"><a class="social-icon" href="https://github.com/charon-cheung"><i class="fa-github fa"></i></a><a class="social-icon search"><i class="fa fa-search"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/30/激光SLAM/卡尔曼滤波/robot_pose_ekf源码分析/">robot_pose_ekf源码分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/卡尔曼滤波/">卡尔曼滤波</a></span><div class="content"><p>robot_pose_ekf基本流程：</p><ol><li><p>从每个传感器获取数据</p></li><li><p>检查它们是否有效，如果它们有效，则将它们相对于参考基准坐标系进行转换</p></li><li><p>当获得传感器信息时，它将被存储，直到所有传感器的信息可用为止。收到的每个数据都有自己的时间戳</p></li><li><p>一旦所有数据都可用，则在所有传感器数据均可用时，针对每个可用传感器数据更新扩展卡尔曼滤波器（在Orocos-BFL库中定义）。即：如果来自里程计的数据在时间t_0（&gt; 0）可用，则来自imu的数据在时间t_1（&gt; t_0）处获得，而来自视觉里程计的数据在时间t_2（&gt; t_1）处获得，则在时间t_1对所有三组数据进行滤波。</p></li><li><p>该融合的传感器数据被转换为里程计消息，并在话题/odom_combined上发布</p></li></ol></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/30/Matlab/matlab实现高斯分布/">Matlab实现高斯分布</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Matlab/">Matlab</a></span><div class="content"><p>一般是两种方法</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=[<span class="number">-20</span>:<span class="number">0.01</span>:<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">%y2 = pdf('Normal',x,1,5)</span></span><br><span class="line">y = gaussmf(x,[<span class="number">1</span> <span class="number">5</span>]);</span><br><span class="line"><span class="built_in">plot</span>(x,y2)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/30/xs4JOZ2QHSg8Rdp.png" alt="运行结果"></p><p><img src="https://i.loli.net/2020/03/30/yBuZR26nLh8EFQT.png" alt><br>深蓝色区域是距平均值小于一个标准差之内的数值范围。在正态分布中，此范围所占比率为全部数值之68%，根据正态分布，两个标准差之内的比率合起来为95%；三个标准差之内的比率合起来为99%。</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/30/激光SLAM/amcl和粒子滤波/源码分析(四)运动模型/">源码分析(四)运动模型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/amcl和粒子滤波/">amcl和粒子滤波</a></span><div class="content"><p>在AMCL中，里程计是作为状态预测器存在的，通过接受当前的控制信号，从<strong>上一帧机器人状态对这一帧机器人状态进行预测，并与当前观测的结果对当前预测进行加权打分</strong>。所以通过输入和输出我们知道，里程计在AMCL中的作用就是根据当前控制信号更新上一帧的能表征机器人状态的粒子集合。</p><p>给机器人一个初始位姿，粒子才根据初始位姿进行初始化分布，才会进行更新(<code>UpdateAction函数</code>)，否则不会有<code>amcl_pose</code>话题输出，而更新依赖于读取到传感器数据发生变化，如在amcl中里程计的数据变化等，也就是机器人的运动</p><h2 id="工具函数和类"><a href="#工具函数和类" class="headerlink" title="工具函数和类"></a>工具函数和类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 两个处理角度的函数，保证角度都在(-π，π] 的范围内 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如 30°的弧度,代入后基本还是得30°的弧度</span></span><br><span class="line"><span class="comment">// 但是对于210°, 代入得到的是-150°的弧度值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">normalize</span><span class="params">(<span class="keyword">double</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">atan2</span>(<span class="built_in">sin</span>(z),<span class="built_in">cos</span>(z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于240和30的弧度,返回-150的弧度</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">angle_diff</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> d1, d2;</span><br><span class="line">  a = normalize(a);</span><br><span class="line">  b = normalize(b);</span><br><span class="line">  d1 = a-b;</span><br><span class="line">  d2 = <span class="number">2</span>*M_PI - <span class="built_in">fabs</span>(d1);</span><br><span class="line">  <span class="keyword">if</span>(d1 &gt; <span class="number">0</span>)</span><br><span class="line">    d2 *= <span class="number">-1.0</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">fabs</span>(d1) &lt; <span class="built_in">fabs</span>(d2))</span><br><span class="line">    <span class="keyword">return</span>(d1);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span>(d2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向量，成员为[x,y,θ]</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">double</span> v[<span class="number">3</span>];</span><br><span class="line">&#125; <span class="keyword">pf_vector_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Odometric sensor data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AMCLOdomData</span> :</span> <span class="keyword">public</span> AMCLSensorData</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Odometric pose</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">pf_vector_t</span> pose;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Change in odometric pose</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">pf_vector_t</span> delta;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个粒子的采样信息，只有位姿和权重</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// Pose represented by this sample</span></span><br><span class="line">  <span class="keyword">pf_vector_t</span> pose;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Weight for this pose</span></span><br><span class="line">  <span class="keyword">double</span> weight;</span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">pf_sample_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从零均值的高斯分布获得随机值，标准差为sigma</span></span><br><span class="line"><span class="comment">// We use the polar form of the Box-Muller transformation</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pf_ran_gaussian</span><span class="params">(<span class="keyword">double</span> sigma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> x1, x2, w, r;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123; r = drand48(); &#125; <span class="keyword">while</span> (r==<span class="number">0.0</span>);</span><br><span class="line">    x1 = <span class="number">2.0</span> * r - <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123; r = drand48(); &#125; <span class="keyword">while</span> (r==<span class="number">0.0</span>);</span><br><span class="line">    x2 = <span class="number">2.0</span> * r - <span class="number">1.0</span>;</span><br><span class="line">    w = x1*x1 + x2*x2;</span><br><span class="line">  &#125; <span class="keyword">while</span>(w &gt; <span class="number">1.0</span> || w==<span class="number">0.0</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span>(sigma * x2 * <span class="built_in">sqrt</span>(<span class="number">-2.0</span>*<span class="built_in">log</span>(w)/w));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="laserReceived中的准备工作"><a href="#laserReceived中的准备工作" class="headerlink" title="laserReceived中的准备工作"></a>laserReceived中的准备工作</h2><p>下面来看回调函数<code>laserReceived</code>中的运动模型准备工作，我们需要的是<code>odata</code>，它的类型就是上面的<code>AMCLOdomData</code>，以delta成员为例，它的赋值顺序是： odata.delta &lt;— delta &lt;— pose(当前位姿)和pf_odom_pose_(上一次位姿)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得雷达数据时刻的odom坐标系中的坐标,赋值给pose</span></span><br><span class="line"><span class="keyword">pf_vector_t</span> pose;</span><br><span class="line"><span class="keyword">if</span>(!getOdomPose(latest_odom_pose_, pose.v[<span class="number">0</span>], pose.v[<span class="number">1</span>], pose.v[<span class="number">2</span>],</span><br><span class="line">              laser_scan-&gt;header.stamp, base_frame_id_))</span><br><span class="line">&#123;</span><br><span class="line">    ROS_ERROR(<span class="string">"Couldn't determine robot's pose associated with laser scan"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pf_vector_t</span> delta = pf_vector_zero();</span><br><span class="line"><span class="comment">// 完成初始化后执行</span></span><br><span class="line"><span class="keyword">if</span>(pf_init_)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 位姿相对上一次的变化， pf_odom_pose_就是上一时刻的位姿</span></span><br><span class="line">delta.v[<span class="number">0</span>] = pose.v[<span class="number">0</span>] - pf_odom_pose_.v[<span class="number">0</span>];</span><br><span class="line">delta.v[<span class="number">1</span>] = pose.v[<span class="number">1</span>] - pf_odom_pose_.v[<span class="number">1</span>];</span><br><span class="line">delta.v[<span class="number">2</span>] = angle_diff(pose.v[<span class="number">2</span>], pf_odom_pose_.v[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否更新粒子滤波器，位移需要大于参数update_min_d， 角度需要大于参数update_min_a</span></span><br><span class="line"><span class="keyword">bool</span> update = <span class="built_in">fabs</span>(delta.v[<span class="number">0</span>]) &gt; d_thresh_ ||</span><br><span class="line">              <span class="built_in">fabs</span>(delta.v[<span class="number">1</span>]) &gt; d_thresh_ ||</span><br><span class="line">              <span class="built_in">fabs</span>(delta.v[<span class="number">2</span>]) &gt; a_thresh_;</span><br><span class="line">update = update || m_force_update;</span><br><span class="line">m_force_update=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the laser update flags</span></span><br><span class="line"><span class="keyword">if</span>(update)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; lasers_update_.size(); i++)</span><br><span class="line">    lasers_update_[i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> force_publication = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 第一次执行laserReceived时执行, 之前的handleMapMessage里还是false</span></span><br><span class="line"><span class="comment">// 如果里程计的数据显示机器人已经发生了明显的位移或者旋转，标记所有的雷达更新为true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 难道这里只在开始运行一次 ???</span></span><br><span class="line"><span class="keyword">if</span>(!pf_init_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 上一次滤波器更新的位姿 </span></span><br><span class="line">    pf_odom_pose_ = pose;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 滤波器现在初始化了</span></span><br><span class="line">    pf_init_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Should update sensor data</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; lasers_update_.size(); i++)</span><br><span class="line">      lasers_update_[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    force_publication = <span class="literal">true</span>;</span><br><span class="line">    resample_count_ = <span class="number">0</span>; 	<span class="comment">// 重采样次数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 刚启动amcl时不执行,机器人移动后执行, 更新滤波器</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pf_init_ &amp;&amp; lasers_update_[laser_index])</span><br><span class="line">&#123;</span><br><span class="line">    AMCLOdomData odata;</span><br><span class="line">    odata.pose = pose;</span><br><span class="line">    odata.delta = delta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一帧位姿粒子状态pf和当前传感器信息，更新滤波器</span></span><br><span class="line">    odom_-&gt;UpdateAction(pf_, (AMCLSensorData*)&amp;odata);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> resampled = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>到此就是算法的准备工作了, <code>pf_</code>是粒子滤波器，在<code>handleMapMessage</code>中创建和初始化</p><h2 id="UpdateAction"><a href="#UpdateAction" class="headerlink" title="UpdateAction"></a>UpdateAction</h2><p>接下来就是运动模型的算法了，对应《概率机器人》103页：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply the action model</span></span><br><span class="line"><span class="keyword">bool</span> AMCLOdom::UpdateAction(<span class="keyword">pf_t</span> *pf, AMCLSensorData *data)</span><br><span class="line">&#123;</span><br><span class="line">  AMCLOdomData *ndata;</span><br><span class="line">  ndata = (AMCLOdomData*) data;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the new sample poses</span></span><br><span class="line">  <span class="keyword">pf_sample_set_t</span> *<span class="built_in">set</span>;</span><br><span class="line">  <span class="comment">// 确立当前的粒子集合，我们要产生的是一堆有位姿的粒子</span></span><br><span class="line">  <span class="built_in">set</span> = pf-&gt;sets + pf-&gt;current_set;</span><br><span class="line">  <span class="comment">// 上一时刻的位姿</span></span><br><span class="line">  <span class="keyword">pf_vector_t</span> old_pose = pf_vector_sub(ndata-&gt;pose, ndata-&gt;delta);</span><br><span class="line">  <span class="comment">// 与103页的各个delta量对应</span></span><br><span class="line">    <span class="keyword">double</span> delta_rot1, delta_trans, delta_rot2;</span><br><span class="line">    <span class="keyword">double</span> delta_rot1_hat, delta_trans_hat, delta_rot2_hat;</span><br><span class="line">    <span class="keyword">double</span> delta_rot1_noise, delta_rot2_noise;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相较于于书上，在计算delta _rot1时，多了个判定条件以位移是否小于1cm作为判断条件</span></span><br><span class="line">    <span class="comment">// 如果里程计量得机器人位移小于1cm，delta _rot1就置为0</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sqrt</span>(ndata-&gt;delta.v[<span class="number">1</span>]*ndata-&gt;delta.v[<span class="number">1</span>] + </span><br><span class="line">            ndata-&gt;delta.v[<span class="number">0</span>]*ndata-&gt;delta.v[<span class="number">0</span>]) &lt; <span class="number">0.01</span>)</span><br><span class="line">      delta_rot1 = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      delta_rot1 = angle_diff(<span class="built_in">atan2</span>(ndata-&gt;delta.v[<span class="number">1</span>], ndata-&gt;delta.v[<span class="number">0</span>]),</span><br><span class="line">                              old_pose.v[<span class="number">2</span>]);</span><br><span class="line">    delta_trans = <span class="built_in">sqrt</span>(ndata-&gt;delta.v[<span class="number">0</span>]*ndata-&gt;delta.v[<span class="number">0</span>] +</span><br><span class="line">                       ndata-&gt;delta.v[<span class="number">1</span>]*ndata-&gt;delta.v[<span class="number">1</span>] );</span><br><span class="line">    delta_rot2 = angle_diff(ndata-&gt;delta.v[<span class="number">2</span>], delta_rot1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We want to treat backward and forward motion symmetrically for the</span></span><br><span class="line">    <span class="comment">// noise model to be applied below.  The standard model seems to assume forward motion.</span></span><br><span class="line">    <span class="comment">// 取了两次旋转角的锐角</span></span><br><span class="line">    delta_rot1_noise = <span class="built_in">std</span>::min(<span class="built_in">fabs</span>(angle_diff(delta_rot1,<span class="number">0.0</span>)),</span><br><span class="line">                                <span class="built_in">fabs</span>(angle_diff(delta_rot1,M_PI)));</span><br><span class="line">    delta_rot2_noise = <span class="built_in">std</span>::min(<span class="built_in">fabs</span>(angle_diff(delta_rot2,<span class="number">0.0</span>)),</span><br><span class="line">                                <span class="built_in">fabs</span>(angle_diff(delta_rot2,M_PI)));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用一定数量的粒子来表征这个区域，然后对这些粒子进行采样来尽可能多的逼近机器人的真实值</span></span><br><span class="line">	<span class="comment">// 下面还是书上的公式，我们需要的是sample</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">set</span>-&gt;sample_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 指针形式, 会给set的samples都赋值</span></span><br><span class="line">      <span class="keyword">pf_sample_t</span>* sample = <span class="built_in">set</span>-&gt;samples + i;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Sample pose differences，pf_ran_gaussian函数：从零平均高斯分布中随机抽取，带有标准差sigma</span></span><br><span class="line">      <span class="comment">// 将这两个角度带入pf_ran_gaussian()进行高斯采样，也就是书103页的sample()函数。</span></span><br><span class="line">      <span class="comment">// 对每个粒子，不同的信息就是高斯采样产生的，其他部分不变</span></span><br><span class="line">      delta_rot1_hat = angle_diff(delta_rot1,</span><br><span class="line">                      pf_ran_gaussian(<span class="keyword">this</span>-&gt;alpha1*delta_rot1_noise*delta_rot1_noise + <span class="keyword">this</span>-&gt;alpha2*delta_trans*delta_trans)  );</span><br><span class="line"></span><br><span class="line">      delta_trans_hat = delta_trans - </span><br><span class="line">              pf_ran_gaussian(<span class="keyword">this</span>-&gt;alpha3*delta_trans*delta_trans +</span><br><span class="line">                              <span class="keyword">this</span>-&gt;alpha4*delta_rot1_noise*delta_rot1_noise +</span><br><span class="line">                              <span class="keyword">this</span>-&gt;alpha4*delta_rot2_noise*delta_rot2_noise);</span><br><span class="line"></span><br><span class="line">      delta_rot2_hat = angle_diff(delta_rot2,</span><br><span class="line">                          pf_ran_gaussian(<span class="keyword">this</span>-&gt;alpha1*delta_rot2_noise*delta_rot2_noise +</span><br><span class="line">                        <span class="keyword">this</span>-&gt;alpha2*delta_trans*delta_trans) );</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Apply sampled update to particle pose, 对初始预测的修正</span></span><br><span class="line">      sample-&gt;pose.v[<span class="number">0</span>] += delta_trans_hat * </span><br><span class="line">              <span class="built_in">cos</span>(sample-&gt;pose.v[<span class="number">2</span>] + delta_rot1_hat);</span><br><span class="line">      sample-&gt;pose.v[<span class="number">1</span>] += delta_trans_hat * </span><br><span class="line">              <span class="built_in">sin</span>(sample-&gt;pose.v[<span class="number">2</span>] + delta_rot1_hat);</span><br><span class="line">      sample-&gt;pose.v[<span class="number">2</span>] += delta_rot1_hat + delta_rot2_hat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/26/ROS/机器人导航/使用robot_localization实现数据融合/">使用robot_localization实现数据融合</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS机器人/">ROS机器人</a></span><div class="content"><p><code>robot_localization</code>是一系列状态估计的节点，每个是一种非线性的状态估计，用于3D空间的机器人。包含<code>ekf_localization_node</code>和<code>ukf_localization_node</code>两个节点。 另外<code>navsat_transform_node</code>用于融合GPS数据。</p><p>所有节点共享如下特性:</p><ul><li><p>节点不限制输入数据的个数，比如多个IMU或多个里程计</p></li><li><p>支持多种ROS消息，例如<code>nav_msgs/Odometry</code>, <code>sensor_msgs/Imu</code>, <code>geometry_msgs/PoseWithCovarianceStamped</code>, <code>geometry_msgs/TwistWithCovarianceStamped</code></p></li><li><p>节点可以在处理输入的传感器数据之前，排除不想要的数据部分</p></li><li><p>持续估计，包中的每个状态估计节点从机器人收到第一次测量开始，就估计它的状态。如果传感器有一段时间收不到数据，filter会通过内部的运动模型持续估计机器人的状态</p></li></ul><p>所有状态估计节点 track 15维的机器人状态：<br><img src="https://i.loli.net/2020/03/26/ht9sqPdI6x45OSR.png" alt="15维的状态量"></p><h2 id="ekf-localization-node"><a href="#ekf-localization-node" class="headerlink" title="ekf_localization_node"></a>ekf_localization_node</h2><p>扩展卡尔曼滤波的实现。 它使用全向的机器人模型预测状态，并且使用感知的传感器数据修正已预测的状态估计</p><h2 id="ukf-localization-node"><a href="#ukf-localization-node" class="headerlink" title="ukf_localization_node"></a>ukf_localization_node</h2><p>ukf_localization_node is an implementation of an unscented Kalman filter. It uses a set of carefully selected sigma points to project the state through the same motion model that is used in the EKF, and then uses those projected sigma points to recover the state estimate and covariance. This eliminates the use of Jacobian matrices and makes the filter more stable. However, it is also more computationally taxing than ekf_localization_node.</p><p>两个节点所用的大部分参数都相同，参数控制着数据在被filter融合前是如何处理的。</p><p>机器人在odom坐标系的位置会随时间而漂移，但在短期是准确而且持续的；map坐标系是一个世界范围的固定坐标系，机器人在这个坐标系中是全局准确的，会有跳变。</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/25/激光SLAM/卡尔曼滤波/使用robot_pose_ekf实现数据融合/">使用robot_pose_ekf实现传感器融合</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/卡尔曼滤波/">卡尔曼滤波</a></span><div class="content"><p>Each source gives a pose estimate and a covariance. The sources operate at different rates and with different latencies. A source can appear and disappear over time, and the node will automatically detect and use the available sensors.To add your own sensor inputs,</p><p>给滤波器节点提供信息的所有传感器源都有自己的参考坐标系，并且随着时间推移都可能出现漂移现象。因此，每个传感器发出来的绝对位姿不能直接对比。</p><p><code>robot_pose_ekf</code>使用每个传感器的相对位姿差异来更新扩展卡尔曼滤波器，用松耦合方式融合不同传感器信息实现位姿估计。</p><p>在位姿本身上发布协方差是没有用的，而是传感器源发布协方差如何随时间变化，即速度的协方差。使用对世界的观测（例如，测量到已知墙壁的距离）将减少机器人位姿的不确定性；但是这是定位而不是里程计。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>校正好IMU,因为融合后的效果就是要看imu的校准度</p><p>注释掉StatusPublisher.cpp中的<code>sendTransform(tf::StampedTransform(transform, current_time.fromSec(base_time_), &quot;odom&quot;, &quot;base_footprint&quot;));</code> 因为ekf包会为我们处理好这部分tf，所以不需要我们发布odom变换了</p><h2 id="修改-xiaoqiang-pose-ekf-launch"><a href="#修改-xiaoqiang-pose-ekf-launch" class="headerlink" title="修改 xiaoqiang_pose_ekf.launch"></a>修改 xiaoqiang_pose_ekf.launch</h2><p>以小强自带的launch文件为基础进行修改</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"robot_pose_ekf"</span> <span class="attr">type</span>=<span class="string">"robot_pose_ekf"</span> <span class="attr">name</span>=<span class="string">"robot_pose_ekf"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"output_frame"</span> <span class="attr">value</span>=<span class="string">"odom_combined"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"base_footprint_frame"</span> <span class="attr">value</span>=<span class="string">"base_footprint"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"freq"</span> <span class="attr">value</span>=<span class="string">"30.0"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"sensor_timeout"</span> <span class="attr">value</span>=<span class="string">"1.0"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"odom_used"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"imu_used"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"vo_used"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"debug"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"self_diagnose"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>freq: the update and publishing frequency of the filter. Note that a higher frequency will give you more robot poses over time, but it will not increase the accuracy of each estimated robot pose.</p></li><li><p>sensor_timeout: when a sensor stops sending information to the filter, how long should the filter wait before moving on without that sensor.</p></li><li><p>odom_used, imu_used, vo_used: enable or disable inputs.</p></li></ul><p><code>robot_pose_ekf</code>默认监听topic: <code>imu_data</code>、<code>odom</code>和<code>vo</code>. 发布<code>robot_pose_ekf/odom_combined</code>，也是机器人位姿的估计值，带协方差矩阵的位姿。所以我们需要remap到实际的话题:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"odom"</span> <span class="attr">to</span>=<span class="string">"/xqserial_server/Odom"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"vo"</span> <span class="attr">to</span>=<span class="string">"/ORB_SLAM/Odom"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"imu_data"</span> <span class="attr">to</span>=<span class="string">"xqserial_server/IMU"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>启动之后,发布一下tf树,看看各坐标系名称是否正确,而且<code>odom_combined</code>是不是<code>robot_pose_ekf</code>发布的，它提供的tf变换是： odom_combined –&gt; base_footprint</p><p>我们最终要实现的目标TF关系是： <code>map --&gt; odom_combined --&gt; base_footprint --&gt; base_link</code></p><p>启动launch: <code>roslaunch robot_pose_ekf xiaoqiang_pose_ekf.launch</code></p><p><img src="https://i.loli.net/2020/03/25/RbpSnG9Ce8lLhOw.png" alt="发布订阅关系1"><br><img src="https://i.loli.net/2020/03/25/nM2Hb7NF9JfedWQ.png" alt="发布订阅关系2"></p><p>为了查看ekf包是否正常工作，可以用下面代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /robot_pose_efk/get_status</span><br></pre></td></tr></table></figure><h2 id="协方差问题"><a href="#协方差问题" class="headerlink" title="协方差问题"></a>协方差问题</h2><p>里程计消息的协方差平时可以没有,但是如果要用到卡尔曼滤波做融合,就必须有,否则会报错:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] [1519539033.600801081]: Covariance specified <span class="keyword">for</span> measurement on topic wheelodom is zero</span><br></pre></td></tr></table></figure><p>这里的协方差矩阵就是&lt;&lt;概率机器人&gt;&gt;154页的<code>Vt*Mt*VtT</code>, 根据之前速度积分的模型,我们已知的是ωt,Δt,θ</p><p>只有a1~a4还未知,它们的说明在《概率机器人》103页,这里就涉及到粒子滤波和AMCL了,其实它们就是AMCL的四个参数,即里程计的四个噪声分量. 我们在使用AMCL定位前就要调节这四个参数, 有了这四个参数,就能算出里程计的协方差矩阵了.</p><p><code>robot_pose_ekf</code>不输出协方差信息，但要求输入协方差，协方差是<font size="3" color="blue">on velocity level</font></p><p>随着机器人的移动，其位姿的不确定性越来越大。随着时间的流逝，协方差将无限增长。<code>robot_pose_ekf</code>会在每个传感器更新数据前重置协方差， 所以发布的协方差是the increase in covariance over the past time interval. 这个时间间隔不是不变的，它取决于传感器的测量速度和什么时候完成．</p><p>在使用robot_pose_ekf时，常遇到接收到的odometry数据格式错误的问题。一个可能的原因为底盘或其他设备发布odometry数据的协方差矩阵默认为0矩阵。解决的方法由两种：一种为在底盘将信息封装发布前对协方差矩阵进行初始化；另一种方法为在robot_pose_ekf中添加判断，如果接收到的odometry信息的协方差矩阵没有进行初始化，则进行初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// manually set covariance untile imu sends covariance</span></span><br><span class="line"><span class="keyword">if</span> (imu_covariance_(<span class="number">1</span>,<span class="number">1</span>) == <span class="number">0.0</span>)&#123;</span><br><span class="line">  <span class="function">SymmetricMatrix <span class="title">measNoiseImu_Cov</span><span class="params">(<span class="number">3</span>)</span></span>;  measNoiseImu_Cov = <span class="number">0</span>;</span><br><span class="line">  measNoiseImu_Cov(<span class="number">1</span>,<span class="number">1</span>) = <span class="built_in">pow</span>(<span class="number">0.00017</span>,<span class="number">2</span>);  <span class="comment">// = 0.01 degrees / sec</span></span><br><span class="line">  measNoiseImu_Cov(<span class="number">2</span>,<span class="number">2</span>) = <span class="built_in">pow</span>(<span class="number">0.00017</span>,<span class="number">2</span>);  <span class="comment">// = 0.01 degrees / sec</span></span><br><span class="line">  measNoiseImu_Cov(<span class="number">3</span>,<span class="number">3</span>) = <span class="built_in">pow</span>(<span class="number">0.00017</span>,<span class="number">2</span>);  <span class="comment">// = 0.01 degrees / sec</span></span><br><span class="line">  imu_covariance_ = measNoiseImu_Cov;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>轮式里程计严重依赖控制系统，比如编码器，电机，轮子，控制器，驱动器等等．</p><p>try adjusting the process noise vs. the measurement covariance for the state variables you’re fusing. Lower covariance in the measurement and higher process noise will mean that the filter trusts your sensors more. Otherwise, the filter will prefer to stick with its predictions</p><p><a href="https://blog.csdn.net/EAIBOT/article/details/51405152" target="_blank" rel="noopener">turtlebot所用的里程计和IMU协方差是手动设置的</a></p><p>修改<code>robot_pose_ekf/src/odom_estimation_node.cpp</code>中的函数<code>OdomEstimationNode::odomCallback</code>如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">6</span>; j++)</span><br><span class="line">    odom_covariance_(i+<span class="number">1</span>, j+<span class="number">1</span>) = odom-&gt;pose.covariance[<span class="number">6</span>*i+j];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (odom_covariance_(<span class="number">1</span>,<span class="number">1</span>) == <span class="number">0.0</span>)&#123;</span><br><span class="line">  <span class="function">SymmetricMatrix <span class="title">measNoiseOdom_Cov</span><span class="params">(<span class="number">6</span>)</span></span>;  measNoiseOdom_Cov = <span class="number">0</span>;</span><br><span class="line">  measNoiseOdom_Cov(<span class="number">1</span>,<span class="number">1</span>) = <span class="built_in">pow</span>(<span class="number">0.01221</span>,<span class="number">2</span>);  <span class="comment">// = 0.01221 meters / sec</span></span><br><span class="line">  measNoiseOdom_Cov(<span class="number">2</span>,<span class="number">2</span>) = <span class="built_in">pow</span>(<span class="number">0.01221</span>,<span class="number">2</span>);  <span class="comment">// = 0.01221 meters / sec</span></span><br><span class="line">  measNoiseOdom_Cov(<span class="number">3</span>,<span class="number">3</span>) = <span class="built_in">pow</span>(<span class="number">0.01221</span>,<span class="number">2</span>);  <span class="comment">// = 0.01221 meters / sec</span></span><br><span class="line">  measNoiseOdom_Cov(<span class="number">4</span>,<span class="number">4</span>) = <span class="built_in">pow</span>(<span class="number">0.007175</span>,<span class="number">2</span>);  <span class="comment">// = 0.41 degrees / sec</span></span><br><span class="line">  measNoiseOdom_Cov(<span class="number">5</span>,<span class="number">5</span>) = <span class="built_in">pow</span>(<span class="number">0.007175</span>,<span class="number">2</span>);  <span class="comment">// = 0.41 degrees / sec</span></span><br><span class="line">  measNoiseOdom_Cov(<span class="number">6</span>,<span class="number">6</span>) = <span class="built_in">pow</span>(<span class="number">0.007175</span>,<span class="number">2</span>);  <span class="comment">// = 0.41 degrees / sec</span></span><br><span class="line">  odom_covariance_ = measNoiseOdom_Cov;</span><br><span class="line">&#125;</span><br><span class="line">my_filter_.addMeasurement(StampedTransform(odom_meas_.inverse(), odom_stamp_, base_footprint_frame_, <span class="string">"wheelodom"</span>), odom_covariance_);</span><br></pre></td></tr></table></figure><p>这是仿照源码中的函数<code>imuCallback</code>做的修改</p><p>如果协方差太大，那么说明机器人不太依靠里程计．协方差矩阵具体值可以考虑设置为精度的二次方。工程中确保odom的协方差矩阵对角线元素不均为0，则robot_pose_ekf即可工作。</p><h2 id="源码的坐标系错误"><a href="#源码的坐标系错误" class="headerlink" title="源码的坐标系错误"></a>源码的坐标系错误</h2><p>使用rviz观看滤波后的行走轨迹，结果报错：<br><img src="https://i.loli.net/2020/05/23/BAwtu9NfZ3sQW4I.png" alt="rviz里的ekf_dom_path报错.png"><br>它居然要求的是odom坐标系，但是查看tf树，坐标关系是正确的<code>odom_combined --&gt; base_footprint</code>，没有odom了。</p><p>使用echo查看/robot_pose_ekf/odom_combined话题，发现header里的frame_id: “odom”，看来是哪个地方发布错了。 从robot_pose_ekf源码里查找，发现<code>OdomEstimation::getEstimate(geometry_msgs::PoseWithCovarianceStamped&amp; estimate)</code>中，有这样一句<code>estimate.header.frame_id = &quot;odom&quot;;</code>，按说新的坐标系是<code>odom_combined</code>，不知为什么这里还是<code>odom</code>，只能认为是源码写错了。</p><h2 id="转换odom-combined的格式"><a href="#转换odom-combined的格式" class="headerlink" title="转换odom_combined的格式"></a>转换odom_combined的格式</h2><p>原来的<code>odom</code>话题的格式为<code>nav_msgs/Odometry</code>. robot_pose_ekf发布的默认话题<code>robot_pose_ekf/odom_combined</code>，消息格式为<code>geometry_msgs/PoseWithCovarianceStamped</code>, 需要进行消息格式转换：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> geometry_msgs.msg <span class="keyword">import</span> PoseWithCovarianceStamped</span><br><span class="line"><span class="keyword">from</span> nav_msgs.msg <span class="keyword">import</span> Odometry</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OdomEKF</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">       <span class="comment"># Give the node a name</span></span><br><span class="line">       rospy.init_node(<span class="string">'odom_ekf'</span>, anonymous=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># Publisher of type nav_msgs/Odometry</span></span><br><span class="line">       self.ekf_pub = rospy.Publisher(<span class="string">'output'</span>, Odometry, queue_size=<span class="number">10</span>)</span><br><span class="line">       </span><br><span class="line">       <span class="comment"># Wait for the /odom_combined topic to become available</span></span><br><span class="line">       rospy.wait_for_message(<span class="string">'input'</span>, PoseWithCovarianceStamped)</span><br><span class="line">       </span><br><span class="line">       <span class="comment"># Subscribe to the /odom_combined topic</span></span><br><span class="line">       rospy.Subscriber(<span class="string">'input'</span>, PoseWithCovarianceStamped, self.pub_ekf_odom)</span><br><span class="line">       </span><br><span class="line">       rospy.loginfo(<span class="string">"Publishing combined odometry on /odom_ekf"</span>)</span><br><span class="line">       </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">pub_ekf_odom</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">       odom = Odometry()</span><br><span class="line">       odom.header = msg.header</span><br><span class="line">       odom.header.frame_id = <span class="string">'/odom'</span></span><br><span class="line">       odom.child_frame_id = <span class="string">'base_footprint'</span></span><br><span class="line">       odom.pose = msg.pose</span><br><span class="line">       </span><br><span class="line">       self.ekf_pub.publish(odom)</span><br><span class="line">       </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">       OdomEKF()</span><br><span class="line">       rospy.spin()</span><br><span class="line">   <span class="keyword">except</span>:</span><br><span class="line">       <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>修改<code>xiaoqiang_move_base_blank_map.launch</code>中的static_transform_publisher和remap中的里程计话题名称. 打开<code>nav_test/config/xiaoqiang/local_costmap_params.yaml</code>, 将<code>global_frame</code>改为<code>odom_combined</code></p><p>参考:<a href="https://answers.ros.org/question/11682/robot_pose_ekf-with-an-external-sensor/?answer=17402#post-id-17402" target="_blank" rel="noopener">ROS answer的回答</a><br><a href="http://xxty.fun/2019/08/12/ROS%E5%B0%8F%E8%BD%A6%EF%BC%9Arobot_pose_ekf%E8%9E%8D%E5%90%88%E9%87%8C%E7%A8%8B%E8%AE%A1%E4%BF%A1%E6%81%AF/" target="_blank" rel="noopener">XiaoXiaoTao博客</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/25/C++/C++  面向对象/抛出异常/">抛出异常</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-面向对象/">C++ 面向对象</a></span><div class="content"><p>异常是运行期出现的情况，编译不会报错。如果出现异常，它后面的代码不会执行，一般会显示<font color="orange"> <font size="3">The program has unexpectedly finished. </font></font>。如果能处理好异常，就可以让后面的代码继续运行</p><p>throw就是抛出异常，后面可以接任何语句表示异常。比如<code>throw 123;</code>, <code>throw &quot;exception&quot;;</code></p><p>try里面的第一个语句必须包含throw，可以是个函数。之后的语句不再进行，直接进catch了</p><p>catch的参数是和throw一致的，比如下面的<code>const char*</code>，如果要catch任何类型，小括号内换成<code>...</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">"Division by zero condition!"</span>;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; division(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"本句不执行"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cerr</span> &lt;&lt; msg &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 输出错误用cerr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++ 提供了一系列标准的异常，定义在<exception>，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的。可以使用<code>catch(std::exception e)</code></exception></p><p>一些第三方库也提供了异常，使用时要注意。比如log4cpp:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    log4cpp::PropertyConfigurator::configure(config_base_path+<span class="string">"setting.conf"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (log4cpp::ConfigureFailure&amp; f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Configure Problem: "</span> &lt;&lt; f.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如程序运行前没有配置文件，而且没有使用异常机制，后面的程序就没法运行了。这不一定是我们想要的，我们不一定要求log4cpp的运行，所以使用异常就很合适了。</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/25/Linux基础/ELF文件/">ELF文件及调试命令</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux基础/">Linux基础</a></span><div class="content"><p>ELF文件有三种：可执行文件，so共享库，o目标文件</p><h2 id="打印文件校验和"><a href="#打印文件校验和" class="headerlink" title="打印文件校验和"></a>打印文件校验和</h2><p>二进制文件传输过程中有没有被损坏或者是否是同一个版本，看看校验和以及程序块计数:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># md5sum liblidar.so</span></span><br><span class="line">615f8ede92bb7cca3d559a46397474b6  liblidar.so</span><br></pre></td></tr></table></figure><h2 id="查看函数或者全局变量是否存在于elf文件中–nm"><a href="#查看函数或者全局变量是否存在于elf文件中–nm" class="headerlink" title="查看函数或者全局变量是否存在于elf文件中–nm"></a>查看函数或者全局变量是否存在于elf文件中–nm</h2><p>nm命令用于查看elf文件的符号信息。文件编译出来之后，我们可能不知道新增加的函数或者全局变量是否已经成功编译进去。这时候，我们可以使用nm命令来查看。</p><h2 id="打印ELF文件中的可打印字符串-strings"><a href="#打印ELF文件中的可打印字符串-strings" class="headerlink" title="打印ELF文件中的可打印字符串  strings"></a>打印ELF文件中的可打印字符串 strings</h2><p>例如你在代码中存储了一个版本号信息，那么即使编译成elf文件后，仍然可以通过strings搜索其中的字符串甚至可以搜索某个.c文件是否编译在其中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings elfFile| grep <span class="string">"someString"</span></span><br></pre></td></tr></table></figure><h2 id="查看文件段大小-size"><a href="#查看文件段大小-size" class="headerlink" title="查看文件段大小 size"></a>查看文件段大小 size</h2><p>可以通过size命令查看各段大小：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># size cmdTest</span></span><br><span class="line">text       data      bss      dec      hex  filename</span><br><span class="line">1319      560        8     1887      75f   cmdTest</span><br></pre></td></tr></table></figure><p>text段：正文段字节数大小<br>data段:包含静态变量和已经初始化的全局变量的数据段字节数大小<br>bss段：存放程序中未初始化的全局变量的字节数大小<br>当我们知道各个段的大小之后，如果有减小程序大小的需求，就可以有针对性的对elf文件进行优化处理。</p><h2 id="为elf文件瘦身-strip"><a href="#为elf文件瘦身-strip" class="headerlink" title="为elf文件瘦身  strip"></a>为elf文件瘦身 strip</h2><p>strip用于去掉elf文件中所有的符号信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls -al cmdTest</span></span><br><span class="line">-rwxr-xr-x 1 hyb root 9792 Sep 25 20:30 cmdTest <span class="comment">#总大小为9792字节</span></span><br><span class="line">strip cmdTest</span><br><span class="line">ls -al cmdTest</span><br><span class="line">-rwxr-xr-x 1 hyb root 6248 Sep 25 20:35 cmdTest<span class="comment">#strip之后大小为6248字节</span></span><br></pre></td></tr></table></figure><p>可以看到，“瘦身”之后，大小减少将近三分之一。但是要特别注意的是，“瘦身”之后的elf文件由于没有了符号信息，许多调试命令将无法正常使用，出现core dump时，问题也较难定位，因此只建议在正式发布时对其进行“瘦身”。</p><p>##查看elf文件信息 readelf</p><p>readelf用于查看elf文件信息，它可以查看各段信息，符号信息等，<code>readelf -h cmdTest</code>是查看elf文件头信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  <span class="comment">#elf文件魔数字</span></span><br><span class="line">Class:                             ELF64  <span class="comment">#64位 elf文件</span></span><br><span class="line">Data:                              2<span class="string">'s complement, little endian#字节序为小端序</span></span><br><span class="line"><span class="string">Version:                           1 (current)</span></span><br><span class="line"><span class="string">OS/ABI:                            UNIX - System V #</span></span><br><span class="line"><span class="string">ABI Version:                       0</span></span><br><span class="line"><span class="string">Type:                              EXEC (Executable file)#目标文件类型</span></span><br><span class="line"><span class="string">Machine:                           Advanced Micro Devices X86-64 #目标处理器体系</span></span><br><span class="line"><span class="string">Version:                           0x1</span></span><br><span class="line"><span class="string">Entry point address:               0x400440  #入口地址</span></span><br><span class="line"><span class="string">Start of program headers:          64 (bytes into file)</span></span><br><span class="line"><span class="string">Start of section headers:          4456 (bytes into file)</span></span><br><span class="line"><span class="string">Flags:                             0x0</span></span><br><span class="line"><span class="string">Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">Size of program headers:           56 (bytes)</span></span><br><span class="line"><span class="string">Number of program headers:         9</span></span><br><span class="line"><span class="string">Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">Number of section headers:         28</span></span><br><span class="line"><span class="string">Section header string table index: 27</span></span><br></pre></td></tr></table></figure><p>从elf头信息中，我们可以知道该elf是64位可执行文件，运行在x86-64中，且字节序为小端序。另外，我们还注意到它的入口地址是<code>0x400440(_start)</code>，而不是<code>400540(main)</code>。也就是说，我们的程序运行并非从main开始。</p><p>参考：<a href="https://www.yanbinghu.com/2019/10/13/54745.html" target="_blank" rel="noopener"></a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/25/C++/C++  面向对象/operator()/">operator()</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-面向对象/">C++ 面向对象</a></span><div class="content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>   <span class="title">operator</span><span class="params">()</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"Foo operator"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val*<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo f;</span><br><span class="line">f();    <span class="comment">// Foo operator</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; f(<span class="number">5</span>) &lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 50</span></span><br></pre></td></tr></table></figure><p>Foo是定义了调用操作符（）的类,它的对象就相当于函数名,因此<code>operator()</code>取名叫函数对象</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/21/Qt/如何让第三方库和Qt自身库一样使用/">如何让第三方库和Qt自身库一样使用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Qt/">Qt</a></span><div class="content"><p>Qt中添加模块都是编辑pro文件，比如<code>QT += network</code>，显然跟某些文件是对应的，加入我们自己编译了一个第三方库，怎么才能这样使用？</p><p>我们一般编译会生成<code>include/LibName</code>, <code>lib</code>(存放库文件), <code>mkspecs</code>几个文件夹。做如下操作即可：</p><ul><li><p>库文件都放入<code>5.14.1\mingw73_64\bin</code>，就像Qt5Network.dll一样</p></li><li><p>头文件放入<code>5.14.1\mingw73_64\include</code>，就像QtWebSockets一样</p></li><li><p><code>mkspecs\modules</code>中的pri文件放入<code>5.14.1\mingw73_64\mkspecs\modules</code>中，就像qt_lib_sql.pri, qt_lib_svg.pri</p></li></ul><p>现在可以优雅使用第三方库了，名称和pri文件的最后部分一样</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/21/第三方库/MQTT(二) QtMqtt客户端实现发布订阅/">MQTT(二) QtMqtt客户端实现发布订阅</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/第三方库/">第三方库</a></span><div class="content"><p>代码在<a href="https://github.com/charon-cheung/MQTT_Client" target="_blank" rel="noopener">这里</a>，网上的示例是<a href="https://github.com/emqx/qmqtt" target="_blank" rel="noopener">这个</a>，但是我发现现在的QtMqtt已经变换很大，之前的API很多已经不能使用了</p><p>值得注意的是，客户端不能在构造函数里订阅话题，因为客户端在connected信号对应的槽函数里才连接成功，所以订阅也应该换到槽函数或者自己做的按钮里</p><p>MQTT的通信可以在wireshark里读取，可以直接解析MQTT的数据包：<br><img src="https://i.loli.net/2020/03/22/sR7NwdvrjLHnp4m.png" alt="发布话题test到客户端"></p></div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/46/">46</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image:url(https://i.loli.net/2020/07/13/QgyrefaLDxhBWSZ.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>