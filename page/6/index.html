<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG={root:"/",algolia:{appId:"RI90VLL69D",apiKey:"20c535e9a1424a7913210eb747d6e67b",indexName:"HexoBlog",hits:{per_page:10},languages:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}.",hits_stats:"${hits} results found in ${time} ms"}},localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">413</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">49</span></a></div></div></div><nav id="nav" style="background-image:url(https://i.loli.net/2020/07/13/QgyrefaLDxhBWSZ.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div><div id="site-social-icons"><a class="social-icon" href="https://github.com/charon-cheung"><i class="fa-github fa"></i></a><a class="social-icon search"><i class="fa fa-search"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/02/激光SLAM/gmapping/(四) 源码分析2  initMapper 第2部分/">(四) 源码分析2 initMapper 第2部分</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/gmapping/">gmapping</a></span><div class="content"><h2 id="initMapper-第2部分"><a href="#initMapper-第2部分" class="headerlink" title="initMapper 第2部分"></a>initMapper 第2部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 激光的名称必须是"FLASER"</span></span><br><span class="line"><span class="comment">// 传入计算的angle increment绝对值, 因为gmapping接受正的angle increment</span></span><br><span class="line"><span class="comment">// 根据上面得到的激光雷达的数据信息， 初始化一个激光传感器</span></span><br><span class="line">gsp_laser_ = <span class="keyword">new</span> GMapping::RangeSensor(<span class="string">"FLASER"</span>,</span><br><span class="line">                                       gsp_laser_beam_count_,</span><br><span class="line">                                       <span class="built_in">fabs</span>(scan.angle_increment),</span><br><span class="line">                                       gmap_pose,   <span class="comment">// (0,0,0)</span></span><br><span class="line">                                       <span class="number">0.0</span>,</span><br><span class="line">                                       maxRange_);</span><br><span class="line">ROS_ASSERT(gsp_laser_);</span><br><span class="line"><span class="comment">// std::map&lt;std::string, Sensor*&gt;</span></span><br><span class="line">GMapping::SensorMap  smap;</span><br><span class="line"><span class="comment">// getName()就是 FLASER</span></span><br><span class="line">smap.insert(make_pair(gsp_laser_-&gt;getName(), gsp_laser_));</span><br><span class="line">gsp_-&gt;setSensorMap(smap);   <span class="comment">// GMapping::GridSlamProcessor*</span></span><br><span class="line"><span class="comment">// 构造函数里只有变量的赋值</span></span><br><span class="line">gsp_odom_ = <span class="keyword">new</span> GMapping::OdometrySensor(odom_frame_);</span><br><span class="line">ROS_ASSERT(gsp_odom_);</span><br><span class="line"></span><br><span class="line"><span class="comment">///得到里程计的初始位姿，如果没有，则把初始位姿设置为(0,0,0)</span></span><br><span class="line">GMapping::OrientedPoint  initialPose;</span><br><span class="line"><span class="keyword">if</span>(!getOdomPose(initialPose, scan.header.stamp))</span><br><span class="line">&#123;</span><br><span class="line">  ROS_WARN(<span class="string">"Unable to determine inital pose of laser! Starting point will be set to zero."</span>);</span><br><span class="line">  initialPose = GMapping::OrientedPoint(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下全是参数的设置，纯粹变量赋值，不多不少</span></span><br><span class="line">gsp_-&gt;setMatchingParameters(maxUrange_, maxRange_, sigma_,</span><br><span class="line">                            kernelSize_, lstep_, astep_, iterations_,</span><br><span class="line">                            lsigma_, ogain_, lskip_);</span><br><span class="line"></span><br><span class="line">gsp_-&gt;setMotionModelParameters(srr_, srt_, str_, stt_);</span><br><span class="line">gsp_-&gt;setUpdateDistances(linearUpdate_, angularUpdate_, resampleThreshold_);</span><br><span class="line">gsp_-&gt;setUpdatePeriod(temporalUpdate_);</span><br><span class="line">gsp_-&gt;setgenerateMap(<span class="literal">false</span>);</span><br><span class="line">gsp_-&gt;GridSlamProcessor::init(particles_, xmin_, ymin_, xmax_, ymax_,</span><br><span class="line">                              delta_, initialPose);</span><br><span class="line">gsp_-&gt;setllsamplerange(llsamplerange_);</span><br><span class="line">gsp_-&gt;setllsamplestep(llsamplestep_);</span><br><span class="line">gsp_-&gt;setlasamplerange(lasamplerange_);</span><br><span class="line">gsp_-&gt;setlasamplestep(lasamplestep_);</span><br><span class="line">gsp_-&gt;setminimumScore(minimum_score_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成1作为方差，均值为0的高斯分布</span></span><br><span class="line">GMapping::sampleGaussian(<span class="number">1</span>, seed_);</span><br><span class="line"></span><br><span class="line">ROS_INFO(<span class="string">"Mapper Initialization complete"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h3 id="getOdomPose"><a href="#getOdomPose" class="headerlink" title="getOdomPose"></a>getOdomPose</h3><p>获得<code>centered_laser_pose_</code> (laser坐标系的原点, 方向(0,0,angle_center)) 在odom坐标系中的坐标<code>gmap_pose</code>，即scan消息的时间戳时，激光雷达在里程计坐标系中的位姿</p><p>调用： <code>getOdomPose(initialPose, scan.header.stamp)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line">SlamGMapping::getOdomPose(GMapping::OrientedPoint&amp; gmap_pose, <span class="keyword">const</span> ros::Time&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Get the pose of the centered laser at the right time</span></span><br><span class="line">  centered_laser_pose_.stamp_ = t;</span><br><span class="line"></span><br><span class="line">  tf::Stamped&lt;tf::Transform&gt; odom_pose;</span><br><span class="line">  <span class="comment">// 得到centered_laser_pose_ 在odom坐标系中的坐标 odom_pose</span></span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    tf_.transformPose(odom_frame_, centered_laser_pose_, odom_pose);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(tf::TransformException e)</span><br><span class="line">  &#123;</span><br><span class="line">    ROS_WARN(<span class="string">"Failed to compute odom pose, skipping scan (%s)"</span>, e.what());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">double</span> yaw = tf::getYaw(odom_pose.getRotation());</span><br><span class="line">  ROS_INFO(<span class="string">"get centered_laser_pose_'s odom pose: yaw: %f"</span>, yaw);</span><br><span class="line">  ROS_INFO(<span class="string">"centered_laser_pose_'s odom pose:: %f %f %f"</span>,odom_pose.getOrigin().x(), odom_pose.getOrigin().y(), odom_pose.getOrigin().z());</span><br><span class="line">  gmap_pose = GMapping::OrientedPoint(odom_pose.getOrigin().x(),</span><br><span class="line">                                      odom_pose.getOrigin().y(), yaw);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="sampleGaussian"><a href="#sampleGaussian" class="headerlink" title="sampleGaussian"></a>sampleGaussian</h3><p>S是随机数种子，保证每次的高斯分布不同。AMCL源码中是<code>pf_pdf_gaussian_sample</code>函数中调用<code>pf_ran_gaussian</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sampleGaussian</span><span class="params">(<span class="keyword">double</span> sigma, <span class="keyword">unsigned</span> <span class="keyword">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       srand(S);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sigma==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> pf_ran_gaussian (sigma);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="GridSlamProcessor-init"><a href="#GridSlamProcessor-init" class="headerlink" title="GridSlamProcessor::init"></a>GridSlamProcessor::init</h3><p>GridFastSLAM初始化主要是用来初始化各个粒子的一些信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GridSlamProcessor::init(<span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">double</span> xmin, <span class="keyword">double</span> ymin, <span class="keyword">double</span> xmax, <span class="keyword">double</span> ymax, <span class="keyword">double</span> delta, OrientedPoint initialPose)</span><br><span class="line">&#123;</span><br><span class="line">  　　<span class="comment">//设置地图大小和分辨率</span></span><br><span class="line">   　m_xmin=xmin;</span><br><span class="line">    m_ymin=ymin;</span><br><span class="line">    m_xmax=xmax;</span><br><span class="line">    m_ymax=ymax;</span><br><span class="line">    m_delta=delta;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*设置每个粒子的初始值*/</span></span><br><span class="line">    m_particles.clear();    <span class="comment">// vector&lt;Particle&gt;</span></span><br><span class="line">    TNode* node=<span class="keyword">new</span> TNode(initialPose, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//粒子对应的地图进行初始化 用两个地图来进行初始化 一个高分辨率地图 一个低分辨率地图</span></span><br><span class="line">    <span class="comment">//高分辨率地图由自己指定 低分辨率地图固定为0.1m</span></span><br><span class="line">    <span class="comment">//定义最终使用的地图数据类型 cell类型为 PointAccumulator 存储数据类型为HierarchicalArray2D&lt;PointAccumulator&gt;</span></span><br><span class="line">    <span class="comment">// typedef Map&lt;PointAccumulator,HierarchicalArray2D&lt;PointAccumulator&gt; &gt; ScanMatcherMap;</span></span><br><span class="line">    <span class="function">ScanMatcherMap <span class="title">lmap</span><span class="params">(Point(xmin+xmax, ymin+ymax)*<span class="number">.5</span>, xmax-xmin, ymax-ymin, delta)</span></span>;</span><br><span class="line">    <span class="function">ScanMatcherMap <span class="title">lowMap</span><span class="params">(Point(xmin+xmax,ymin+ymax)*<span class="number">0.5</span>,xmax-xmin,ymax-ymin,　<span class="number">0.1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)    <span class="comment">// size是粒子数</span></span><br><span class="line">    &#123;</span><br><span class="line">      m_particles.push_back(Particle(lmap,lowMap));</span><br><span class="line">      <span class="comment">//m_particles.push_back(Particle(lmap));</span></span><br><span class="line">      m_particles.back().pose　=　initialPose;</span><br><span class="line">      <span class="comment">// 开始时，前一帧的粒子位姿也是 initialPose</span></span><br><span class="line">      m_particles.back().previousPose　=　initialPose;</span><br><span class="line">      m_particles.back().setWeight(<span class="number">0</span>);</span><br><span class="line">      m_particles.back().previousIndex=<span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// we use the root directly</span></span><br><span class="line">      m_particles.back().node= node;</span><br><span class="line">    &#125;</span><br><span class="line">    m_neff=(<span class="keyword">double</span>)size;</span><br><span class="line">    m_count=<span class="number">0</span>;</span><br><span class="line">    m_readingCount=<span class="number">0</span>;</span><br><span class="line">    m_linearDistance=m_angularDistance=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/01/视觉SLAM/融合Realsense+Laser的二维scan导航/">融合Realsense+Laser的二维scan导航</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/视觉SLAM/">视觉SLAM</a></span><div class="content"><p>因为二维雷达只能扫描一个平面，所以低于或高于这个平面的障碍物扫描不到，机器人也就难以进行建图和导航。当然可以用3D雷达，但是这个成本一下大了很多，对于室内环境太奢侈了。</p><p>由于kinect具有一定的水平和垂直视角，它的FOV可以覆盖不同高度的障碍。深度图可以转化为scan，这样就可以把障碍物投影到二维地图上了，把kinect和雷达融合，就可以解决这个问题了。</p><p>阅读了几篇论文，把这个方案总结了一下，但是感觉没有多少可行性，那些论文只能用于研究。其实想想，kinect这么廉价的东西，跟雷达相比，它转换出的scan肯定不如雷达，这么一融合，恐怕够呛。</p><p>基本的思路是这样:</p><p><strong>Kinect —— 深度图 —— 降噪滤波 —— 转为scan —— 与雷达scan融合 —— 作为SLAM算法的输入 —— 建图</strong></p><p>这里有两种方案：kinect和laser的安装朝向相同或者相反(呈180°)，结果发现存在以下问题：</p><ol><li>和雷达相同，kinect对透明或高反射性的表面也难以检测</li><li>降噪滤波算法需要反复试验</li><li>转为scan一般使用的是depthimage_to_laserscan包，但这个包存在<a href="https://charon-cheung.github.io/2020/06/05/%E8%A7%86%E8%A7%89SLAM/depthimage_to_laserscan%20%E6%B7%B1%E5%BA%A6%E5%9B%BE%E8%BD%ACscan/">scan_height难以调整的问题</a></li><li>融合scan使用的是ira_laser_tools中的laser_multi_merger包，但是这个包是针对激光scan，不是针对kinect转出的scan，需要做一些修改。</li><li>对于gmapping算法，当两个传感器反向安装时，低处的障碍物开始出现地图里，但是过了一会又消失了，因为雷达scan在Kinect-scan之后检测到了墙，gmapping会把之前的kinect-scan当做错误而把相应的区域又按free space处理。同向安装时，kinect-scan扫描的障碍物会变得不太清晰，原因跟反向安装时还是一样的。</li><li>如果用的是kinect1，因为是基于结构光，所以不适合室外使用。不能感知小障碍物，深度图的深度值是<code>0.5~8</code>米，分辨率又太低，建图精度不行，以及FOV不大</li></ol><p>另外朝向相同时，建图精度不如朝向相反的情况。原因还是里程计误差，朝向相反时，两个传感器融合造成的扫描角度大于朝向相同的时候，所以机器人行走比较少。</p><p>由于以上原因，这个方案的可行性大打折扣，尤其是3和5，除非自己修改现有的包和gmapping算法(降低地图cell被确定为<strong>占用</strong>的概率threshold)，但是这样要做的工作就更多了。</p><p>论文提出了一个折中方案，结合个人思考，修改方案如下：</p><ol><li>使用realsense 435相机，它的深度值为<code>0.1~10m</code>，黑洞和噪点比较少。FOV和分辨率也比Kinect好多了</li><li>调整<code>scan_height</code>为一个固定值，保证近距离的障碍物能正常识别，远处障碍不必太考虑。</li><li>生成<code>/camera/scan</code>话题，把它用作costmap2D的单独一层，不再和雷达的scan合并</li></ol><p>值得注意的是，这个新的层不需要单独写C++，将下述代码复制到costmap_common_params.yaml:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">camera_layer:</span><br><span class="line">  enabled:              <span class="literal">true</span></span><br><span class="line">  max_obstacle_height:  2.2</span><br><span class="line">  origin_z:             0.0</span><br><span class="line">  z_resolution:         0.1</span><br><span class="line">  z_voxels:             22</span><br><span class="line">  unknown_threshold:    15</span><br><span class="line">  mark_threshold:       0</span><br><span class="line">  combination_method:   1</span><br><span class="line">  track_unknown_space:  <span class="literal">true</span>    <span class="comment">#true needed for disabling global path planning through unknown space</span></span><br><span class="line">  obstacle_range: 2.5</span><br><span class="line">  raytrace_range: 3.0</span><br><span class="line">  publish_voxel_map: <span class="literal">true</span></span><br><span class="line">  observation_sources:  scan</span><br><span class="line">  scan:</span><br><span class="line">    data_type: LaserScan</span><br><span class="line">    topic: camera/scan</span><br><span class="line">    marking: <span class="literal">true</span></span><br><span class="line">    clearing: <span class="literal">true</span></span><br><span class="line">    min_obstacle_height: 0.1</span><br><span class="line">    max_obstacle_height: 0.3</span><br></pre></td></tr></table></figure><p>将下述代码分别复制到<code>global_costmap_params.yaml</code>和<code>local_costmap_param.yaml</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &#123;name: camera_layer,            <span class="built_in">type</span>: <span class="string">"costmap_2d::VoxelLayer"</span>&#125;</span><br></pre></td></tr></table></figure><p>该行代码需要在障碍层代码的上部</p><h2 id="depth-nav-tools"><a href="#depth-nav-tools" class="headerlink" title="depth_nav_tools"></a>depth_nav_tools</h2><p>ROS另有一套用于kinect的工具包：<a href="https://github.com/mdrwiega/depth_nav_tools" target="_blank" rel="noopener">depth_nav_tools</a>，不过懒得研究了</p><ul><li><p>laserscan_kinect: Converts a depth image coded with uint16 to laser scan 2D (sensor_msgs/LaserScan).</p></li><li><p>cliff_detector: 检测negative障碍物，比如悬崖或下楼</p></li><li><p>depth_sensor_pose: Detects ground plane in depth image and estimates height and tilt angle of depth sensor.</p></li><li><p>nav_layer_from_points: <strong>创建代价地图的一层</strong> based on received points coordinates in robot frame.</p></li><li><p>depth_nav_msgs: 用于其他packages的msg</p></li></ul><p>还有这个 <a href="https://github.com/marshallpowell97/laser_merge" target="_blank" rel="noopener">第三方融合laser和kinect生成的scan</a></p><h2 id="手持kinect建图"><a href="#手持kinect建图" class="headerlink" title="手持kinect建图"></a>手持kinect建图</h2><p>这才是<code>depthimage_to_laserscan</code>的常见用途</p><p>流程: kinect——深度图——scan——laser_scan_matcher——gmapping</p><p><img src="https://i.loli.net/2020/06/09/9aZfunEO24BTUCQ.png" alt="rqt节点关系图"></p><p>手持kinect没有里程计信息，可以用<code>laser_scan_matcher</code>做里程计估计器，它可以输出一个模拟的里程计信息，实际就是参数<code>fixed_frame</code>的值</p><p>建图时要保证kinect的水平，如果有一定程度的倾斜或翻转，建的地图就有误差。gmapping算法的时间与kinect的移动速度和环境面积有关，所以不要移动太快。</p><p>参考：<br><a href="http://wiki.ros.org/ira_laser_tools" target="_blank" rel="noopener">ira_laser_tools</a><br><a href="https://blog.csdn.net/anchuanxu/article/details/108235704" target="_blank" rel="noopener">ROS机器人视觉避障部署流程</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/27/激光SLAM/gmapping/(五) 源码分析3  laserCallback第2部分及addScan/">(五) 源码分析3 laserCallback第2部分及addScan, updateMap</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/gmapping/">gmapping</a></span><div class="content"><h2 id="laserCallback-第2部分"><a href="#laserCallback-第2部分" class="headerlink" title="laserCallback 第2部分"></a>laserCallback 第2部分</h2><p>接<code>initMapper</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">GMapping::OrientedPoint odom_pose;</span><br><span class="line"><span class="comment">// addScan这个函数要转到pf的核心代码了，将调用processScan</span></span><br><span class="line"><span class="keyword">if</span>(addScan(*scan, odom_pose))</span><br><span class="line">&#123;</span><br><span class="line">  ROS_DEBUG(<span class="string">"scan processed done !"</span>);</span><br><span class="line">  <span class="comment">// 从粒子集合中挑选最优的粒子， 以其地图坐标为基准， 计算从激光雷达到地图之间的坐标变换</span></span><br><span class="line">  GMapping::OrientedPoint mpose = gsp_-&gt;getParticles()[gsp_-&gt;getBestParticleIndex()].pose;</span><br><span class="line">  ROS_INFO(<span class="string">"new best pose: %.3f %.3f %.3f"</span>, mpose.x, mpose.y, mpose.theta);</span><br><span class="line">  tf::Transform laser_to_map = tf::Transform(tf::createQuaternionFromRPY(<span class="number">0</span>, <span class="number">0</span>, mpose.theta), tf::Vector3(mpose.x, mpose.y, <span class="number">0.0</span>)).inverse();</span><br><span class="line"></span><br><span class="line">  ROS_INFO(<span class="string">"odom pose: %.3f %.3f %.3f"</span>, odom_pose.x, odom_pose.y, odom_pose.theta);</span><br><span class="line">  tf::Transform odom_to_laser = tf::Transform(tf::createQuaternionFromRPY(<span class="number">0</span>, <span class="number">0</span>, odom_pose.theta), tf::Vector3(odom_pose.x, odom_pose.y, <span class="number">0.0</span>));</span><br><span class="line"></span><br><span class="line">  ROS_WARN(<span class="string">"correction: %.3f %.3f %.3f"</span>, mpose.x - odom_pose.x, mpose.y - odom_pose.y, mpose.theta - odom_pose.theta);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 另一处的lock在 SlamGMapping::publishTransform()， 这里是获得map_to_odom_，前者是发布</span></span><br><span class="line">  map_to_odom_mutex_.lock();</span><br><span class="line">  map_to_odom_ = (odom_to_laser * laser_to_map).inverse();</span><br><span class="line">  map_to_odom_mutex_.unlock();</span><br><span class="line">  <span class="comment">// 如果没有地图则直接更新。 如果有地图了，两次扫描时间差大于参数，才更新地图</span></span><br><span class="line">  <span class="keyword">if</span>(!got_map_ || (scan-&gt;header.stamp - last_map_update) &gt; map_update_interval_)</span><br><span class="line">  &#123;</span><br><span class="line">    updateMap(*scan);</span><br><span class="line">    last_map_update = scan-&gt;header.stamp;</span><br><span class="line">    ROS_DEBUG(<span class="string">"Updated the map"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  ROS_WARN(<span class="string">"cannot process scan"</span>);</span><br></pre></td></tr></table></figure><p>这里如果<code>addScan</code>返回false，就是未向地图添加scan，原因在<code>processScan</code>里，可能是机器人走过的线距离太短或者旋转过角度太少，未达到门槛；或者未达到指定的时间(<code>period_</code>，写死为5秒)，毕竟我们不希望机器人停着不动就更新地图，那太消耗资源了。</p><p><code>updateMap()</code>得到最优的粒子的地图数据，利用占据栅格地图算法，更新地图。</p><h3 id="addScan"><a href="#addScan" class="headerlink" title="addScan"></a>addScan</h3><p>把新的测量值和里程计坐标报告给建图引擎gsp_，让其更新粒子集。 根据激光雷达的安装方式，对角度进行修改。</p><p>然后将ROS的激光雷达采集的信息转换成gmapping能看懂的格式。设置和激光数据时间戳匹配的机器人的位姿。调用<code>processscan</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入一个激光雷达的数据, 里面会调用 processScan()函数,这个函数被laserCallback()函数调用</span></span><br><span class="line"><span class="comment">// gmap_pose为刚定义的里程计的累积位姿</span></span><br><span class="line"><span class="keyword">bool</span> SlamGMapping::addScan(<span class="keyword">const</span> sensor_msgs::LaserScan&amp;  scan, GMapping::OrientedPoint&amp;  gmap_pose)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//得到与激光的时间戳相对应的机器人的里程计的位姿</span></span><br><span class="line">    <span class="keyword">if</span>(!getOdomPose(gmap_pose, scan.header.stamp))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测是否所有帧的数据都是相等的，如果不相等就return</span></span><br><span class="line">    <span class="keyword">if</span>(scan.ranges.size() != gsp_laser_beam_count_)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span>* ranges_double = <span class="keyword">new</span> <span class="keyword">double</span>[scan.ranges.size()];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果激光是反着装的，这激光的顺序需要反过来，这段代码省略</span></span><br><span class="line">    <span class="keyword">if</span> (do_reverse_range_)</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; scan.ranges.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// mapper那里无法过滤掉</span></span><br><span class="line">            <span class="comment">// 排除掉所有激光距离小于range_min的值，它们很可能是噪声数据</span></span><br><span class="line">            <span class="keyword">if</span>(scan.ranges[i] &lt; scan.range_min)</span><br><span class="line">                ranges_double[i] = (<span class="keyword">double</span>)scan.range_max;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ranges_double[i] = (<span class="keyword">double</span>)scan.ranges[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把ROS的激光雷达数据信息 转换为 GMapping算法看得懂的形式</span></span><br><span class="line">    <span class="comment">// 激光传感器gsp_laser_ 在initMapper里定义，ranges数据赋值给m_dists，size给m_beams</span></span><br><span class="line">    GMapping::<span class="function">RangeReading <span class="title">reading</span><span class="params">(scan.ranges.size(),</span></span></span><br><span class="line"><span class="function"><span class="params">                                   ranges_double,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   gsp_laser_,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   scan.header.stamp.toSec())</span></span>;</span><br><span class="line">    <span class="comment">// 上面的初始化是进行深拷贝，因此申请的内存可以直接释放。</span></span><br><span class="line">    <span class="keyword">delete</span>[] ranges_double;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置和激光数据的时间戳匹配的机器人的位姿   不是雷达位姿吗???</span></span><br><span class="line">    reading.setPose(gmap_pose);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用gmapping算法进行处理</span></span><br><span class="line">    <span class="keyword">return</span> gsp_-&gt;processScan(reading);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gmap_pose</code>应当是不同时间戳时，雷达扫描扇形的中心(包含角度)在odom坐标系中的坐标。</p><p>问题：</p><ul><li><code>reading.setPose(gmap_pose);</code> 解释存疑</li></ul><p>最后就是核心算法所在的<code>processScan</code></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/27/ROS/ROS机器人/ROS使用GPS/">ROS使用GPS</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS机器人/">ROS机器人</a></span><div class="content"><p>可以使用创客智造的<code>ublox</code>的GPS，淘宝有卖<br><a href="http://wiki.ros.org/ublox" target="_blank" rel="noopener"></a><br><a href="https://www.ncnynl.com/archives/201905/3053.html" target="_blank" rel="noopener">创客智造的教程</a></p><p>GPS无法完成室内环境的精确定位, 但是发现一种被称为”室内GPS”的产品<code>Marvelmind beacon</code>，其定位精度达到2cm，配合<code>robot_localization</code>实现多传感器融合,可显著提高定位精度，但价格4000。参考:<a href="https://github.com/methylDragon/ros-sensor-fusion-tutorial" target="_blank" rel="noopener">sensor fusion with robot_localization</a></p><p>差分GPS RTK的精度可以达到2cm左右，但价格在2000以上</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/26/ROS/ROS Kinetic知识/tf MessageFilter/">tf MessageFilter</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic知识/">ROS Kinetic知识</a></span><div class="content"><p>tf::MessageFilter可以订阅任何的ROS消息，然后将其缓存，直到这些消息可以转换到目标坐标系，然后进行相应的处理（进入回调函数）</p><p>tf::MessageFilter的初始化需要message_filters::Subscriber，tf转换，<strong>目标坐标系</strong>，等待时间。当message_filters::Subscriber的消息能够由tf转换到目标坐标系时，调用回调函数，回调函数由<code>tf::MessageFilter::registerCallback()</code>进行注册。</p><p>步骤:</p><ol><li>定义数据：TransformListener、message_filters::Subscriber、tf::MessageFilter</li><li>用话题的名称来初始化message_filters::Subscriber</li><li>用<code>tf</code> <code>message_filters::Subscriber</code> 目标坐标系来初始化<code>tf::MessageFilter</code></li><li>给tf::MessageFilter注册callback<br>，编写callback，并在回调中完成坐标转换，至此完成消息订阅+坐标转换</li></ol></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/25/激光SLAM/gmapping/(三) 源码分析1  总体和laserCallback 第1部分/">(三) 源码分析1 总体和laserCallback 第1部分</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/gmapping/">gmapping</a></span><div class="content"><p>到<code>gmapping</code>包里，查看CMakeLists可知，gmapping所用的可执行文件主要是<code>slam_gmapping</code>，对应<code>slam_gmapping.cpp</code>。</p><p>用到了头文件<code>gridslamprocessor.h</code>，其位于<code>/opt/ros/kinetic/include/gmapping/gridfastslam/</code></p><p>gmapping用到的很重要的动态库有<code>/opt/ros/kinetic/lib/libgridfastslam.so</code>，它的来源是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add_library(gridfastslam</span><br><span class="line">    gfsreader.cpp</span><br><span class="line">    gridslamprocessor.cpp</span><br><span class="line">    gridslamprocessor_tree.cpp</span><br><span class="line">    motionmodel.cpp</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 又链接库 scanmatcher  sensor_range</span></span><br><span class="line">target_link_libraries(gridfastslam scanmatcher sensor_range)</span><br></pre></td></tr></table></figure><p><code>scanmatcher</code>库的来源：<br><code>add_library(scanmatcher eig3.cpp scanmatcher.cpp scanmatcherprocessor.cpp smmap.cpp)</code></p><br><p>main函数如下，显然就看<code>SlamGMapping</code>了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ros::init(argc, argv, <span class="string">"slam_gmapping"</span>);</span><br><span class="line">SlamGMapping gn;</span><br><span class="line">gn.startLiveSlam();</span><br><span class="line">ros::spin();</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/05/29/sLX7JRfuYqzHQk6.png" alt="gmapping流程图.png"></p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数只有两行，定义了随机数种子，供之后的高斯采样使用。然后是init函数，它也很简单，先是下面两行，看来主要是类<strong>GridSlamProcessor</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gsp_ = <span class="keyword">new</span> GMapping::GridSlamProcessor();</span><br><span class="line">tfB_ = <span class="keyword">new</span> tf::TransformBroadcaster();</span><br></pre></td></tr></table></figure><p><code>GridSlamProcessor</code>构造函数其实有用的就一句<code>period_ = 5.0;</code>，其他是参数赋值，但在<code>initMapper</code>里又会重新赋值，其实是多余的。 然后声明两个指针和布尔量，剩下的代码全是读取和配置参数了</p><h2 id="startLiveSlam"><a href="#startLiveSlam" class="headerlink" title="startLiveSlam"></a>startLiveSlam</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册entryopy  map  map_metadata话题　　　dynamic_map服务</span></span><br><span class="line">entropy_publisher_ = private_nh_.advertise&lt;std_msgs::Float64&gt;(<span class="string">"entropy"</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">sst_ = node_.advertise&lt;nav_msgs::OccupancyGrid&gt;(<span class="string">"map"</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">sstm_ = node_.advertise&lt;nav_msgs::MapMetaData&gt;(<span class="string">"map_metadata"</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">ss_ = node_.advertiseService(<span class="string">"dynamic_map"</span>, &amp;SlamGMapping::mapCallback, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">scan_filter_sub_ = <span class="keyword">new</span> message_filters::Subscriber&lt;sensor_msgs::LaserScan&gt;(node_, <span class="string">"scan"</span>, <span class="number">5</span>);</span><br><span class="line">scan_filter_ = <span class="keyword">new</span> tf::MessageFilter&lt;sensor_msgs::LaserScan&gt;(*scan_filter_sub_, tf_, odom_frame_, <span class="number">5</span>);</span><br><span class="line">scan_filter_-&gt;registerCallback(boost::bind(&amp;SlamGMapping::laserCallback, <span class="keyword">this</span>, _1));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以成员函数publishLoop作为线程启动，参数为　transform_publish_period,默认　0.05</span></span><br><span class="line">transform_thread_ = <span class="keyword">new</span> boost::thread(boost::bind(&amp;SlamGMapping::publishLoop, <span class="keyword">this</span>, transform_publish_period_));</span><br></pre></td></tr></table></figure><p><code>mapCallback</code>是service的回调函数，留给使用者定义客户端，这样一来重点是<code>laserCallback</code>，稍后再分析。</p><br><p>线程<code>transform_thread_</code>也很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(transform_publish_period == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">ros::<span class="function">Rate <span class="title">r</span><span class="params">(<span class="number">1.0</span> / transform_publish_period)</span></span>;</span><br><span class="line"><span class="keyword">while</span>(ros::ok())</span><br><span class="line">&#123;</span><br><span class="line">  publishTransform();</span><br><span class="line">  r.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><code>publishTransform</code>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map_to_odom_mutex_.lock();</span><br><span class="line">ros::Time tf_expiration = ros::Time::now() + ros::Duration(tf_delay_);</span><br><span class="line"><span class="comment">// 构造函数里定义的广播，　发布map和odom之间的变换</span></span><br><span class="line">tfB_-&gt;sendTransform( tf::StampedTransform (map_to_odom_, tf_expiration, map_frame_, odom_frame_));</span><br><span class="line">map_to_odom_mutex_.unlock();</span><br></pre></td></tr></table></figure><h2 id="laserCallback-第1部分"><a href="#laserCallback-第1部分" class="headerlink" title="laserCallback 第1部分"></a>laserCallback 第1部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">laser_count_++;</span><br><span class="line"><span class="comment">/*每隔throttle_scans_ （默认值 1）帧数据计算一次，限流作用*/</span></span><br><span class="line"><span class="keyword">if</span> ((laser_count_ % throttle_scans_) != <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ros::<span class="function">Time <span class="title">last_map_update</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!got_first_scan_)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*重要参数的初始化，将slam里的参数传递到 openslam 里 ，设定坐标系，坐标原点，以及</span></span><br><span class="line"><span class="comment">  采样函数随机种子的初始化，还调用了GridSlamProcessor::init,初始化了粒子数，子地图大小*/</span></span><br><span class="line">  <span class="keyword">if</span>(!initMapper(*scan))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  got_first_scan_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分析函数 <code>bool SlamGMapping::initMapper(const sensor_msgs::LaserScan&amp; scan)</code></p><ul><li>这个函数在收到的第一帧激光雷达数据的时候会被调用一次，之后就再也不会被调用了。</li><li>这个函数的功能主要就是对gmapping算法中需要的一些参数进行赋值，即对gmapping算法进行初始化</li></ul><ol><li>判断激光雷达是否是水平放置的，如果不是 则报错。</li><li>假设激光雷达数据的角度是对称的 &amp; 递增的 为每个激光束分配角度。</li><li>为gmapping算法设置各种需要的参数。</li></ol><h3 id="initMapper-第1部分"><a href="#initMapper-第1部分" class="headerlink" title="initMapper 第1部分"></a>initMapper 第1部分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">laser_frame_ = scan.header.frame_id;</span><br><span class="line"><span class="comment">// 雷达坐标系原点在base_link中的位置</span></span><br><span class="line">tf::Stamped&lt;tf::Pose&gt; ident;</span><br><span class="line">tf::Stamped&lt;tf::Transform&gt; laser_pose;</span><br><span class="line">ident.setIdentity();</span><br><span class="line">ident.frame_id_ = laser_frame_;   <span class="comment">// "laser"</span></span><br><span class="line">ident.stamp_ = scan.header.stamp;</span><br><span class="line">ROS_INFO(<span class="string">"ident : %f %f %f"</span>,ident.getOrigin().x(), ident.getOrigin().y(), ident.getOrigin().z());</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 输出laser_pose，雷达坐标系原点在base_link中的位置</span></span><br><span class="line">  tf_.transformPose(base_frame_, ident, laser_pose);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(tf::TransformException e)</span><br><span class="line">&#123;</span><br><span class="line">  ROS_WARN(<span class="string">"Failed to compute laser pose, aborting initialization (%s)"</span>,</span><br><span class="line">           e.what());</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">ROS_INFO(<span class="string">"laser_pose: %f %f %f"</span>,laser_pose.getOrigin().x(), laser_pose.getOrigin().y(), laser_pose.getOrigin().z());</span><br><span class="line"><span class="comment">// base_link坐标系中，创建laser_pose１米之上的点，再把它转到laser坐标系</span></span><br><span class="line">tf::Vector3 v;</span><br><span class="line">v.setValue(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> + laser_pose.getOrigin().z());</span><br><span class="line">tf::Stamped&lt;tf::Vector3&gt; up(v, scan.header.stamp, base_frame_);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  tf_.transformPoint(laser_frame_, up, up);</span><br><span class="line">  ROS_DEBUG(<span class="string">"Z-Axis in sensor frame: %.3f"</span>, up.z());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(tf::TransformException&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">  ROS_WARN(<span class="string">"Unable to determine orientation of laser: %s"</span>,</span><br><span class="line">           e.what());</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gmapping doesn't take roll or pitch into account.</span></span><br><span class="line"><span class="comment">// 这里是判断雷达是否倾斜</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(<span class="built_in">fabs</span>(up.z()) - <span class="number">1</span>) &gt; <span class="number">0.001</span>)</span><br><span class="line">&#123;</span><br><span class="line">  ROS_WARN(<span class="string">"Laser has to be mounted planar! Z-coordinate has to be 1 or -1, but gave: %.5f"</span>,</span><br><span class="line">               up.z());</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">gsp_laser_beam_count_ = scan.ranges.size();</span><br><span class="line"><span class="comment">// 扇形扫描面的中心</span></span><br><span class="line"><span class="keyword">double</span> angle_center = (scan.angle_min + scan.angle_max)/<span class="number">2</span>;</span><br><span class="line"><span class="comment">// 雷达是否正装</span></span><br><span class="line"><span class="keyword">if</span> (up.z() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  do_reverse_range_ = scan.angle_min &gt; scan.angle_max;</span><br><span class="line">  <span class="comment">// laser坐标系中的点(0,0,0), 方向(0,0,angle_center)</span></span><br><span class="line">  centered_laser_pose_ = tf::Stamped&lt;tf::Pose&gt;(</span><br><span class="line">    tf::Transform(tf::createQuaternionFromRPY(<span class="number">0</span>,<span class="number">0</span>,angle_center), </span><br><span class="line">      tf::Vector3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)),  ros::Time::now(),  laser_frame_);</span><br><span class="line">  ROS_INFO(<span class="string">"Laser is mounted upwards."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  do_reverse_range_ = scan.angle_min &lt; scan.angle_max;</span><br><span class="line">  centered_laser_pose_ = tf::Stamped&lt;tf::Pose&gt;(tf::Transform(tf::createQuaternionFromRPY(M_PI,<span class="number">0</span>,-angle_center),</span><br><span class="line">                                                             tf::Vector3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)), ros::Time::now(), laser_frame_);</span><br><span class="line">  ROS_INFO(<span class="string">"Laser is mounted upside down."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Compute the angles of the laser from -x to x, basically symmetric and in increasing order</span></span><br><span class="line">laser_angles_.resize(scan.ranges.size());</span><br><span class="line"><span class="comment">// 把角度调成对称，也就是扇形要关于ｚ轴对称，扫描角度从-3.124～3.142变为-3.133～3.133</span></span><br><span class="line"><span class="keyword">double</span> theta = - <span class="built_in">std</span>::<span class="built_in">fabs</span>(scan.angle_min - scan.angle_max)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;scan.ranges.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">  laser_angles_[i]=theta;</span><br><span class="line">  theta += <span class="built_in">std</span>::<span class="built_in">fabs</span>(scan.angle_increment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ROS_INFO(<span class="string">"Laser angles in laser-frame: min: %.3f max: %.3f inc: %.3f"</span>, scan.angle_min, scan.angle_max,</span><br><span class="line">          scan.angle_increment);</span><br><span class="line">ROS_INFO(<span class="string">"Laser angles in top-down centered laser-frame: min: %.3f max: %.3f inc: %.3f"</span>, laser_angles_.front(),  laser_angles_.back(), <span class="built_in">std</span>::<span class="built_in">fabs</span>(scan.angle_increment));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是Gmapping算法接受的点类型</span></span><br><span class="line">GMapping::<span class="function">OrientedPoint <span class="title">gmap_pose</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 设置激光雷达的最大观测距离和最大使用距离</span></span><br><span class="line">ros::<span class="function">NodeHandle <span class="title">private_nh_</span><span class="params">(<span class="string">"~"</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(!private_nh_.getParam(<span class="string">"maxRange"</span>, maxRange_))</span><br><span class="line">    maxRange_ = scan.range_max<span class="number">-0.01</span>;</span><br><span class="line"><span class="keyword">if</span>(!private_nh_.getParam(<span class="string">"maxUrange"</span>, maxUrange_))</span><br><span class="line">    maxUrange_=maxRange_;</span><br></pre></td></tr></table></figure><h3 id="GMapping-OrientedPoint"><a href="#GMapping-OrientedPoint" class="headerlink" title="GMapping::OrientedPoint"></a>GMapping::OrientedPoint</h3><p>这个是Gmapping算法接受的点类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">orientedpoint</span>:</span> <span class="keyword">public</span> point&lt;T&gt;&#123;</span><br><span class="line">  inline orientedpoint() : point&lt;T&gt;(0,0), theta(0) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">orientedpoint</span><span class="params">(<span class="keyword">const</span> point&lt;T&gt;&amp; p)</span></span>;</span><br><span class="line">    inline orientedpoint(T x, T y, A _theta): point&lt;T&gt;(x,y), theta(_theta)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">inline</span> orientedpoint&lt;T,A&gt; rotate(A alpha)</span><br><span class="line">    &#123;</span><br><span class="line">        T s=<span class="built_in">sin</span>(alpha), c=<span class="built_in">cos</span>(alpha);</span><br><span class="line">        A a=alpha+theta;</span><br><span class="line">        a=<span class="built_in">atan2</span>(<span class="built_in">sin</span>(a),<span class="built_in">cos</span>(a));</span><br><span class="line">        <span class="keyword">return</span> orientedpoint(</span><br><span class="line">            c*<span class="keyword">this</span>-&gt;x-s*<span class="keyword">this</span>-&gt;y,</span><br><span class="line">            s*<span class="keyword">this</span>-&gt;x+c*<span class="keyword">this</span>-&gt;y, </span><br><span class="line">            a);</span><br><span class="line">    &#125;</span><br><span class="line">    A theta;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">orientedpoint</span>&lt;T,A&gt;:</span>:normalize()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (theta &gt;= -M_PI &amp;&amp; theta &lt; M_PI)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> multiplier = (<span class="keyword">int</span>)(theta / (<span class="number">2</span>*M_PI));</span><br><span class="line">  theta = theta - multiplier*<span class="number">2</span>*M_PI;</span><br><span class="line">  <span class="keyword">if</span> (theta &gt;= M_PI)</span><br><span class="line">    theta -= <span class="number">2</span>*M_PI;</span><br><span class="line">  <span class="keyword">if</span> (theta &lt; -M_PI)</span><br><span class="line">    theta += <span class="number">2</span>*M_PI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/21/激光SLAM/常用数据集/">常用数据集</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/其他/">其他</a></span><div class="content"><p>我看到很多篇论文使用了log格式的数据集进行建图算法的仿真，比如<a href="https://www.ipb.uni-bonn.de/datasets/" target="_blank" rel="noopener">这里的</a>，发现这输入carmen框架，已经比较古老</p><ol><li>进入<a href="http://ais.informatik.uni-freiburg.de/slamevaluation/datasets.php" target="_blank" rel="noopener">informatik.uni-freiburg</a>选择<code>download log file</code>下载数据集</li><li>看到一个文本网页,另存下载或者新建一個文件如data.clf保存.注意是.clf格式</li><li>这个clf文件显然不是我们想要的,可以转换为bag文件. 使用<a href="https://github.com/charon-cheung/xiaoqiang_robot/blob/master/clf_to_bag.py" target="_blank" rel="noopener">clf_to_bag.py</a></li></ol><br><p><a href="http://projects.csail.mit.edu/stata/downloads.php" target="_blank" rel="noopener">MIT data center的数据集页面</a><br>数据集<code>2011-04-11-07-34-27.bag</code>所用odom坐标系是<code>odom_combined</code></p><br><p><a href="http://download.ros.org/data/gmapping/" target="_blank" rel="noopener">俄勒冈大学的数据集</a></p><p>数据集<code>hallway_slow_2011-03-04-21-41-33.bag</code>所用的雷达话题是<code>base_laser1_scan</code></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/19/ROS/ROS机器人/小强机器人的里程计误差/">小强机器人的里程计误差和IMU</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS机器人/">ROS机器人</a></span><div class="content"><h2 id="里程计"><a href="#里程计" class="headerlink" title="里程计"></a>里程计</h2><p>机器人从给定的初始位置启动，四处行驶并返回初始位置,完美的里程计图应显示出精确的回路闭合。里程计和imu这类积分原理的传感器，位姿肯定会漂，有时差的会很大。imu角度会比里程计好一点。还需要一个全局的信息，或者在建图的时候增加闭环，或者有路标提供世界定位。</p><p>里程计的协方差在<code>StatusPublisher.cpp</code>中，是个固定值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">car_status.encoder_ppr = <span class="number">4</span> * <span class="number">12</span> * <span class="number">64</span>;</span><br><span class="line">var_angle = (<span class="number">0.01f</span> / <span class="number">180.0f</span> * PI) * (<span class="number">0.01f</span> / <span class="number">180.0f</span> * PI);</span><br><span class="line"><span class="comment">// speed[0] = car_status.omga_r / car_status.encoder_ppr * 2.0 * PI * wheel_radius;</span></span><br><span class="line"><span class="comment">// speed[1] = car_status.omga_l / car_status.encoder_ppr * 2.0 * PI * wheel_radius;</span></span><br><span class="line">var_len = (<span class="number">50.0f</span> / car_status.encoder_ppr * <span class="number">2.0f</span> * PI * wheel_radius) * (<span class="number">50.0f</span> / car_status.encoder_ppr * <span class="number">2.0f</span> * PI * wheel_radius);</span><br><span class="line"></span><br><span class="line">CarOdom.pose.covariance = boost::assign::list_of(var_len)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(var_len)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">999</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">999</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">999</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(var_angle);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/05/22/rYNQuEhMTqBpz5A.png" alt="里程计协方差.png"></p><p>观察左右轮的编码器增量，大部分情况下都相同，不同时只差1，极少情况差2，但可以忽略。</p><h2 id="IMU"><a href="#IMU" class="headerlink" title="IMU"></a>IMU</h2><p>话题<code>xqserial_server/IMU</code>, IMU型号为MPU9250。 <code>/xqserial_server/IMU</code>的协方差矩阵没有处理，所以元素全是0</p><h2 id="走正方形测里程计的累计误差"><a href="#走正方形测里程计的累计误差" class="headerlink" title="走正方形测里程计的累计误差"></a>走正方形测里程计的累计误差</h2><p>机器人直接走正方形的程序</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun nav_test nav_square.py</span><br></pre></td></tr></table></figure><p>但是我们需要先修改这个文件，因为默认的有问题。打开文件，头部添加：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PyKDL</span><br><span class="line"><span class="keyword">import</span> math</span><br></pre></td></tr></table></figure><p>紧接着添加下面内容，也就是在<code>class NavSquare():</code>之前：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quat_to_angle</span><span class="params">(quat)</span>:</span></span><br><span class="line">  rot = PyKDL.Rotation.Quaternion(quat.x, quat.y, quat.z, quat.w)</span><br><span class="line">  <span class="keyword">return</span> rot.GetRPY()[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize_angle</span><span class="params">(angle)</span>:</span></span><br><span class="line">    res = angle</span><br><span class="line">    <span class="keyword">while</span> res &gt; math.pi:</span><br><span class="line">        res -= <span class="number">2.0</span>*math.pi</span><br><span class="line">    <span class="keyword">while</span> res &lt; -math.pi:</span><br><span class="line">        res += <span class="number">2.0</span>*math.pi</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>将线速度改为0.15，角速度0.15，原来的实在太大了</p><p>从网上下载<code>rbx1</code>工程，这是一本教程里用到的，只把其中的<code>rbx1_nav</code>放到当前工作空间里，编译通过。</p><p>现在就可以运行了，走正方形的效果如下：<br><img src="https://i.loli.net/2020/05/21/Z5NEudsMn28SCwi.png" alt="不经过不平的地面.png"><br><img src="https://i.loli.net/2020/05/21/qSVAZtUBad7yGD5.png" alt="经过不平的地面.png"><br>第一张图的左侧经过了一段不平的地面，明显效果不如第二张</p><p>使用robot_pose_ekf的融合里程计进行测试，对比同样平地上的结果：<br><img src="https://i.loli.net/2020/05/23/wEq15AkFvpBShNQ.png" alt="连走4圈.png"><br><img src="https://i.loli.net/2020/05/23/ZQGK2bdo6MAYWSX.png" alt="使用robot_pose_ekf连走四圈.png"></p><h3 id="用move-base走正方形"><a href="#用move-base走正方形" class="headerlink" title="用move_base走正方形"></a>用move_base走正方形</h3><p>教程４里的<code>fake_move_base_blank_map.launch</code>其实是在一个空地图上运行了move_base的一套节点,指定odom和map坐标系的转换全是0,也就是重合. 对代价地图和算法的配置不必关心. <code>square.py</code>是让机器人以全局路径算法，从当前位置开始向前、向左走一个正方形，每次走一米。<strong>所以走得不是严格正方形</strong></p><p>我写了一个程序，当机器人以odom为固定坐标系，base_link相对其运动时，显示运动的轨迹。再配合<code>square.py</code>，可以显示出小强走正方形的轨迹，连续走四次的轨迹如下：</p><p><img src="https://i.loli.net/2020/05/19/Yh8NTnKbqDB63RA.png" alt="第1圈"><br><img src="https://i.loli.net/2020/05/19/Z6XodwYjH5ibkvQ.png" alt="第2圈"><br><img src="https://i.loli.net/2020/05/19/GL6XYc1UAmD29hb.png" alt="第3圈"><br><img src="https://i.loli.net/2020/05/19/2iCd9ZPt3Gz6Wsf.png" alt="第4圈"></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/13/Matlab/Matlab加载栅格地图/">Matlab加载栅格地图</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Matlab/">Matlab</a></span><div class="content"><h2 id="实现二进制栅格地图"><a href="#实现二进制栅格地图" class="headerlink" title="实现二进制栅格地图"></a>实现二进制栅格地图</h2><p>The object keeps track of three reference frames: world, local, and, grid. 世界坐标系的原点由<code>GridLocationInWorld</code>决定, which defines the bottom-left corner of the map relative to the world frame. <code>LocalOriginInWorld</code> property specifies the location of the origin of the local frame relative to the world frame. The first grid location with index (1,1) begins in the top-left corner of the grid.</p><p><code>map = binaryOccupancyMap</code> creates a 2-D binary occupancy grid with a width and height of 10m. The default grid resolution is one cell per meter.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">image = imread(<span class="string">'F:\map.pgm'</span>);</span><br><span class="line"><span class="comment">%imshow(image)</span></span><br><span class="line"></span><br><span class="line">imageBW = image &lt; <span class="number">100</span>;</span><br><span class="line">map = binaryOccupancyMap(imageBW);</span><br><span class="line">show(map)</span><br></pre></td></tr></table></figure><p>读取建好的pgm地图,如果直接<code>imshow</code>，结果就是pgm文件的本来样子</p><p>加下面几句后，结果是这样的<br><img src="https://i.loli.net/2020/05/13/zM1Qrypsm48niHb.png" alt="处理后的栅格地图.png"></p><h2 id="实现栅格地图"><a href="#实现栅格地图" class="headerlink" title="实现栅格地图"></a>实现栅格地图</h2><p><code>occupancyMap</code>对象support local coordinates, world coordinates, and grid indices. The first grid location with index (1,1) begins in the top-left corner of the grid.</p><p>Use the <code>occupancyMap</code> class to create 2-D maps of an environment with probability values representing different obstacles in your world. You can specify exact probability values of cells or include observations from sensors such as laser scanners.</p><p>Probability values are stored using a <code>binary Bayes filter</code> to estimate the occupancy of each grid cell. A log-odds representation is used, with values stored as int16 to reduce the map storage size and allow for real-time applications.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image = imread(&apos;F:\map.pgm&apos;);</span><br><span class="line">imageNorm = double(image)/255;</span><br><span class="line">imageOccupancy = 1 - imageNorm;</span><br><span class="line">map = occupancyMap(imageOccupancy,20);</span><br><span class="line">show(map)</span><br></pre></td></tr></table></figure><p>pgm文件中的值是<code>0~255</code>的uint8类型，将其归一化:先转为double类型,再除以255. 图片中的障碍物对应值为0,应该用1减去它,这样1就代表障碍物了. 否则图片显示出来是一团黑.</p><p>使用<code>occupancyMap</code>函数创建栅格地图,分辨率为1米20个cell,所支持的分辨率极限是±0.001</p><h2 id="读取雷达扫描结果"><a href="#读取雷达扫描结果" class="headerlink" title="读取雷达扫描结果"></a>读取雷达扫描结果</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建一个空地图,宽和高依次为10m,分辨率20,也就是1米有20个cell</span></span><br><span class="line">map = occupancyMap(10,10,20);</span><br><span class="line"><span class="comment"># 机器人位姿[x,y,theta]</span></span><br><span class="line">pose = [5,5,pi/2];</span><br><span class="line"><span class="comment"># ones函数是生成100行1列的矩阵, 元素全是1, 又都乘以3</span></span><br><span class="line"><span class="comment"># ones(n)函数是生成nXn的矩阵</span></span><br><span class="line">ranges = 3*ones(100,1);</span><br><span class="line">angles = linspace(-pi/2,pi/2,100);</span><br><span class="line">maxrange = 20;</span><br><span class="line">scan = lidarScan(ranges,angles);</span><br><span class="line"><span class="comment"># 把laser scan的数据插入栅格地图</span></span><br><span class="line">insertRay(map,pose,scan,maxrange);</span><br><span class="line"></span><br><span class="line">show(map)</span><br></pre></td></tr></table></figure><p>linspace(x,y,n)是Matlab中的一个指令，用于产生x,y之间n点行矢量。其中x是起始值、y是中止值，n表示元素个数，如果缺省，则<strong>默认n为100。</strong></p><p>linspace(1,10,2)为<code>1，10</code>. linspace(1,10,4)为<code>1，4，7，10</code></p><h3 id="laserScan对象"><a href="#laserScan对象" class="headerlink" title="laserScan对象"></a>laserScan对象</h3><p>使用laserScan对象作为一些机器人算法的输入,例如matchScans, controllerVFH, monteCarloLocalization.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ranges and angles inputs are vectors of the same length</span></span><br><span class="line">scan = lidarScan(ranges,angles)</span><br><span class="line">scan = lidarScan(cart)</span><br><span class="line">scan = lidarScan(scanMsg) # 从ROS message中创建</span><br></pre></td></tr></table></figure><p><code>plot(scan)</code>可以显示雷达扫描的曲线</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">minRange = <span class="number">0.1</span>;</span><br><span class="line">maxRange = <span class="number">7</span>;</span><br><span class="line">scan2 = removeInvalidData(scan,'RangeLimits',[minRange maxRange]);</span><br><span class="line">hold on</span><br><span class="line">plot(scan2)</span><br></pre></td></tr></table></figure><p>根据指定的范围,移除invalid数据</p><p>参考:<a href="https://www.mathworks.com/help/nav/ref/occupancymap.html" target="_blank" rel="noopener">Matlab occupancy map</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/11/ROS/机器人导航/机器人导航（四）代价地图/">机器人导航（四）代价地图</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/机器人导航/">机器人导航</a></span><div class="content"><p><code>costmap_2D</code>提供了一种2D代价地图的实现方案，该方案利用输入传感器数据，构建数据2D或者3D（依赖于是否使用基于voxel的实现）代价地图。 此外，该包也支持利用map_server初始化代价地图，支持滚动窗口的代价地图，支持参数化订阅和配置传感器主题。<br><img src="https://i.loli.net/2020/05/11/Qba4npCwqmDUfBV.png" alt="matlab仿真路径和栅格地图.png"></p><p>costmap_2d包中，StaticLayer（静态地图层）是第一层，ObstacleLayer（障碍物层）是第二层，InflationLayer（膨胀层）是第三层。这三层组合成了<strong>master map</strong>（最终的costmap），供给路线规划模块使用。文件夹<code>costmap_2d\plugins</code>提供了这三层和voxel层的源文件，<code>costmap_2d</code>包中的<code>costmap_plugins.xml</code>定义了这几层和<code>VoxelLayer</code>。</p><p>我自己定义的障碍物也可以是一层，假如我不想让机器人通过一个freespace就可以自己插入个障碍物，主要的接口是costmap_2d::Costmap2DROS，在每一层中使用pluginlib实例化Costmap2DROS并将每一层添加到LayeredCostmap，各个层可以被独立的编译。写法模仿<code>obstacle_layer.cpp</code>，在CMakeLists里添加后，一起编译成<code>liblayers.so</code></p><p><img src="https://i.loli.net/2020/05/11/zo8bKCJ1DuSBewN.png" alt="costmap中各Layer之间的继承关系"></p><p><code>costmap_2d::Costmap2DROS</code>给用户提供了纯2D的接口，这意味着查询障碍只能在列上进行，它使用<code>costmap_2d::LayeredCostmap</code>来跟踪每一层. 每一层在Costmap2DROS中以插件方式被实例化，并被添加到LayeredCostmap. 每一层可以独立编译，且可使用C++接口实现对代价地图的随意修改，即LayerdCostmap为Costmap2DROS（用户接口）提供了加载地图层的插件机制，每个插件（即地图层）都是Layer类型的.</p><p><code>rotate_recovery</code>, <code>move_base</code>, <code>move_slow_and_clear</code>, <code>global_planner</code>, <code>clear_costmap_recovery</code>(这个库又在move_base中调用), <code>dwa_local_planner</code>, <code>base_local_planner</code>都使用了<strong>libcostmap_2d.so</strong>这个库</p><p><code>src</code>文件夹中的<code>costmap_2d_markers.cpp</code>, <code>costmap_2d_cloud.cpp</code>, <code>costmap_2d_node.cpp</code>各自编译成一个可执行文件,其余文件联合编译成库文件<code>libcostmap_2d.so</code></p><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><h3 id="move-base里初始化全局代价地图"><a href="#move-base里初始化全局代价地图" class="headerlink" title="move_base里初始化全局代价地图"></a>move_base里初始化全局代价地图</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">planner_costmap_ros_ = <span class="keyword">new</span> costmap_2d::Costmap2DROS(<span class="string">"global_costmap"</span>, tf_);</span><br><span class="line"><span class="comment">// 只有两行，类成员变量赋值： stop_updates_ = true;  initialized_ = false;</span></span><br><span class="line">planner_costmap_ros_-&gt;pause();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略... 初始化global_planner </span></span><br><span class="line"><span class="comment">// 很简单的代码，对各层地图插件调用activate函数，激活各层地图</span></span><br><span class="line">planner_costmap_ros_-&gt;start();</span><br></pre></td></tr></table></figure><h2 id="构造函数-Costmap2DROS-Costmap2DROS"><a href="#构造函数-Costmap2DROS-Costmap2DROS" class="headerlink" title="构造函数 Costmap2DROS::Costmap2DROS"></a>构造函数 Costmap2DROS::Costmap2DROS</h2><h3 id="获取参数值和tf变换"><a href="#获取参数值和tf变换" class="headerlink" title="获取参数值和tf变换"></a>获取参数值和tf变换</h3><p>首先是一些参数的获取。循环等待直到获得机器人底盘坐标系和global系之间的坐标转换。<br>并获取rolling_window、track_unknown_space、always_send_full_costmap的参数，默认为false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">Costmap2DROS::Costmap2DROS(<span class="built_in">std</span>::<span class="built_in">string</span> name, tf::TransformListener&amp; tf) :</span><br><span class="line">    layered_costmap_(<span class="literal">NULL</span>),</span><br><span class="line">    name_(name),</span><br><span class="line">    tf_(tf),</span><br><span class="line">    transform_tolerance_(<span class="number">0.3</span>),</span><br><span class="line">    map_update_thread_shutdown_(<span class="literal">false</span>),</span><br><span class="line">    stop_updates_(<span class="literal">false</span>),</span><br><span class="line">    initialized_(<span class="literal">true</span>),</span><br><span class="line">    stopped_(<span class="literal">false</span>),</span><br><span class="line">    robot_stopped_(<span class="literal">false</span>),</span><br><span class="line">    map_update_thread_(<span class="literal">NULL</span>),</span><br><span class="line">    last_publish_(<span class="number">0</span>),</span><br><span class="line">    plugin_loader_(<span class="string">"costmap_2d"</span>, <span class="string">"costmap_2d::Layer"</span>),</span><br><span class="line">    publisher_(<span class="literal">NULL</span>),</span><br><span class="line">    dsrv_(<span class="literal">NULL</span>),</span><br><span class="line">    footprint_padding_(<span class="number">0.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化old pose</span></span><br><span class="line">  old_pose_.setIdentity();</span><br><span class="line">  old_pose_.setOrigin(tf::Vector3(<span class="number">1e30</span>, <span class="number">1e30</span>, <span class="number">1e30</span>));</span><br><span class="line">  <span class="comment">// 如果是全局代价地图，这里name是global_costmap</span></span><br><span class="line">  ros::<span class="function">NodeHandle <span class="title">private_nh</span><span class="params">(<span class="string">"~/"</span> + name)</span></span>;</span><br><span class="line">  ros::NodeHandle g_nh;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取tf前缀</span></span><br><span class="line">  ros::NodeHandle prefix_nh;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> tf_prefix = tf::getPrefixParam(prefix_nh);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//两个坐标系，全局和局部的参数是不同的</span></span><br><span class="line">  private_nh.param(<span class="string">"global_frame"</span>, global_frame_, <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"/map"</span>));</span><br><span class="line">  private_nh.param(<span class="string">"robot_base_frame"</span>, robot_base_frame_, <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"base_link"</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//确保基于tf前缀正确设置了坐标系</span></span><br><span class="line">  <span class="comment">//注：tf::resolve或者TransformListener::resolve方法的作用就是使用tf_prefix参数将frame_name解析为frame_id</span></span><br><span class="line">  global_frame_ = tf::resolve(tf_prefix, global_frame_);</span><br><span class="line">  robot_base_frame_ = tf::resolve(tf_prefix, robot_base_frame_);</span><br><span class="line"></span><br><span class="line">  ros::Time last_error = ros::Time::now();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> tf_error;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//确保机器人底盘坐标系和世界坐标系之间的有效转换, 否则一直停留在这里阻塞</span></span><br><span class="line">  <span class="keyword">while</span> (ros::ok()</span><br><span class="line">      &amp;&amp; !tf_.waitForTransform(global_frame_, robot_base_frame_, ros::Time(), ros::Duration(<span class="number">0.1</span>), ros::Duration(<span class="number">0.01</span>), &amp;tf_error))</span><br><span class="line">  &#123;</span><br><span class="line">    ros::spinOnce();</span><br><span class="line">    <span class="comment">// 如果５秒内未成功tf转换，报警</span></span><br><span class="line">    <span class="keyword">if</span> (last_error + ros::Duration(<span class="number">5.0</span>) &lt; ros::Time::now())</span><br><span class="line">    &#123;</span><br><span class="line">      ROS_WARN(<span class="string">"Timed out waiting for transform from %s to %s to become available before running costmap, tf error: %s"</span>,</span><br><span class="line">               robot_base_frame_.c_str(), global_frame_.c_str(), tf_error.c_str());</span><br><span class="line">      last_error = ros::Time::now();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The error string will accumulate and errors will typically be the same, so the last</span></span><br><span class="line">    <span class="comment">// will do for the warning above. Reset the string here to avoid accumulation.</span></span><br><span class="line">    tf_error.clear();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//检测是否需要“窗口滚动”，从参数服务器获取以下参数</span></span><br><span class="line">  <span class="keyword">bool</span> rolling_window, track_unknown_space, always_send_full_costmap;</span><br><span class="line">  private_nh.param(<span class="string">"rolling_window"</span>, rolling_window, <span class="literal">false</span>);</span><br><span class="line">  private_nh.param(<span class="string">"track_unknown_space"</span>, track_unknown_space, <span class="literal">false</span>);</span><br><span class="line">  private_nh.param(<span class="string">"always_send_full_costmap"</span>, always_send_full_costmap, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="LayeredCostmap类的对象"><a href="#LayeredCostmap类的对象" class="headerlink" title="LayeredCostmap类的对象"></a>LayeredCostmap类的对象</h3><p>接下来创建一个<code>LayeredCostmap</code>类实例<code>layered_costmap_</code>，作为规划器使用的主地图，并通过它管理各层地图。</p><p><code>LayeredCostmap</code>类是Costmap2DROS的类成员，它是<strong>主地图</strong>，也能够管理各层地图，因为它含有指向各层子地图的指针<code>std::vector&lt;boost::shared_ptr&lt;Layer&gt; &gt; plugins_</code>，能够调用子地图的类方法，开启子地图的更新，各层子地图最后都会合并到主地图上，提供给规划器的使用。</p><p><code>LayeredCostmap</code>含有类成员<code>Costmap2D costmap_</code>，这个类就是底层地图，用于记录地图数据。它的构造函数只有:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (track_unknown) 	<span class="comment">// 如果追踪未知信息的cell</span></span><br><span class="line">	costmap_.setDefaultValue(<span class="number">255</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	costmap_.setDefaultValue(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举值的含义对应如下：</span></span><br><span class="line"><span class="comment">/*	NO_INFORMATION = 255;</span></span><br><span class="line"><span class="comment">	LETHAL_OBSTACLE = 254;</span></span><br><span class="line"><span class="comment">	INSCRIBED_INFLATED_OBSTACLE = 253;</span></span><br><span class="line"><span class="comment">	FREE_SPACE = 0;*/</span></span><br></pre></td></tr></table></figure><p>继续Costmap2DROS的构造函数代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">layered_costmap_ = <span class="keyword">new</span> LayeredCostmap(global_frame_, rolling_window, track_unknown_space);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看参数服务器里的costmap是否有plugins参数，如果没有，则重置为旧参数</span></span><br><span class="line"><span class="keyword">if</span> (!private_nh.hasParam(<span class="string">"plugins"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    resetOldParameters(private_nh);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果加载了plugins，循环将每个plugin即每层子地图添加进layered_costmap_类的指针组对象中，并对每层地图调用其initialize类方法，初始化各层地图。</span></span><br><span class="line"><span class="keyword">if</span> (private_nh.hasParam(<span class="string">"plugins"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    XmlRpc::XmlRpcValue my_list;</span><br><span class="line">    private_nh.getParam(<span class="string">"plugins"</span>, my_list);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int32_t</span> i = <span class="number">0</span>; i &lt; my_list.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> pname = <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(my_list[i][<span class="string">"name"</span>]);</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> type = <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(my_list[i][<span class="string">"type"</span>]);</span><br><span class="line">      ROS_INFO(<span class="string">"Using plugin \"%s\""</span>, pname.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// plugin_loader_类型是　pluginlib::ClassLoader&lt;Layer&gt;，ROS插件机制</span></span><br><span class="line">      boost::<span class="built_in">shared_ptr</span>&lt;Layer&gt; plugin = plugin_loader_.createInstance(type);</span><br><span class="line">      <span class="comment">// 添加到容器 plugins_</span></span><br><span class="line">      layered_costmap_-&gt;addPlugin(plugin);</span><br><span class="line">      <span class="comment">// 执行 Layer::initialize，它向各层地图通知主地图的存在，并调用oninitialize方法（Layer类中的虚函数，被定义在各层地图中）</span></span><br><span class="line">      plugin-&gt;initialize(layered_costmap_, name + <span class="string">"/"</span> + pname, &amp;tf_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里得到的插件即为各层子地图。每层子地图使用Pluginlib（ROS插件机制）来实例化，各个层可以被独立的编译，且允许使用C++接口对Costmap做出任意的改变。</p><h3 id="footprint话题"><a href="#footprint话题" class="headerlink" title="footprint话题"></a>footprint话题</h3><p>订阅footprint话题，回调函数为setUnpaddedRobotFootprintPolygon。当话题上收到footprint时，回调函数会将接收到的footprint根据参数<code>footprint_padding_</code>的值进行<strong>膨胀</strong>，得到“膨胀”后的<code>padded_footprint_</code>，传递给各级地图。</p><p>查看节点可知，<code>/move_base/local_costmap/footprint</code>和<code>/move_base/global_costmap/footprint</code>两个话题的发布订阅者都是move_base</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> topic_param, topic;</span><br><span class="line"><span class="keyword">if</span> (!private_nh.searchParam(<span class="string">"footprint_topic"</span>, topic_param))</span><br><span class="line">&#123;</span><br><span class="line">  topic_param = <span class="string">"footprint_topic"</span>;</span><br><span class="line">&#125;</span><br><span class="line">private_nh.param(topic_param, topic, <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"footprint"</span>));</span><br><span class="line">footprint_sub_ = private_nh.subscribe(topic, <span class="number">1</span>, &amp;Costmap2DROS::setUnpaddedRobotFootprintPolygon, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!private_nh.searchParam(<span class="string">"published_footprint_topic"</span>, topic_param))</span><br><span class="line">&#123;</span><br><span class="line">  topic_param = <span class="string">"published_footprint"</span>;</span><br><span class="line">&#125;</span><br><span class="line">private_nh.param(topic_param, topic, <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"oriented_footprint"</span>));</span><br><span class="line">footprint_pub_ = private_nh.advertise&lt;geometry_msgs::PolygonStamped&gt;(<span class="string">"footprint"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">setUnpaddedRobotFootprint(makeFootprintFromParams(private_nh));</span><br></pre></td></tr></table></figure><br><h3 id="发布代价地图"><a href="#发布代价地图" class="headerlink" title="发布代价地图"></a>发布代价地图</h3><p>创建地图的发布器实例,<code>Costmap2DPublisher</code>类是用于地图发布的封装类,在函数<code>mapUpdateLoop</code>中调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发布Costmap2D</span></span><br><span class="line">publisher_ = <span class="keyword">new</span> Costmap2DPublisher(&amp;private_nh, layered_costmap_-&gt;getCostmap(), global_frame_, <span class="string">"costmap"</span>, always_send_full_costmap);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建地图更新线程的控制量</span></span><br><span class="line">stop_updates_ = <span class="literal">false</span>;</span><br><span class="line">initialized_ = <span class="literal">true</span>;</span><br><span class="line">stopped_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个timer去检测机器人是否在移动</span></span><br><span class="line">robot_stopped_ = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//回调函数movementCB通过比较前后两个pose的差来判断机器人是否在移动</span></span><br><span class="line">timer_ = private_nh.createTimer(ros::Duration(<span class="number">.1</span>), &amp;Costmap2DROS::movementCB, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>开启动态参数配置，它的回调函数Costmap2DROS::reconfigureCB会在节点启动时运行一次，加载.cfg文件的配置参数。这个函数给对应参数赋值，并创建了一个<code>Costmap2DROS::mapUpdateLoop</code>函数的线程，即地图更新线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启参数动态配置</span></span><br><span class="line">  dsrv_ = <span class="keyword">new</span> dynamic_reconfigure::Server&lt;Costmap2DConfig&gt;(ros::NodeHandle(<span class="string">"~/"</span> + name));</span><br><span class="line">  <span class="comment">//回调函数reconfigureCB 除了对一些类成员的配置值做赋值以外，还会开启一个更新map的线程 </span></span><br><span class="line">  dynamic_reconfigure::Server&lt;Costmap2DConfig&gt;::CallbackType cb = boost::bind(&amp;Costmap2DROS::reconfigureCB, <span class="keyword">this</span>, _1,_2);</span><br><span class="line">  dsrv_-&gt;setCallback(cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码有点复杂了，<code>mapUpdateLoop</code>函数循环调用<code>UpdateMap</code>函数，更新地图。并以publish_cycle为周期，发布更新后的地图。</p><p><code>UpdateMap</code>首先调用类内getRobotPose函数，通过tf转换，将机器人底盘系的坐标转换到global系，得到机器人的位姿。然后通过<code>layered_costmap_</code>调用LayeredCostmap类的updateMap函数，更新地图。</p><p>流程如下<br><img src="https://i.loli.net/2020/05/13/4R5iKrCghHZ7cwd.png" alt="costmap的初始化流程.png"></p><p>整个costmap初始化，最关键和复杂的就是各层的加载和更新地图</p></div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/42/">42</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image:url(https://i.loli.net/2020/07/13/QgyrefaLDxhBWSZ.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>