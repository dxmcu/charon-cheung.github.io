<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="C++笔试题（一）"><meta name="keywords" content><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>C++笔试题（一） | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG={root:"/",algolia:{appId:"RI90VLL69D",apiKey:"20c535e9a1424a7913210eb747d6e67b",indexName:"HexoBlog",hits:{per_page:10},languages:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}.",hits_stats:"${hits} results found in ${time} ms"}},localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#形参与实参"><span class="toc-number">1.</span> <span class="toc-text">形参与实参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指针的运算"><span class="toc-number">2.</span> <span class="toc-text">指针的运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-生成可执行文件的过程"><span class="toc-number">3.</span> <span class="toc-text">c++生成可执行文件的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逗号表达式不能有空表达式"><span class="toc-number">4.</span> <span class="toc-text">逗号表达式不能有空表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运算符的优先级"><span class="toc-number">5.</span> <span class="toc-text">运算符的优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#预处理"><span class="toc-number">6.</span> <span class="toc-text">预处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常量折叠"><span class="toc-number">7.</span> <span class="toc-text">常量折叠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#和"><span class="toc-number">8.</span> <span class="toc-text">%和/</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#格式"><span class="toc-number">9.</span> <span class="toc-text">%格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指针常量和常量指针"><span class="toc-number">10.</span> <span class="toc-text">指针常量和常量指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二维数组"><span class="toc-number">11.</span> <span class="toc-text">二维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#联合体union"><span class="toc-number">12.</span> <span class="toc-text">联合体union</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#科学计数法"><span class="toc-number">13.</span> <span class="toc-text">科学计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数做循环条件"><span class="toc-number">14.</span> <span class="toc-text">函数做循环条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#宏"><span class="toc-number">15.</span> <span class="toc-text">宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#override"><span class="toc-number">16.</span> <span class="toc-text">override</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数缺少参数-默认实参"><span class="toc-number">17.</span> <span class="toc-text">函数缺少参数/默认实参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#大端和小端"><span class="toc-number">18.</span> <span class="toc-text">大端和小端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#柔性数组char-a-0"><span class="toc-number">19.</span> <span class="toc-text">柔性数组char a[0]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#空类和空结构体"><span class="toc-number">20.</span> <span class="toc-text">空类和空结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态变量和静态函数"><span class="toc-number">21.</span> <span class="toc-text">静态变量和静态函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sizeof与strlen"><span class="toc-number">22.</span> <span class="toc-text">sizeof与strlen</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#溢出时的计算"><span class="toc-number">23.</span> <span class="toc-text">溢出时的计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数的隐式转换"><span class="toc-number">24.</span> <span class="toc-text">构造函数的隐式转换</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">313</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">35</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://live.staticflickr.com/65535/48055510011_577ff62eaf_b.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">C++笔试题（一）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-19</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/面试笔试/">面试笔试</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2018/07/19/笔试面试/C++笔试题（一）/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2018/07/19/笔试面试/C++笔试题（一）/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3k</span><span class="post-meta__separator">|</span><span>Reading time: 11 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h3 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h3><p>形式参数：定义函数时函数名后括号中的变量名。实际参数：调用函数时函数名后括号中的表达式。<br>1.形参是变量，未被调用时，不占存储单元，调用过程中占用存储单元。<br>2.实参可以是常量、变量或者表达式，要与形参类型一致，而且实参要有确定的值，占用储存单元。<br>3.C++中实参对形参数据传递是单向的值传递，在存储单元中是不同的单元。<br>比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int sum(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m=1,n=2;</span><br><span class="line">    int c = sum(m,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a,b是形参，m和n是实参，如果换成1和2就成了常量做实参，如果是m+n就成了表达式做实参。</p><h3 id="指针的运算"><a href="#指针的运算" class="headerlink" title="指针的运算"></a>指针的运算</h3><p>指针也可以做算术运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int a[3];</span><br><span class="line">a[0]=0;a[1]=1;a[2]=2;</span><br><span class="line">int *p,*q;</span><br><span class="line">p=a;</span><br><span class="line">q=&amp;a[2];</span><br><span class="line">cout&lt;&lt;q&lt;&lt;&quot;  &quot;&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;q+1:&quot;&lt;&lt;q+1&lt;&lt;endl;    //原来的地址值加上指向对象占用的字节数</span><br><span class="line">cout&lt;&lt;q-p&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00CFFCD4  00CFFCCC</span><br><span class="line">q+1:00CFFCD8</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>指针q+1不是只加个1，而是加1个指向对象所占字节数。比较诡异的是q-p，分开q和p可以看到二者之差是8，但相减得到的是相差多少个所指对象的字节数，这是由编译器实现的。</p><h3 id="c-生成可执行文件的过程"><a href="#c-生成可执行文件的过程" class="headerlink" title="c++生成可执行文件的过程"></a>c++生成可执行文件的过程</h3><p>预处理——编译——汇编——链接</p><p>预处理：头文件展开，宏替换，去掉注释，条件编译的选择。所有以#开头的都是预处理命令。每行只能有一个预处理命令。宏替换占用的是编译时间。<br>编译：词法和语法分析，生成s文件。决定const变量是只读的。<br>汇编：编程二进制文件obj<br>链接：把一个个目标文件链接生成exe文件，可发现函数是否有定义</p><h3 id="逗号表达式不能有空表达式"><a href="#逗号表达式不能有空表达式" class="headerlink" title="逗号表达式不能有空表达式"></a>逗号表达式不能有空表达式</h3><p><code>int ma= (1+2,3+4);</code>是对的，但<code>int ma= (1+2, ,3+4);</code>是错的。</p><h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a[]=&#123;1,22,33,44,55&#125;;</span><br><span class="line">int *p=a;</span><br><span class="line">std::cout&lt;&lt;*p&lt;&lt;endl;	//1</span><br><span class="line">std::cout&lt;&lt;*p++&lt;&lt;endl;	//1</span><br><span class="line">std::cout&lt;&lt;*p+2&lt;&lt;endl;	// 24</span><br><span class="line">std::cout&lt;&lt;*(p+2)&lt;&lt;endl;	// 44</span><br></pre></td></tr></table></figure><p>优先级顺序: 自增减 &gt; * &gt; 加减法，所以<code>*p+2</code>和<code>*(p+2)</code>是不同的。</p><p>计算<code>1&lt;&lt;3+2</code>，由于加号的优先级大于&lt;&lt;，所以是<code>1&lt;&lt;5</code>，为32。</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>源程序中凡是以#开头的命令都是预处理命令，一般独占一行，但可以用<code>\</code>表示换行。包括头文件包含、宏定义、条件编译。</p><h3 id="常量折叠"><a href="#常量折叠" class="headerlink" title="常量折叠"></a>常量折叠</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*volatile*/ const int i = 0;</span><br><span class="line">int *j = (int *) &amp;i;</span><br><span class="line">*j = 1;</span><br><span class="line">cout&lt;&lt;&quot;i:&quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;*j:&quot;&lt;&lt;*j&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;&amp;i:&quot;&lt;&lt;&amp;i&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;j:&quot;&lt;&lt;j&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>结果为 <code>0,1,14416592,14416592</code>。二者指向同一地址，但i没有跟随改变。如果没有const，i就变为1。<br>在C++中，const变量(即常量)值放在编译器的符号表中，计算时编译器直接从表中取值，而不是访问内存，省去了访问内存的时间，这也就是所谓的编译器优化。<br>volatile关键字，告诉编译器不要对这样的对象进行优化，所以加上volatile之后，会强制从内存中取值，i会变成1。</p><p>参考: <a href="https://blog.csdn.net/misayaaaaa/article/details/69432679" target="_blank" rel="noopener">C++ 常量折叠问题的理解</a></p><h3 id="和"><a href="#和" class="headerlink" title="%和/"></a>%和/</h3><p>%的两个操作数都必须为整数，且右操作数不能为0。/的两个操作数可以不是整数，且右操作数不能为0。</p><h3 id="格式"><a href="#格式" class="headerlink" title="%格式"></a>%格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%5.3s\n&quot;,&quot;computer&quot;);</span><br></pre></td></tr></table></figure><p>结果是<code>com</code>，<code>%m.ns</code>输出占m列，但只取字符串中左端n个字符。这n个字符输出在m列的右侧，左补空格。</p><h3 id="指针常量和常量指针"><a href="#指针常量和常量指针" class="headerlink" title="指针常量和常量指针"></a>指针常量和常量指针</h3><p>这两个名词之所以难记，跟翻译有很大关系。这种组合一共有6种写法，前四种比较常见:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">①const int p;</span><br><span class="line"></span><br><span class="line">②const int* p;</span><br><span class="line">③int const* p;</span><br><span class="line"></span><br><span class="line">④int * const p;</span><br><span class="line"></span><br><span class="line">⑤const int * const p;</span><br><span class="line">⑥int const * const p;</span><br></pre></td></tr></table></figure><p>如此记忆：对表达式从右往左读，遇到p就替换成<code>p is a</code>，遇到<code>*</code>就替换成<code>point to</code>。所以②读作<code>p is a point to int const</code>，p是指向常量的指针，而③也一样。④读作<code>p is a const point to int</code>，p是指向整型的常量指针。</p><p>对于指向常量的指针，指针可以指向其他地址，但所指整型的值不能更改。指向整型的常量指针，指针不能指向其他地址，但所指整型的值可以更改。</p><p>测试代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const int v=12;</span><br><span class="line">int c = 25;</span><br><span class="line">const int *p1 = &amp;v;</span><br><span class="line">int *const p2 = &amp;c;</span><br><span class="line">*p2=15;</span><br></pre></td></tr></table></figure><p>p1是指向常量的指针，可以指向v也可以指向c，但指向c后无法更改值，也就是说<code>const int *p1 = &amp;c; *p1=15;</code>是错的，还不如指向v。<br>p2是指向整型的常量指针，所指的值可以修改，因此<code>*p2=15;</code>是正确的，但再运行下面的代码是错误的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int d=8;</span><br><span class="line">p2 = &amp;d;</span><br></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>声明二维数组可以省略第一维的定义，但不能省略第二维。例如<code>int arr[][3]</code>是正确的。可以认为a[m][n]有m行n列。</p><h3 id="联合体union"><a href="#联合体union" class="headerlink" title="联合体union"></a>联合体union</h3><p>联合体的成员都共用一个内存首地址，共用一段内存空间。各变量可以同时操作，同一时间只能存储一个被选择的变量，对其他成员变量赋值会覆盖原变量。定义时可以初始化。<br>联合体所占内存大小是最大成员变量的，但又要是其他成员所占字节的整数倍，但如果指定字节对齐就得做变更。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">union NUM</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    long b;</span><br><span class="line">    char c[13];</span><br><span class="line">    char d;</span><br><span class="line">&#125; num;			// num可以做实参</span><br><span class="line">std::cout&lt;&lt;sizeof(num)&lt;&lt;endl;   //16，先是13，然后又要是8的整数倍</span><br><span class="line">num.a = 4;	//第一种使用方式</span><br><span class="line">std::cout&lt;&lt;num.b&lt;&lt;endl;	  // 也成了4</span><br><span class="line">printf(&quot;%d\n&quot;,num.d);	  // 也是4，其实c[0]的算术值也是4</span><br><span class="line"></span><br><span class="line">union NUM data;	    //第二种使用方式</span><br><span class="line">data.c[0] = 0x04;  //因为是char类型，数字不要太大</span><br><span class="line">data.c[1] = 0x03;</span><br><span class="line">data.c[2] = 0x02;</span><br><span class="line">data.c[3] = 0x01;</span><br><span class="line">printf(&quot;a is %x\n&quot;,data.a);	 //小端时输出01020304</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union u&#123;</span><br><span class="line">    char buff[13];</span><br><span class="line">    int a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sizeof的计算根据char数组是13，还需是int的倍数，所以补3是16。但是如果<code>#pragma pack(2)</code>，只需要补1，也就是达到2的倍数14.<br><a href="https://blog.csdn.net/perfectguyipeng/article/details/69787930" target="_blank" rel="noopener">使用sizeof计算联合体的大小</a></p><h3 id="科学计数法"><a href="#科学计数法" class="headerlink" title="科学计数法"></a>科学计数法</h3><p>浮点常量用科学计数法表示时，指数可写作e或E，但之后必须是整数。如1.23e4, 5.3E-2。不能是<br>表达式，<code>3e(1+4)</code>是错的。e前面必须有数字，<code>12.e4</code>是错的。</p><h3 id="函数做循环条件"><a href="#函数做循环条件" class="headerlink" title="函数做循环条件"></a>函数做循环条件</h3><p>for循环条件部分的函数每次都要运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int func()</span><br><span class="line">&#123;</span><br><span class="line">    qDebug()&lt;&lt;&quot;func&quot;;</span><br><span class="line">    return 5;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;func();i++)</span><br><span class="line">    int a=2;</span><br></pre></td></tr></table></figure><p>会输出6次<code>func</code>，有时会增加程序所占用的CPU和内存，所以最好先赋给某个变量</p><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>空宏的作用：1. 增强代码可读性 2. 条件编译</p><p><code>##</code>的作用是附加关键字名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define ABC(a) a##foo</span><br><span class="line">int ABC(e);		//声明变量为efoo;</span><br></pre></td></tr></table></figure><h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>override关键字在c++ 11里才出现，很多情况下，可用可不用，只有在容易产生歧义的地方才使用。<br>明确地表示一个函数是对基类中一个虚函数的重载。它会检查基类虚函数和派生类中重载函数的签名不匹配问题。</p><h3 id="函数缺少参数-默认实参"><a href="#函数缺少参数-默认实参" class="headerlink" title="函数缺少参数/默认实参"></a>函数缺少参数/默认实参</h3><p>&emsp;&emsp;在函数声明或者定义中指定默认实参皆可，但要么在声明中指定，要么在定义中指定，而不能两者都指定，否则报错。<br>一般地，在头文件的函数声明中指定默认实参，这样在每个包含了该头文件的文件中调用该函数都能使用默认实参.</p><p>例如声明：<code>void out(int a, int b=5);</code><br>调用时可以使用： <code>out(5,2);</code> 或 <code>out(5);</code><br>前者会覆盖b=5；<br>以下声明是错误的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void test(int a=12, int b);</span><br></pre></td></tr></table></figure><p>一旦为某个形参定义了默认实参，必须之后的形参都要定义，否则报错：<font color="red"> error: default argument missing for parameter 2 of ‘void test(int, int)’ void test(int a=12, int b);</font></p><p>调用时，有三种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this-&gt;test();</span><br><span class="line">this-&gt;test(41,59);</span><br><span class="line">this-&gt;test(100);</span><br></pre></td></tr></table></figure><p>结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:  12    b:  1</span><br><span class="line">a:  41    b:  59</span><br><span class="line">a:  100    b:  1</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：调用带有默认实参的函数时，一旦从某个位置开始使用了默认实参，则之后的每个形参都不要再传递实参，而使用默认实参，否则报错。</p><h3 id="大端和小端"><a href="#大端和小端" class="headerlink" title="大端和小端"></a>大端和小端</h3><p>小端：内存的低地址存放数据的低位，高地址存放数据的高位<br>大端：内存的低地址存放数据的低位，高地址存放数据的高位<br>以<code>unsigned int value = 0x12345678</code>为例，如果是小端则低地址存放<code>0x78</code>，大端则低地址存放<code>0x12</code>。</p><p>测试代码，用单字节字符变量存放一个字符数据，根据结果判断当前环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 0x1207;</span><br><span class="line">char b1 =  *(char *)&amp;a;</span><br><span class="line">printf(&quot;%d\n&quot;,b);	// 输出7就是小端，输出1则为大端</span><br></pre></td></tr></table></figure><p>一般操作系统都是小端，而网络通讯协议是大端的。</p><h3 id="柔性数组char-a-0"><a href="#柔性数组char-a-0" class="headerlink" title="柔性数组char a[0]"></a>柔性数组char a[0]</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char a[0];</span><br><span class="line">std::cout&lt;&lt;sizeof(a)&lt;&lt;endl;	 // 0</span><br></pre></td></tr></table></figure><p>柔性数组一般被编译器认为长度为0，但有些编译器会报错！主要用于可变长度的结构体，在结构体的最后声明长度为0的数组，可以使这个结构体的大小动态可变，可以构造出缓冲区、数据包等结构体。</p><h3 id="空类和空结构体"><a href="#空类和空结构体" class="headerlink" title="空类和空结构体"></a>空类和空结构体</h3><p>一个类或结构体中没有声明任何成员变量与函数，那么其sizeof值为1，这是被编译器插进去一个char，使这个类或结构体有独一无二的地址，否则无法区分。</p><h3 id="静态变量和静态函数"><a href="#静态变量和静态函数" class="headerlink" title="静态变量和静态函数"></a>静态变量和静态函数</h3><p><a href="https://rjosodtssp.github.io/2018/07/26/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">我的博客的分析</a></p><h3 id="sizeof与strlen"><a href="#sizeof与strlen" class="headerlink" title="sizeof与strlen"></a>sizeof与strlen</h3><p>对字符串用sizeof时，需要考虑·<code>\0</code>；用<code>strlen</code>（长度）时不用考虑，所以前者比后者大1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char a[]=&quot;12345&quot;;</span><br><span class="line">cout&lt;&lt;sizeof(a)&lt;&lt;&quot;  &quot;&lt;&lt;strlen(a)&lt;&lt;endl;  //6   5</span><br></pre></td></tr></table></figure><h3 id="溢出时的计算"><a href="#溢出时的计算" class="headerlink" title="溢出时的计算"></a>溢出时的计算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char a=101;</span><br><span class="line">int sum=200;</span><br><span class="line">a+=57;</span><br><span class="line">sum+=a;</span><br><span class="line">printf(&quot;%d\n&quot;,sum);		//102</span><br></pre></td></tr></table></figure><p>char的范围是<code>-128~127</code>，a得到158后超出范围，应转为补码：158的有符号二进制是<code>1001 1110</code>，转为补码应先取反为<code>0110 0001</code>，再加1得到98，取相反数为-98。sum=200-98=102</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned char i=-1;</span><br><span class="line">printf(&quot;%d\n&quot;,i);     // %u也一样</span><br></pre></td></tr></table></figure><p>unsigned char范围是0~255，-1对应0000 0001，取反为1111 1110，再加1为1111 1111，就是255。或者这样记：<strong>超出范围后，数太大则减256，数太小就加256.</strong></p><h3 id="构造函数的隐式转换"><a href="#构造函数的隐式转换" class="headerlink" title="构造函数的隐式转换"></a>构造函数的隐式转换</h3><p>如果类有个构造函数只有一个参数，那么存在一个隐式转换，赋值时将参数的数据转换为该类的对象，比如String类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class String</span><br><span class="line">&#123;</span><br><span class="line">	public:</span><br><span class="line">	String(const char* p);</span><br><span class="line">	String ( int n );</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们常常这样使用：<code>String s = &quot;abcd&quot;;</code>，这其实就是隐式转换。比较正规的写法应该是<code>String s(&quot;abcd&quot;)</code>;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Base();</span><br><span class="line">    Base(int a);	// 加explicit</span><br><span class="line">&#125;;</span><br><span class="line">Base::Base(int a)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;constructor a:&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">//使用</span><br><span class="line">Base ba = 10;	//输出constructor a:10</span><br></pre></td></tr></table></figure><p>如果声明里加<code>explicit</code>，就会禁止隐式转换，编译会报错:<code>error: C2440: “初始化”:无法从“int”转换为“Base，class“Base”的构造函数声明为“explicit”</code></p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Charon Cheung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://charon-cheung.github.io/2018/07/19/笔试面试/C++笔试题（一）/">https://charon-cheung.github.io/2018/07/19/笔试面试/C++笔试题（一）/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/07/21/C++  面向对象/虚函数详解/"><i class="fa fa-chevron-left"></i><span>深入探究虚函数</span></a></div><div class="next-post pull-right"><a href="/2018/07/19/C++  面向对象/C++中protected访问权限问题/"><span>C++中protected访问权限问题</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused=null,disqus_config=function(){this.page.url="https://charon-cheung.github.io/2018/07/19/笔试面试/C++笔试题（一）/",this.page.identifier="2018/07/19/笔试面试/C++笔试题（一）/",this.page.title="C++笔试题（一）"},d=document,s=d.createElement("script");s.src="https://charon-cheung-github-io.disqus.com/embed.js",s.setAttribute("data-timestamp",""+ +new Date),(d.head||d.body).appendChild(s)</script><script id="dsq-count-scr" src="https://charon-cheung-github-io.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image:url(https://live.staticflickr.com/65535/48055510011_577ff62eaf_b.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>