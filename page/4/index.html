<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>教练，我想当程序员 | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG={root:"/",algolia:{appId:"RI90VLL69D",apiKey:"20c535e9a1424a7913210eb747d6e67b",indexName:"HexoBlog",hits:{per_page:10},languages:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}.",hits_stats:"${hits} results found in ${time} ms"}},localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">320</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">42</span></a></div></div></div><nav id="nav" style="background-image:url(https://live.staticflickr.com/65535/48055510011_577ff62eaf_b.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">教练，我想当程序员</div><div id="site-social-icons"><a class="social-icon" href="https://github.com/charon-cheung"><i class="fa-github fa"></i></a><a class="social-icon search"><i class="fa fa-search"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/14/数学基础/狄拉克函数/">狄拉克函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/数学基础/">数学基础</a></span><div class="content"><p>狄拉克δ函数是在实数线上定义的一个广义函数或分布。它在除零以外的点上都等于零，且其在整个定义域上的积分等于1。δ函数有时可看作是在原点处无限高、无限细，但是总面积为1的一个尖峰。数学定义如下：<br><a href="https://live.staticflickr.com/65535/49383566037_a45a5160f9_w.jpg" target="_blank" rel="noopener"></a><br>上面的f(x)就可以表示为δ(x−x0)</p><p>在许多应用中，均将δ视为由在原点处有尖峰的函数所组成的序列的极限，而序列中的函数则可作为对δ函数的近似</p><p><a href="https://live.staticflickr.com/65535/49382906718_e48a121e8c_z.jpg" target="_blank" rel="noopener"></a><br><a href="https://live.staticflickr.com/65535/49382906683_c9b2102669_w.jpg" target="_blank" rel="noopener"></a><br>到了极限就是这样子：<br><a href="https://live.staticflickr.com/65535/49383566127_bf40c13d92_z.jpg" target="_blank" rel="noopener"></a></p><p>在概率论和统计学中，狄拉克函数往往以概率密度函数的身份，来代表一个离散分布或部分离散、部分连续的分布（概率密度函数一般只用作描述完全连续分布）。例如，设一组点x = {X1, …, Xn}，对应概率为p1, …,pn；由这些点所组成的离散分布的概率密度函数可以写作:<br><a href="https://live.staticflickr.com/65535/49383389511_3b0e719413_n.jpg" target="_blank" rel="noopener"></a><br>根据函数定义，很容易就能证明</p><p>参考：<a href="http://wuli.wiki//online/Delta.html" target="_blank" rel="noopener">狄拉克函数</a><br><a href="https://www.wikiwand.com/zh-cn/%E7%8B%84%E6%8B%89%E5%85%8B%CE%B4%E5%87%BD%E6%95%B0#/%E6%A6%82%E7%8E%87%E8%AB%96_2" target="_blank" rel="noopener">Wiki 狄拉克函数</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/12/激光SLAM/amcl和粒子滤波/amcl源码分析(一) 总体逻辑/">amcl源码分析(一) 总体逻辑</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/amcl和粒子滤波/">amcl和粒子滤波</a></span><div class="content"><p><a href="https://gaoyichao.com/Xiaotu/?book=turtlebot&title=amcl%E7%9A%84%E6%80%BB%E4%BD%93%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91#4" target="_blank" rel="noopener">无处不在的小土这篇文章</a>已经讲得很透彻了，我只补充一些内容和挑一些重点。</p><p><code>sigintHandler</code>回调函数在关闭程序之前只有一句<code>amcl_node_ptr-&gt;savePoseToServer();</code>，也就是关闭前把最近一次的机器人位姿存入参数服务器，这就可以理解为什么关掉程序后，用<code>rosparam get</code>获得的<code>initial_pose_x</code>等位姿仍然是以前的。</p><p><code>amcl</code>根据输入参数来决定运行方式。从代码中可以看到amcl支持数据回放的，运行时只需要通过参数<code>--run-from-bag</code>指定bag文件即可</p><p>从main函数可以看出，amcl的所有业务逻辑都是由AmclNode类的构造函数完成</p><h2 id="AmclNode构造函数"><a href="#AmclNode构造函数" class="headerlink" title="AmclNode构造函数"></a>AmclNode构造函数</h2><p>通过参数服务器，根据launch文件里的大量参数，对各类变量赋值</p><p>成员函数<code>updatePoseFromServer</code>，该函数就是用来从参数服务器上获取机器人的初始位姿和位姿误差的协方差矩阵的。</p><p>发布<code>amcl_pose</code>和<code>particlecloud</code>两个主题，分别用于输出机器人位姿估计和粒子集合。</p><p>接着注册三个服务：<code>global_localization</code>用于获取机器人的全局定位，<code>request_nomotion_update</code>则用于手动的触发粒子更新并发布新的位姿估计，<code>set_map</code>用于设定机器人位姿和地图信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">laser_scan_sub_ = <span class="keyword">new</span> message_filters::Subscriber&lt;sensor_msgs::LaserScan&gt;(nh_, scan_topic_, <span class="number">100</span>);</span><br><span class="line">laser_scan_filter_ = <span class="keyword">new</span> tf::MessageFilter&lt;sensor_msgs::LaserScan&gt;(</span><br><span class="line">                                  *laser_scan_sub_, </span><br><span class="line">                                  *tf_, </span><br><span class="line">                                  odom_frame_id_, </span><br><span class="line">                                  <span class="number">100</span> );</span><br><span class="line">laser_scan_filter_-&gt;registerCallback(boost::bind(&amp;AmclNode::laserReceived,</span><br><span class="line">                                                 <span class="keyword">this</span>, _1));</span><br></pre></td></tr></table></figure><p>接下来构建激光传感器的消息过滤器对象和tf2的过滤器，并注册回调函数laserReceived。这里的message_filter为ROS系统提供了一些通用的消息过滤方法， 它对接收到的消息进行缓存，只有当满足过滤条件后才输出，在需要消息同步的时候应用比较多。这里主要是同时监听激光扫描消息和里程计坐标变换，同步两者的输出。 这一套路在GMapping中也有用到。</p><p>订阅用于初始化机器人位姿估计的主题initialpose</p><p>根据运行参数<code>use_map_topic_</code>获取地图，或者订阅地图主题，或者通过<code>requestMap</code>请求<code>static_map</code>服务。因为一般取false，所以后面我们直接看<code>requestMap</code>函数</p><p>定义<code>m_force_update</code>为false，后面会用到</p><p>最后定义一个计时器用于每隔15s检查一次激光雷达的接收数据，如果期间没有收到新的数据给出告警</p><h3 id="requestMap和handleMapMessage"><a href="#requestMap和handleMapMessage" class="headerlink" title="requestMap和handleMapMessage"></a>requestMap和handleMapMessage</h3><p><code>requestMap</code>函数请求<code>static_map</code>服务成功后，调用函数<code>handleMapMessage</code>处理接收到的地图数据，进一步完成AmclNode的初始化工作，内容庞大的其实是handleMapMessage</p><p><code>handleMapMessage</code>的流程图在<a href="https://live.staticflickr.com/65535/49379331342_b2dfde6972_b.jpg" target="_blank" rel="noopener">这里</a></p><p>释放了与地图相关的内存和对象之后，通过函数convertMap将地图消息转换成amcl中的地图数据结构。</p><p>接着构建粒子滤波器对象，并完成初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建粒子滤波器对象</span></span><br><span class="line">pf_ = pf_alloc(min_particles_,</span><br><span class="line">               max_particles_,</span><br><span class="line">               alpha_slow_,</span><br><span class="line">               alpha_fast_,</span><br><span class="line">               (<span class="keyword">pf_init_model_fn_t</span>)AmclNode::uniformPoseGenerator,</span><br><span class="line">               (<span class="keyword">void</span> *)map_ );</span><br><span class="line">pf_-&gt;pop_err = pf_err_;</span><br><span class="line">pf_-&gt;pop_z = pf_z_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从参数服务器获取初始位姿及方差放到pf中</span></span><br><span class="line">updatePoseFromServer();</span><br><span class="line"><span class="keyword">pf_vector_t</span> pf_init_pose_mean = pf_vector_zero();</span><br><span class="line">pf_init_pose_mean.v[<span class="number">0</span>] = init_pose_[<span class="number">0</span>];   <span class="comment">// initial_pose_x</span></span><br><span class="line">pf_init_pose_mean.v[<span class="number">1</span>] = init_pose_[<span class="number">1</span>];   <span class="comment">// initial_pose_y</span></span><br><span class="line">pf_init_pose_mean.v[<span class="number">2</span>] = init_pose_[<span class="number">2</span>];   <span class="comment">// initial_pose_a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pf_matrix_t</span> pf_init_pose_cov = pf_matrix_zero();</span><br><span class="line">pf_init_pose_cov.m[<span class="number">0</span>][<span class="number">0</span>] = init_cov_[<span class="number">0</span>];</span><br><span class="line">pf_init_pose_cov.m[<span class="number">1</span>][<span class="number">1</span>] = init_cov_[<span class="number">1</span>];</span><br><span class="line">pf_init_pose_cov.m[<span class="number">2</span>][<span class="number">2</span>] = init_cov_[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化高斯粒子滤波器</span></span><br><span class="line">pf_init(pf_, pf_init_pose_mean, pf_init_pose_cov);</span><br><span class="line">pf_init_ = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>这里面有两个重要函数<strong>pf_alloc</strong>和<strong>pf_init</strong></p><p>构建里程计对象，根据launch文件里的参数配置里程计模型</p><p>构建雷达传感器对象，根据运行参数<code>laser_model_type_</code>构建不同模型的雷达</p><p>最后考虑到，在接收到地图数据之前，有可能已经接收到了机器人的初始位姿，这里调用函数applyInitialPose处理</p><h3 id="laserReceived回调函数"><a href="#laserReceived回调函数" class="headerlink" title="laserReceived回调函数"></a>laserReceived回调函数</h3><p>Amcl的业务逻辑总体就是在一个四五百行的巨大函数laserReceived中实现的，它就是刚刚我们提到的消息过滤器<code>laser_scan_filter_</code>的回调函数。</p><ul><li><p>用变量last_laser_received_ts_记录下当前的系统时间， 它用于判定是否长时间未接收到雷达数据。此外如果没有地图对象，将直接退出</p></li><li><p>AmclNode借助一些vector和map的容器，来支持多传感器。它使用lasers_记录下当前构建的雷达对象，lasers_update_标记雷达的更新状态， 并通过一个string到int的map建立其雷达坐标ID到雷达对象在lasers_中的对应关系。</p></li><li><p>通过在frame_to_laser_中查找雷达的坐标ID，如果之前没有收到该雷达的消息，将新建一个对象保存在lasers_中，并相应的在lasers_update_中添加对应更新状态， 建立映射关系。否则，我们就直接通过frame_to_laser_获取雷达对象的索引。</p></li><li><p>利用tf求出雷达坐标系的原点在base_link下的坐标，然后调用<code>SetLaserPose</code>设置雷达的位姿，angle暂时为0</p></li><li><p>getOdomPose获取收到雷达数据时的里程计位姿</p></li><li><p><code>if(pf_init_)</code>的内容一定执行，如果里程计的数据显示机器人已经发生了明显的位移或者旋转，就标记所有的雷达更新标记为true</p></li><li><p>根据刚刚更新标识，我们调用里程计对象的UpdateAction接口完成运动更新，也就是机器人移动后执行<code>else if(pf_init_ &amp;&amp; lasers_update_[laser_index])</code>的内容</p></li><li><p>机器人移动，执行<code>if(lasers_update_[laser_index])</code>的内容，根据激光的扫描数据更新滤波器。首先构建<code>AMCLLaserData</code>对象，并指定传感器对象和量程，然后将接收到的传感器数据拷贝到ldata对象中，最后通过激光传感器对象的UpdateSensor接口完成粒子滤波器的测量更新。这里发布了<code>particlecloud</code>话题</p></li></ul><ul><li>机器人移动，则执行<code>if(resampled || force_publication)</code>的内容，发布了<code>amcl_pose</code>话题</li></ul></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/03/C++/C++  面向对象/在命名空间中用非成员函数取代成员函数/">在命名空间中用非成员函数取代成员函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-面向对象/">C++ 面向对象</a></span><div class="content"><p>这个就是Effective C++条款23，假如类有多个成员函数，现在需要在一个函数里调用这几个函数，那么最好不要把它定义为成员函数，而是类外的普通函数。</p><p>最常见的做法是定义一个namespace，把类和普通函数都放到里面，namespace可以跨越多个文件，但类不能。这正是C++标准库std的风格，std有数十个文件，每个声明std的部分机能，这样能<font color="blue" size="3"> 降低编译的依存性。</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base();</span><br><span class="line">    ~Base();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setB</span><span class="params">(<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">double</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  这里声明，但不能定义函数体，否则编译不通过</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAB</span><span class="params">(Base&amp; obj, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源文件</span></span><br><span class="line">test::Base::Base():</span><br><span class="line">    m_a(<span class="number">0</span>),</span><br><span class="line">    m_b(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"base constructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test::Base::~Base()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"base destructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> test::Base::setA(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    m_a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> test::Base::setB(<span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    m_b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//必须加test:: ，否则编译不通过</span></span><br><span class="line"><span class="keyword">void</span> test::setAB(Base&amp; obj, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    obj.setA(a);</span><br><span class="line">    obj.setB(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">test::Base b;</span><br><span class="line">test::setAB(b, <span class="number">43</span>, <span class="number">23</span>);</span><br></pre></td></tr></table></figure><p><code>setAB</code>函数在类Base之外，这样的封装性比作为成员函数要好，它并不增加能访问类private成员的函数数量，有较低的编译相依度。</p><p>类放到命名空间后，继承类可以像平常那样继承，不必也放到这个命名空间里。</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/03/C++/C++  面向对象/内联函数/">内联函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-面向对象/">C++ 面向对象</a></span><div class="content"><p>之前对内联函数的理解不够深，内联函数是在<strong>编译阶段</strong>将函数展开，而不用将函数地址压入堆栈,避免被调用的开销来提高效率，但增大了可执行程序的体积。如果在类体内定义实现，那么就是内联函数；也可以在类内用inline声明，在体外实现。函数一般比较小，用于大量调用的场合。</p><p>其实上面这些还没触及到本质，还有以下几条:</p><ol><li><p>inline只是我们对编译器提出的一个申请，是否真按内联函数处理取决于编译器。函数不能有循环和递归，不能太大，否则仍是普通函数</p></li><li><p>编译器的内联看起来就像是代码的复制与粘贴，这与预处理宏是很不同的：宏是强制的内联展开，可能将会污染所有的命名空间与代码，将为程序的调试带来困难，所以最好用内联函数代替宏</p></li><li><p>虚函数与内联：内联是编译期的行为，虚函数是运行期的行为，二者的领域不同。要多态时不能内联，不要多态可以内联</p></li><li><p>如果一个内联函数会在多个源文件中被用到，那么最好把它定义在头文件中，否则必须在调用该函数的每个文件中定义</p></li><li><p>构造函数和析构函数不适合做内联函数，编译器在编译期间会给你的构造函数和析构函数额外加入很多的代码，像成员函数的构造和析构等代码，所以通常构造和析构函数比表面上看起来的要多，并不适合作为内联函数</p></li><li><p>内联函数无法随程序库升级而升级，比如修改了一个内联函数，那么所有用到它的地方都要重新编译，而普通函数做修改后，程序只需要重新链接它，效率比重新编译高</p></li><li><p>大部分调试器不能用在内联函数里</p></li></ol><p>内联函数和宏的区别：</p><ol><li><p>内联函数展开在编译阶段，宏在预处理阶段</p></li><li><p>内联函数运行时可调试，宏定义不可以</p></li><li><p>内联函数会经过编译器安全检查，宏定义的参数没有类型的概念，只有在宏展开以后，才由编译器检查语法，这就存在很多的安全隐患</p></li></ol><p>详细内容看《Effective C++》条款30</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/30/C++/C++  面向对象/总结Effective C++条款/">总结Effective C++条款</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-面向对象/">C++ 面向对象</a></span><div class="content"><p>最近重读了《Effective C++》，对一些复杂的知识点会专门写文章分析，这里将一些小的知识点总结一下，但不会涵盖书里的所有内容。</p><h2 id="条款2"><a href="#条款2" class="headerlink" title="条款2"></a>条款2</h2><ul><li><p>良好的用户自定义类型的特征是它尽量能与内置类型兼容</p></li><li><p>宁可用编译器替换预处理器</p></li><li><p>尽量多用const,而不是宏定义.宏属于模块化的设计概念,会破坏封装性</p></li><li><p>常量可能比<code>#define</code>产生较小量的代码.</p></li><li><p>如果类需要用到多个常量,不要用const数组,而是改用枚举</p></li><li><p>对于宏形式的函数,最好用内联函数取代</p></li></ul><h2 id="条款3"><a href="#条款3" class="headerlink" title="条款3"></a>条款3</h2><ul><li>希望迭代器指向的东西不可改动,需要<code>const_iterator</code></li></ul><h2 id="条款4"><a href="#条款4" class="headerlink" title="条款4"></a>条款4</h2><ul><li><p>永远在使用对象前初始化.对于<code>int x;</code>,有些编译器会将x初始化为0,有些却不会,所以无论之后有没有用到x,都要先对其初始化,比如<code>int x=0;</code></p></li><li><p>成员变量如果是const或引用,它们只能用<strong>成员列表初始化</strong>的方法进行初始化</p></li></ul><h2 id="条款5"><a href="#条款5" class="headerlink" title="条款5"></a>条款5</h2><ul><li><p>编译器自动生成的析构函数不是virtual,除非这个类的基类的析构函数是virtural</p></li><li><p>编译器自动生成的4个函数都是public</p></li><li><p>如果基类的copy构造函数和copy运算符是private,编译器不会为派生类生成它们</p></li><li><p>派生类的copy构造函数可以尽量不定义</p></li></ul><h2 id="条款6"><a href="#条款6" class="headerlink" title="条款6"></a>条款6</h2><ul><li><p>定义uncopyable类是很好的禁止使用copy构造函数和copy运算符的方法，它的析构函数可以不是virtual,派生类不必以public继承它,也没有成员变量,也可以用于多重继承</p></li><li><p>类的不可拷贝特性是可以继承的，例如凡是继承自uncopyable的类都不能使用copy构造函数和赋值运算符</p></li></ul><h2 id="条款7"><a href="#条款7" class="headerlink" title="条款7"></a>条款7</h2><ul><li><p>如果基类析构函数不声明为virtual，析构时不会调用派生类的析构，可查看<a href="https://charon-cheung.github.io/2018/07/05/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">原因分析</a></p></li><li><p>如果一个类不做基类，就不要有virtual析构函数或其他虚函数，因为虚指针会增大类的体积。 反过来，只要一个类做基类，就要有virtual函数</p></li><li><p>当类至少有一个虚函数时，为它声明virtual析构函数，否则编译器有报警<br><img src="https://i.loli.net/2020/01/03/VMqy7Ti53RCkgcJ.png" alt></p></li><li><p>对于抽象类，可以将析构函数声明为pure virtual析构函数</p></li></ul><h2 id="条款8"><a href="#条款8" class="headerlink" title="条款8"></a>条款8</h2><ul><li>析构函数里不要抛出异常，否则会导致不确定行为</li></ul><h2 id="条款9"><a href="#条款9" class="headerlink" title="条款9"></a>条款9</h2><ul><li><p>构造函数和析构函数中都不要调用virtual函数，因为基类构造时，virtual函数不会下降到派生类阶层，或者说此时的virtual函数还不是virtual函数</p></li><li><p>对于存在多个构造函数的情况，为避免代码重复，要把同样的代码放到一个函数里，比如init</p></li></ul><h2 id="条款10"><a href="#条款10" class="headerlink" title="条款10"></a>条款10</h2><ul><li>赋值运算符(包括<code>+= -= *=</code>)的返回最好是<code>return *this</code>，这符合STL等标准库的风格</li></ul><h2 id="条款12"><a href="#条款12" class="headerlink" title="条款12"></a>条款12</h2><ul><li><p>自定义copy构造函数或运算符时，需要复制所有的成员变量，如果少复制了，编译器不会报警或报错</p></li><li><p>派生类的copy构造函数或运算符，无法像平时那样对基类的private成员变量赋值，因为无法访问private的变量，只能显式调用基类的operator =， 比如： Base::operator=(obj);</p></li></ul><p><img src="https://i.loli.net/2019/12/30/wvPezFH9E2OMD7l.png" alt></p><h2 id="条款15"><a href="#条款15" class="headerlink" title="条款15"></a>条款15</h2><ul><li>多使用智能指针shared_ptr，它可以返回原始指针，显式方法是get()函数，隐式方法是取指针操作符-&gt;</li></ul><h2 id="条款16"><a href="#条款16" class="headerlink" title="条款16"></a>条款16</h2><ul><li>new和delete必须配对，[]必须都有或都没有。千万避免new没有[]，delete有[]，这会导致程序不停运行析构函数</li></ul><h2 id="条款18"><a href="#条款18" class="headerlink" title="条款18"></a>条款18</h2><ul><li><p>有时的形参可以用wrapper类型，而不是内置类型</p></li><li><p>保证接口的一致，比如STL容器都有个size的成员函数</p></li><li><p>可以让一些返回指针的函数返回智能指针，比如工厂函数</p></li></ul><h2 id="条款21"><a href="#条款21" class="headerlink" title="条款21"></a>条款21</h2><ul><li>函数内返回对象时，不要返回其引用。因为引用指向局部变量，而局部变量在函数退出前销毁，所以会出现无定义行为。</li></ul><h2 id="条款22"><a href="#条款22" class="headerlink" title="条款22"></a>条款22</h2><ul><li><p>成员变量应该都是private，将它们隐藏在函数接口的背后，如果放到public，直接使用成员变量会降低封装性。如果破坏了成员变量，会破坏太多的客户码</p></li><li><p>成员变量的封装性和成员变量的内容改变时破坏的代码量成反比</p></li><li><p>protected变量被消灭时，所有用到它的派生类的代码都要破坏，所以封装性也很差</p></li></ul><h2 id="条款24"><a href="#条款24" class="headerlink" title="条款24"></a>条款24</h2><ul><li><p>若函数参数都要进行类型转换，应该使用非成员函数</p></li><li><p>成员函数的反面是非成员函数，不是friend函数，friend应该尽量避免</p></li></ul><h2 id="条款26"><a href="#条款26" class="headerlink" title="条款26"></a>条款26</h2><ul><li><p>如果某个类的对象没有用到，就不应该声明，否则运行构造和析构函数都会耗费成本</p></li><li><p>对象初始化用构造函数比=运算符的效率高</p></li><li><p>对变量定义后应马上初始化，然后马上使用，中间不要隔太远</p></li><li><p>变量定义在循环内比外面更好，后者造成作用域更大，对程序维护性不好</p></li></ul><h2 id="条款27"><a href="#条款27" class="headerlink" title="条款27"></a>条款27</h2><ul><li><p>代码中尽量避免dynamic_cast，它会降低效率</p></li><li><p>避免连续的cast转型，尤其是dynamic_cast</p></li></ul><h2 id="条款32"><a href="#条款32" class="headerlink" title="条款32"></a>条款32</h2><ul><li><p>public继承是一种<code>is-a</code>的关系，每一个派生类的对象也是基类的对象</p></li><li><p>程序的错误最好能在编译期检测出来，而不是运行期</p></li></ul><h2 id="条款34"><a href="#条款34" class="headerlink" title="条款34"></a>条款34</h2><ul><li><p>public继承涉及到函数接口继承和实现的继承</p></li><li><p>纯虚函数实际上是可以提供定义的，这个用法比较罕见，知道即可</p></li><li><p>虚函数使派生类继承了其缺省实现，但这可能造成危险</p></li></ul><h2 id="条款36"><a href="#条款36" class="headerlink" title="条款36"></a>条款36</h2><ul><li>不要重新定义继承而来的non-virtual函数，虽然没有错误，但违反了<code>is-a</code>原则，这种情况下干脆不要使用public继承</li></ul></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/30/C++/C++  面向对象/构造函数的成员初始化列表(二)/">构造函数的成员初始化列表 (二)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-面向对象/">C++ 面向对象</a></span><div class="content"><p>根据Effective C++，类的成员变量最好都用<strong>成员列表初始化</strong>的方法进行初始化,对内置类型没什么不同,但对类对象会提高效率.成员初始化顺序是其声明的顺序,不是初始化列表中的顺序,二者最好一致</p><p>构造函数内赋值成员变量,先调用默认构造函数,再调用copy运算符. 如果用成员列表初始化,只调用copy构造函数，提高了效率</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived();</span><br><span class="line">    Derived(Base obj)</span><br><span class="line">    &#123;</span><br><span class="line">		m_b = obj;</span><br><span class="line">    	<span class="built_in">cout</span>&lt;&lt;<span class="string">"derived constructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Derived();</span><br><span class="line">    Derived(<span class="keyword">const</span> Derived&amp; obj);</span><br><span class="line">    Derived&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Derived&amp; obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Base m_b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际调用:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base b;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"----------------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="function">Derived <span class="title">d</span><span class="params">(b)</span></span>;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">base constructor</span><br><span class="line">----------------</span><br><span class="line">base copy constructor</span><br><span class="line">base constructor</span><br><span class="line">base constructor</span><br><span class="line">base operator =</span><br><span class="line">derived constructor</span><br><span class="line">base destructor</span><br><span class="line">----------------</span><br><span class="line">derived destructor</span><br><span class="line">base destructor</span><br><span class="line">base destructor</span><br><span class="line">base destructor</span><br></pre></td></tr></table></figure><p>第一行是<code>Base b</code>的结果,第二行是运行构造函数时,b传递的参数副本,所以调用copy构造函数;<br>第三行是成员变量<code>m_b</code>的构造函数;第四行是运行派生类的构造函数前先运行的基类构造函数;<br>第五行就是=运算符; 析构过程就简单了,不再分析</p><p>这里是解释一下成员列表初始化的原则,实际中一般不这么用,Derived的成员变量会是<code>Base* m_b</code>,此时的调用是这样的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base *b = <span class="keyword">new</span> Base();</span><br><span class="line"><span class="function">Derived <span class="title">d</span><span class="params">(b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> b;</span><br><span class="line">b = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>结果是:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">base constructor</span><br><span class="line">----------------</span><br><span class="line">base constructor</span><br><span class="line">derived constructor</span><br><span class="line">base destructor</span><br><span class="line">----------------</span><br><span class="line">derived destructor</span><br><span class="line">base destructor</span><br></pre></td></tr></table></figure><p>这样简单多了</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/26/C++/C++  面向对象/const成员变量和成员函数/">const成员变量和成员函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-面向对象/">C++ 面向对象</a></span><div class="content"><ul><li><p>在类成员函数后面加const关键字用于声明const成员函数，它不能改变类的成员变量，也不能调用该类中普通的成员函数，最好不要涉及非const的成员变量</p></li><li><p>const成员变量只能通过构造函数初始化列表进行初始化，任何成员函数均不能改变它的值</p></li><li><p>const对象只能调用const成员函数，那是它的唯一对外接口</p></li><li><p>若不希望传入的实参对象被修改，应该将形参定义为const的指针变量或者引用</p></li></ul><p>const成员函数的定义是这样形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getConst</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>前面不用加const了，否则会有报警：<br><img src="https://i.loli.net/2019/12/26/VLH2Q4w8r3fADEW.png" alt></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setM</span><span class="params">(<span class="keyword">int</span> M)</span>	<span class="comment">//setter都不能加const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m = M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getM</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Base b;</span><br><span class="line">b.setM(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><code>getM</code>就是常量成员函数，如果给setM加const，那么就会报错，因为它修改m的值。定义的常对象b只能调用<code>getM</code>，调setM会报错。</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/26/C++/C++  面向对象/使用const引用做函数形参类型/">使用const引用做函数形参类型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-面向对象/">C++ 面向对象</a></span><div class="content"><p>本问题是Effective C++的条款20</p><h3 id="提高代码效率"><a href="#提高代码效率" class="headerlink" title="提高代码效率"></a>提高代码效率</h3><p>我们知道函数的实际参数是实参的一个副本，它是由copy构造函数产生的，但这种传const引用的方式可以提高函数调用效率，它不会涉及副本的构造函数、析构函数和copy构造函数</p><p>测试代码如下，对基类定义了copy构造函数，但派生类没有定义copy构造函数，信息中会输出this指针的地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useDerived</span><span class="params">(<span class="keyword">const</span> Derived&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">" use Derived"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Derived f;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"-------------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">useDerived(f);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"*************"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Base constrct  0x75fd20</span><br><span class="line">Derived construct  0x75fd20</span><br><span class="line">-------------</span><br><span class="line"> use Derived</span><br><span class="line">*************</span><br><span class="line">Derived deconstruct  0x75fd20</span><br><span class="line">Base deconstrct  0x75fd20</span><br></pre></td></tr></table></figure><p>显然只有f的构造和析构过程，对于副本，只调用了useDerived函数，没有构造和析构，也没有copy构造。</p><p>如果改用值传递的方式，结果就变成下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Base constrct  0x75fd10</span><br><span class="line">Derived construct  0x75fd10</span><br><span class="line">-------------</span><br><span class="line">Base copy constrct  ---0x75fd40</span><br><span class="line"> use Derived</span><br><span class="line">Derived deconstruct  0x75fd40</span><br><span class="line">Base deconstrct  0x75fd40</span><br><span class="line">*************</span><br><span class="line">Derived deconstruct  0x75fd10</span><br><span class="line">Base deconstrct  0x75fd10</span><br></pre></td></tr></table></figure><p>显然副本的copy构造和析构都有了，效率明显降低</p><h3 id="避免对象切割问题"><a href="#避免对象切割问题" class="headerlink" title="避免对象切割问题"></a>避免对象切割问题</h3><p>如果上面的函数改成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useDerived</span><span class="params">(Base f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f.testConst();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"value use Derived"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// testConst声明为虚函数</span></span><br><span class="line"><span class="keyword">void</span> Base::testConst() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"base test const"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Derived::testConst() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"derived test const"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">Derived d;</span><br><span class="line">useDerived(d);</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">base constructor</span><br><span class="line">derived constructor</span><br><span class="line">base copy constructor</span><br><span class="line">base test const     // 基类版本</span><br><span class="line">value use Derived</span><br><span class="line">base destructor</span><br><span class="line">derived destructor</span><br><span class="line">base destructor</span><br></pre></td></tr></table></figure><p>此时如果传入f，会把它按Base对象处理，而丧失了派生类的特性，调用的还是基类版本的函数，这不是我们的目的。但是如果用<code>const Base&amp; obj</code>，就会根据传入的类型处理，结果调用派生类版本的函数，但是形参为常引用时，只能调用const成员函数。</p><p>不过对于内置类型和STL的iterator，函数对象，还是用值传递的方式比较好</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/19/激光SLAM/gmapping/一 概述/">(一) gmapping概述</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/gmapping/">gmapping</a></span><div class="content"><p>Gmapping是目前应用最为广的2D slam方法，主要是利用RBRF方法，所以需要了解粒子滤波的方法（利用统计特性描述物理表达式下的结果）。</p><p>Gmapping可以实时构建室内地图，在构建小场景地图所需的计算量较小且精度较高。相比Hector SLAM对激光雷达频率要求低、鲁棒性高（Hector 在机器人快速转向时很容易发生错误匹配，建出的地图发生错位，原因主要是优化算法容易陷入局部最小值）；而相比Cartographer在构建小场景地图时，Gmapping不需要太多的粒子并且没有回环检测因此计算量小于Cartographer而精度并没有差太多。</p><p>随着场景增大所需的粒子增加，因为每个粒子都携带一幅地图，因此在构建大地图时所需内存和计算量都会增加。因此不适合构建大场景地图。并且没有回环检测，因此在回环闭合时可能会造成地图错位，虽然增加粒子数目可以使地图闭合但是以增加计算量和内存为代价。</p><p>粒子是一个依据过程的观测逐渐更新权重与收敛的过程,这种重采样的过程必然会代入粒子耗散问题(depletion problem), 大权重粒子显著,小权重粒子会消失(有可能正确的粒子模拟可能在中间的阶段表现权重小而消失)。</p><p>自适应重采样技术引入减少了粒子耗散问题，计算粒子分布的时候不单单仅依靠机器人的运动(里程计)，同时将当前观测考虑进去，减少了机器人位置在粒子滤波步骤中的不确定性. (FAST-SLAM 2.0 的思想，可以适当减少粒子数)</p><p>所以Gmapping不能像cartographer那样构建大的地图，虽然论文生成几万平米的地图，但实际我们使用中建的地图没有上万平米时就会发生错误。 gmapping建图对狭窄走廊容易出错</p><p>参考：<br><a href="https://blog.csdn.net/zyh821351004/article/details/47381135" target="_blank" rel="noopener">各种激光slam: 开源代码的比较</a><br><a href="https://www.slamtec.com/en/News/Detail/72" target="_blank" rel="noopener">2D激光SLAM算法优劣对比</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/16/ROS/ROS机器人/机器人运动模型/">机器人运动模型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS机器人/">ROS机器人</a></span><div class="content"><p>二轮差速模型的航迹推演原理图，后方两个驱动轮，前面两个万向轮<br><img src="https://i.loli.net/2019/12/16/Hl2Fz8Mqdo3bY5t.png" alt></p><ul><li>IMU只提供yaw</li><li>根据航迹推演，两驱车的线速度是两个轮子线速度的平均值，角速度是 差/底盘长度;两个参数作为<code>raw_vel</code>话题发布</li><li>机器人切线运动模型<br>base_controller节点正确读取到底层（比如嵌入式控制板）传回的速度后进行积分，计算出机器人的估计位置和姿态，并将里程计信息和tf变换发布出去。</li><li>机器人中通过运行底盘控制ROS驱动，来实现读取串口的速度反馈，利用航迹推演算法计算得到里程计并发布到/odom这个主题</li></ul><p>之所以说这个是粗略的定位，是因为在实际情况中可能会碰到轮子打滑，地面不平整等因素的干扰，里程计的运动增量带有噪声，对速度积分进行航迹推算得到的里程计累积误差会越来越大。当然上层会通过激光信息来匹配校准。</p><p>IMU姿态的协方差矩阵代表了姿态测量的不确定度。</p></div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image:url(https://live.staticflickr.com/65535/48055510011_577ff62eaf_b.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>