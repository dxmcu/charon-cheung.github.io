<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG={root:"/",algolia:{appId:"RI90VLL69D",apiKey:"20c535e9a1424a7913210eb747d6e67b",indexName:"HexoBlog",hits:{per_page:10},languages:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}.",hits_stats:"${hits} results found in ${time} ms"}},localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">451</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">52</span></a></div></div></div><nav id="nav" style="background-image:url(https://i.loli.net/2020/07/13/QgyrefaLDxhBWSZ.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div><div id="site-social-icons"><a class="social-icon" href="https://github.com/charon-cheung"><i class="fa-github fa"></i></a><a class="social-icon search"><i class="fa fa-search"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/路径规划/move_base分析/OdometryHelperRos 解析/">OdometryHelperRos 解析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/move-base分析/">move_base分析</a></span><div class="content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OdometryHelperRos</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** @brief Constructor.</span></span><br><span class="line"><span class="comment">   * @param odom_topic The topic on which to subscribe to Odometry</span></span><br><span class="line"><span class="comment">   *        messages.  If the empty string is given (the default), no</span></span><br><span class="line"><span class="comment">   *        subscription is done. */</span></span><br><span class="line">  OdometryHelperRos(<span class="built_in">std</span>::<span class="built_in">string</span> odom_topic = <span class="string">""</span>)</span><br><span class="line">  &#123; </span><br><span class="line">    setOdomTopic( odom_topic ); </span><br><span class="line">  &#125;</span><br><span class="line">  ~OdometryHelperRos() &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">odomCallback</span><span class="params">(<span class="keyword">const</span> nav_msgs::Odometry::ConstPtr&amp; msg)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getOdom</span><span class="params">(nav_msgs::Odometry&amp; base_odom)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getRobotVel</span><span class="params">(tf::Stamped&lt;tf::Pose&gt;&amp; robot_vel)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** @brief Set the odometry topic.  This overrides what was set in the constructor, if anything.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * This unsubscribes from the old topic (if any) and subscribes to the new one (if any).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * If odom_topic is the empty string, this just unsubscribes from the previous topic. */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setOdomTopic</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> odom_topic)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getOdomTopic</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> odom_topic_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> odom_topic_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we listen on odometry on the odom topic</span></span><br><span class="line">  ros::Subscriber odom_sub_;</span><br><span class="line">  nav_msgs::Odometry base_odom_;</span><br><span class="line">  boost::mutex odom_mutex_;</span><br><span class="line">  <span class="comment">// global tf frame id</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> frame_id_; <span class="comment">///&lt; The frame_id associated this data</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是base_local_planner局部规划器里起辅助功能的一个类,主要作用就是从/odom的topic中获取机器人的速度状态(包括线速度(x,y),和角速度z)</p><p>TrajectoryPlannerROS局部规划器初始化的时候便调用这个类初始化/odom topic</p><p>要使用，首先<code>#include &lt;base_local_planner/odometry_helper_ros.h&gt;</code>，</p><p>OdometryHelperRos()在初始化的时候,新建了NodeHandle并设置关注的topic的名称odom_topic;<br>并在回调函数odomCallback()中, 取出速度信息</p><h2 id="和Teb算法的关系"><a href="#和Teb算法的关系" class="headerlink" title="和Teb算法的关系"></a>和Teb算法的关系</h2><p>类<code>TrajectoryPlannerROS</code>中定义： <code>base_local_planner::OdometryHelperRos odom_helper_;</code></p><p>move_base的yaml中，对局部路径规划配置：<code>teb_local_planner/TebLocalPlannerROS</code></p><p>MoveBase中有一段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private_nh.param(<span class="string">"base_local_planner"</span>, local_planner, <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"base_local_planner/TrajectoryPlannerROS"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tc_ = blp_loader_.createInstance(local_planner);</span><br><span class="line">tc_-&gt;initialize(blp_loader_.getName(local_planner), &amp;tf_, controller_costmap_ros_);</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/xinmei4275/article/details/87863686" target="_blank" rel="noopener">OdometryHelperRos类</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/路径规划/move_base分析/CostmapModel/">CostmapModel</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/move-base分析/">move_base分析</a></span><div class="content"><p>CostmapModel类则能够获取点、连线、多边形边缘（机器人足迹）的cost，是局部规划器与costmap间的一个桥梁。一般如下使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">world_model_ = <span class="keyword">new</span> base_local_planner::CostmapModel(*(planner_costmap_ros_ -&gt;getCostmap()) ); </span><br><span class="line"><span class="comment">//costmap_2d::Costmap2DROS*  planner_costmap_ros_</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;geometry_msgs::Point&gt; footprint = planner_costmap_ros_-&gt;getRobotFootprint();</span><br><span class="line"><span class="keyword">double</span> footprint_cost = world_model_-&gt;footprintCost(x_i, y_i, theta_i, footprint);</span><br><span class="line"></span><br><span class="line"><span class="comment">// footprint.size() 16</span></span><br></pre></td></tr></table></figure><p>CostmapModel类帮助local planner在Costmap上进行计算, footprintCost,lineCost,pointCost三个类方法分别能通过Costmap计算出机器人足迹范围、两个cell连线、单个cell的代价，并将值返回给局部规划器。</p><p>若预设的足迹点数&lt;3，考虑足迹的形状没有意义，这时只计算机器人位置点在costmap上的代价；<br>若预设的足迹点数≥3，把足迹视为多边形，循环调用lineCost计算多边形各边的cell，注意首尾闭合，最后返回代价。对于圆形底盘，足迹点数是16,也就是在costmap里把圆形按16边形处理。</p><p>footprintCost函数的返回值:</p><ul><li>1.0 ：覆盖至少一个障碍cell</li><li>2.0 ：覆盖至少一个未知cell</li><li>3.0 ：不在地图上</li><li>其他正cost</li></ul><p>参考：<br><a href="https://blog.csdn.net/Neo11111/article/details/104720103" target="_blank" rel="noopener">CostmapModel::footprintCost</a><br><a href="https://my.oschina.net/u/4324682/blog/3457091" target="_blank" rel="noopener">ObstacleCostFunction类，继承自Trajectory类</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/激光SLAM/Cartographer/原理和配置/扩展建图 - 在现有地图基础上继续建图/">扩展建图 - 在现有地图基础上继续建图</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/Cartographer/原理和配置/">原理和配置</a></span><div class="content"><p>There is currently no way to “resume mapping” when using gmapping. Basically, the map image and yaml file do not have enough information for GMapping to resume from. The occupancy grid representation of the map (for example, the pgm bitmap) doesn’t contain enough state to resume mapping. Internally, gmapping is estimating a distribution over maps and robot trajectories, using a particle filter. To resume mapping, you’d have to save all of that internal state. In principle, it’s possible to do that, but it’s not currently implemented, and I would guess it would take quite a bit of work.</p><p>For long-term mapping, including pause-and-resume abilities, I’d go for a constraint-graph SLAM algorithm, instead of a particle filter algorithm.</p><p><a href="https://github.com/cartographer-project/cartographer/issues/1633" target="_blank" rel="noopener">https://github.com/cartographer-project/cartographer/issues/1633</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/路径规划/move_base分析/公司机器人的注意事项/">公司机器人的注意事项</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS机器人/">ROS机器人</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2020/11/15/路径规划/move_base分析/公司机器人的注意事项/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/路径规划/move_base分析/机器人footprint的研究/">机器人footprint的研究</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/move-base分析/">move_base分析</a></span><div class="content"><p>目前所用的机器人模型是圆形,在通用代价地图里定义:<code>robot_radius: 0.26</code>,而不是<code>footprint</code>参数. 但是注意TEB里用的是Point类型.</p><p>指定<code>footprint</code>的数组元素时,点如果太多，可以换行。机器人的轮廓可能是不规则的polygon,但它的运动中心永远是(0, 0),顺时针和逆时针规范都支持。这应该是局部坐标系决定的<br><img src="https://i.loli.net/2020/11/01/JTegObBvfoEYw5n.png" alt="footprint setting.png"></p><p>现在分析源码中对这个参数的处理,<code>Costmap2DROS</code>的构造函数里有一句： <code>setUnpaddedRobotFootprint(makeFootprintFromParams(private_nh));</code>,先看括号里的函数</p><h2 id="makeFootprintFromParams"><a href="#makeFootprintFromParams" class="headerlink" title="makeFootprintFromParams"></a>makeFootprintFromParams</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;geometry_msgs::Point&gt; makeFootprintFromParams(ros::NodeHandle&amp; nh)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> full_param_name;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> full_radius_param_name;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;geometry_msgs::Point&gt; points;</span><br><span class="line">  <span class="comment">// 优先读footprint参数的值</span></span><br><span class="line">  <span class="keyword">if</span> (nh.searchParam(<span class="string">"footprint"</span>, full_param_name))</span><br><span class="line">  &#123;</span><br><span class="line">    XmlRpc::XmlRpcValue footprint_xmlrpc;</span><br><span class="line">    nh.getParam(full_param_name, footprint_xmlrpc);</span><br><span class="line">    <span class="keyword">if</span> (footprint_xmlrpc.getType() == XmlRpc::XmlRpcValue::TypeString &amp;&amp;</span><br><span class="line">        footprint_xmlrpc != <span class="string">""</span> &amp;&amp; footprint_xmlrpc != <span class="string">"[]"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (makeFootprintFromString(<span class="built_in">std</span>::<span class="built_in">string</span>(footprint_xmlrpc), points))</span><br><span class="line">      &#123;</span><br><span class="line">        writeFootprintToParam(nh, points);</span><br><span class="line">        <span class="keyword">return</span> points;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一般是这个，因为我们定义的是数组</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (footprint_xmlrpc.getType() == XmlRpc::XmlRpcValue::TypeArray)</span><br><span class="line">    &#123;</span><br><span class="line">      points = makeFootprintFromXMLRPC(footprint_xmlrpc, full_param_name);</span><br><span class="line">      writeFootprintToParam(nh, points);</span><br><span class="line">      <span class="keyword">return</span> points;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 没有 footprint再读robot_radius</span></span><br><span class="line">  <span class="keyword">if</span> (nh.searchParam(<span class="string">"robot_radius"</span>, full_radius_param_name))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">double</span> robot_radius;</span><br><span class="line">    nh.param(full_radius_param_name, robot_radius, <span class="number">1.234</span>);</span><br><span class="line">    points = makeFootprintFromRadius(robot_radius);</span><br><span class="line">    nh.setParam(<span class="string">"robot_radius"</span>, robot_radius);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Else neither param was found anywhere this knows about, so</span></span><br><span class="line">  <span class="comment">// defaults will come from dynamic_reconfigure stuff, set in</span></span><br><span class="line">  <span class="comment">// cfg/Costmap2D.cfg and read in this file in reconfigureCB().</span></span><br><span class="line">  <span class="keyword">return</span> points;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数检查通用代价地图的yaml里是否定义了<code>footprint</code>和<code>robot_radius</code>参数.前者优先,如果<code>footprint</code>已经定义了,就把它做轮廓,不再处理<code>robot_radius</code>. 我目前用的是<code>robot_radius</code>,所以再看<code>makeFootprintFromRadius</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;geometry_msgs::Point&gt; makeFootprintFromRadius(<span class="keyword">double</span> radius)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;geometry_msgs::Point&gt; points;</span><br><span class="line">  <span class="comment">// Loop over 16 angles around a circle making a point each time</span></span><br><span class="line">  <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line">  geometry_msgs::Point pt;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">double</span> angle = i * <span class="number">2</span> * M_PI / N;</span><br><span class="line">    pt.x = <span class="built_in">cos</span>(angle) * radius;</span><br><span class="line">    pt.y = <span class="built_in">sin</span>(angle) * radius;</span><br><span class="line"></span><br><span class="line">    points.push_back(pt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> points;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实是把圆形处理成了一个正十六边形,把顶点的坐标都放到容器里. 这个容器最终就是<code>setUnpaddedRobotFootprint</code>的参数<br><img src="https://i.loli.net/2020/10/24/cU9vqX6PhMEYdp4.png" alt="正十六边形"></p><p>正十六边形的外接圆半径是内接圆半径的<strong>1.01959</strong>倍</p><h2 id="setUnpaddedRobotFootprint"><a href="#setUnpaddedRobotFootprint" class="headerlink" title="setUnpaddedRobotFootprint"></a>setUnpaddedRobotFootprint</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Costmap2DROS::setUnpaddedRobotFootprint(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;geometry_msgs::Point&gt;&amp; points)</span><br><span class="line">&#123;</span><br><span class="line">  unpadded_footprint_ = points;</span><br><span class="line">  padded_footprint_ = points;</span><br><span class="line">  padFootprint(padded_footprint_, footprint_padding_);</span><br><span class="line"></span><br><span class="line">  layered_costmap_-&gt;setFootprint(padded_footprint_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setUnpaddedRobotFootprint</code>主要是对<code>padded_footprint_</code>赋值,和<code>setFootprint</code>函数</p><p><code>footprint_padding_</code>只用于<code>reconfigureCB</code>,可以不看. <code>padFootprint</code>就是处理padding的情况,但我们的<code>footprint_padding</code>参数为0, 所以也不看了.</p><p>当话题上收到footprint时，回调函数会将接收到的footprint根据参数<code>footprint_padding_</code>的值进行“膨胀”，得到“膨胀”后的padded_footprint_，传递给各级地图。</p><p>调用了这个函数的还有<code>setUnpaddedRobotFootprintRadius</code>回调函数 和 <code>setUnpaddedRobotFootprintPolygon</code>回调函数,前者对应<code>footprint_radius</code><strong>参数值</strong>做的话题, 后者对应<code>footprint_topic</code><strong>参数值</strong>做的话题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> LayeredCostmap::setFootprint(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;geometry_msgs::Point&gt;&amp; footprint_spec)</span><br><span class="line">&#123;</span><br><span class="line">  footprint_ = footprint_spec;</span><br><span class="line">  costmap_2d::calculateMinAndMaxDistances(footprint_spec, inscribed_radius_, circumscribed_radius_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;boost::<span class="built_in">shared_ptr</span>&lt;Layer&gt; &gt;::iterator plugin = plugins_.begin(); plugin != plugins_.end();</span><br><span class="line">      ++plugin)</span><br><span class="line">  &#123;</span><br><span class="line">    (*plugin)-&gt;onFootprintChanged();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>calculateMinAndMaxDistances</code>很重要,它可求得<code>robot_inscribed_radius_: 0.255004</code> 和 <code>robot_circumscribed_radius: 0.26</code></p><p>这里的plugin就是全局和局部代价地图里定义的<code>plugins</code>成员,别忘了MoveBase里有两个代价地图,对plugin的添加在<code>Costmap2DROS</code>的构造函数里.</p><p>每一层都调用了<code>onFootprintChanged</code>,但是只有膨胀层覆盖了基类函数,也就是<code>InflationLayer::onFootprintChanged()</code>,这个在另一篇文章分析. 其它层没有覆盖，还是调用的Layer类的空函数<code>virtual void onFootprintChanged() {}</code></p><p>机器人轮廓之所以能在导航时也行走,原因在<code>updateMap</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Costmap2DROS::updateMap()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (!stop_updates_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// get pose in global frame of costmap</span></span><br><span class="line">    tf::Stamped &lt; tf::Pose &gt; pose;</span><br><span class="line">    <span class="keyword">if</span> (getRobotPose (pose))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">double</span> x = pose.getOrigin().x(),</span><br><span class="line">             y = pose.getOrigin().y(),</span><br><span class="line">             yaw = tf::getYaw(pose.getRotation());</span><br><span class="line"></span><br><span class="line">      layered_costmap_-&gt;updateMap(x, y, yaw);</span><br><span class="line"></span><br><span class="line">      geometry_msgs::PolygonStamped footprint;</span><br><span class="line">      footprint.header.frame_id = global_frame_;</span><br><span class="line">      footprint.header.stamp = ros::Time::now();</span><br><span class="line">      transformFootprint(x, y, yaw, padded_footprint_, footprint);</span><br><span class="line">      footprint_pub_.publish(footprint);</span><br><span class="line"></span><br><span class="line">      initialized_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑不复杂,<code>padded_footprint_</code>就是上面的十六变形的Point容器,<code>transformFootprint</code>是更新机器人行走时的轮廓,原理和里程计解算类似.</p><p><code>footprint_pub_</code>发布的话题是<code>/move_base/local_costmap/footprint</code>,对应机器人的形状，打开rviz放大，会看到它是一个十六边形。</p><h2 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h2><h3 id="参数-footprint-padding"><a href="#参数-footprint-padding" class="headerlink" title="参数 footprint_padding"></a>参数 footprint_padding</h3><p><code>Padding</code>为机器人和障碍物之间提供了额外的距离, 打开<code>rqt_reconfigure</code>调整全局代价地图的参数<code>footprint_padding</code>，膨胀层和障碍层会变化。调整局部代价地图的<code>footprint_padding</code>，机器人轮廓会成比例放大和缩小。如果确实需要改变这个参数，两个代价地图的都要改变。</p><p><a href="https://www.youtube.com/watch?v=sCpVcY2a8G8&feature=youtu.be" target="_blank" rel="noopener">调整的过程</a></p><h3 id="话题-footprint-radius-和-polygon-footprint"><a href="#话题-footprint-radius-和-polygon-footprint" class="headerlink" title="话题 footprint_radius 和 polygon_footprint"></a>话题 footprint_radius 和 polygon_footprint</h3><p>这个和padding是不同的机制，用话题的方式在线更改机器人的轮廓，原因在源码中的这一段，<code>footprint_radius</code>是自己加的，注意全局和局部代价地图的相应话题都只发布一次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private_nh.param(topic_param, topic, <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"footprint"</span>));</span><br><span class="line"></span><br><span class="line">footprint_sub_ = private_nh.subscribe(topic, <span class="number">1</span>, &amp;Costmap2DROS::setUnpaddedRobotFootprintPolygon, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private_nh.param(<span class="string">"footprint_radius"</span>, footprint_radius_topic_, <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"footprint_radius"</span>));</span><br><span class="line"></span><br><span class="line">radius_sub_ = private_nh.subscribe(footprint_radius_topic_, <span class="number">1</span>, &amp;Costmap2DROS::setUnpaddedRobotFootprintRadius, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>两个回调函数都是调用函数<code>setUnpaddedRobotFootprint</code>,对于<code>radius</code>的情况，也就是圆形底盘，还是把圆按正十六边形处理。</p><p>可以用命令测试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rostopic pub -1 /move_base/local_costmap/footprint_radius std_msgs/Float32 <span class="string">'0.34'</span></span><br><span class="line">rostopic pub -1 /move_base/global_costmap/footprint_radius std_msgs/Float32 <span class="string">'0.34'</span></span><br><span class="line"></span><br><span class="line">rostopic pub -1 /move_base/local_costmap/polygon_footprint geometry_msgs/Polygon <span class="string">'[ [-0.3, 0.3], [0.3,0.3], [0.3,-0.3], [-0.3,-0.3] ]'</span></span><br><span class="line"></span><br><span class="line">rostopic pub -1 /move_base/global_costmap/polygon_footprint geometry_msgs/Polygon <span class="string">'[ [-0.3, 0.3], [0.3,0.3], [0.3,-0.3], [-0.3,-0.3] ]'</span></span><br></pre></td></tr></table></figure><h2 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h2><p>Take in mind, that each additional edge significantly increases the required computation time! You may copy your footprint model from your costmap common parameter file.</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>robot_radius为0.26时，16边形的顶点坐标如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">x:0.260000,  y:0.000000</span><br><span class="line">x:0.240209,  y:0.099498</span><br><span class="line">x:0.183848,  y:0.183848</span><br><span class="line">x:0.099498,  y:0.240209</span><br><span class="line">x:0.000000,  y:0.260000</span><br><span class="line">x:-0.099498, y:0.240209</span><br><span class="line">x:-0.183848, y:0.183848</span><br><span class="line">x:-0.240209, y:0.099498</span><br><span class="line">x:-0.260000, y:0.000000</span><br><span class="line">x:-0.240209, y:-0.099498</span><br><span class="line">x:-0.183848, y:-0.183848</span><br><span class="line">x:-0.099498, y:-0.240209</span><br><span class="line">x:-0.000000, y:-0.260000</span><br><span class="line">x:0.099498,  y:-0.240209</span><br><span class="line">x:0.183848,  y:-0.183848</span><br><span class="line">x:0.240209,  y:-0.099498</span><br></pre></td></tr></table></figure><h2 id="计算footprint的内切圆半径和外切圆半径"><a href="#计算footprint的内切圆半径和外切圆半径" class="headerlink" title="计算footprint的内切圆半径和外切圆半径"></a>计算footprint的内切圆半径和外切圆半径</h2><p>计算<code>footprint</code>的内切圆半径和外切圆半径，用到点到线段的距离，计算方法是两个向量的点积等于一个向量在另一个向量的投影乘以另一个向量的模</p><p>点到线段的三种情况如下:</p><p>/*作用：计算点到线段的距离<br>*参数：pX，pY 是中心点坐标</p><ul><li>x0，y0，x1，y2 线段两端的坐标，求点到线段的距离</li><li>用向量点乘 来计算</li><li>/<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distanceToLine</span><span class="params">(<span class="keyword">double</span> pX, <span class="keyword">double</span> pY, <span class="keyword">double</span> x0, <span class="keyword">double</span> y0, <span class="keyword">double</span> x1, <span class="keyword">double</span> y1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> A = pX - x0; <span class="comment">//向量AP的x值</span></span><br><span class="line">  <span class="keyword">double</span> B = pY - y0; <span class="comment">//向量AP 的y中</span></span><br><span class="line">  <span class="keyword">double</span> C = x1 - x0; <span class="comment">//向量AB的x值</span></span><br><span class="line">  <span class="keyword">double</span> D = y1 - y0; <span class="comment">//向量AB的y值</span></span><br><span class="line">  <span class="comment">//向量AP与向量AB的点积</span></span><br><span class="line">  <span class="keyword">double</span> dot = A * C + B * D;</span><br><span class="line">  <span class="comment">//向量AB的模的平方</span></span><br><span class="line">  <span class="keyword">double</span> len_sq = C * C + D * D;</span><br><span class="line">  <span class="comment">//r 的值</span></span><br><span class="line">  <span class="keyword">double</span> param = dot / len_sq;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">double</span> xx, yy;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (param &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    xx = x0;</span><br><span class="line">    yy = y0;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (param &gt; <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    xx = x1;</span><br><span class="line">    yy = y1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//向量AC=r*向量AB</span></span><br><span class="line">    xx = x0 + param * C;</span><br><span class="line">    yy = y0 + param * D;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//计算AC的距离即可</span></span><br><span class="line">  <span class="keyword">return</span> distance(pX, pY, xx, yy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/路径规划/move_base分析/导航相关的节点和动态库之间的关系/">导航相关的节点和动态库之间的关系</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/move-base分析/">move_base分析</a></span><div class="content"><p>注意<code>devel/lib</code>里的so文件权限是<code>rwxrwxr-x</code>，<code>install/lib</code>里的so文件权限是<code>rw-r--r--</code></p><p>节点move_base由很多库链接,一部分是<code>/opt/ros/kinetic</code>目录的ROS基本库文件,另一部分是<code>/usr/lib/x86_64-linux-gnu</code>的系统库文件,除此之外的重要库文件只有:</p><ul><li>libmove_base.so</li><li>libbase_local_planner.so</li><li>libcostmap_2d.so</li><li>libvoxel_grid.so</li><li>libteb_local_planner.so</li></ul><p>同理,<code>libmove_base.so</code>的重要链接库:</p><ul><li>libbase_local_planner.so</li><li>libcostmap_2d.so</li><li>libvoxel_grid.so</li></ul><p>依次检查其他库文件,由于<code>base_local_planner</code>一般不修改,所以重要的其实就是<code>libmove_base.so</code>, <code>libcostmap_2d.so</code>, <code>libvoxel_grid.so</code></p><h2 id="libteb-local-planner-so"><a href="#libteb-local-planner-so" class="headerlink" title="libteb_local_planner.so"></a>libteb_local_planner.so</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">add_library( teb_local_planner</span><br><span class="line"></span><br><span class="line">   src/timed_elastic_band.cpp</span><br><span class="line">   src/optimal_planner.cpp</span><br><span class="line">   src/obstacles.cpp</span><br><span class="line">   src/visualization.cpp</span><br><span class="line">   src/recovery_behaviors.cpp</span><br><span class="line">   src/teb_config.cpp</span><br><span class="line">   src/homotopy_class_planner.cpp</span><br><span class="line">   src/teb_local_planner_ros.cpp</span><br><span class="line">   src/graph_search.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>更新teb算法的so文件，不能只更新<code>libteb_local_planner.so</code>，而是包含以下文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libbase_local_planner.so libmove_base.so libcostmap_2d.so libvoxel_grid.so liblayers.so libteb_local_planner.so</span><br></pre></td></tr></table></figure><p><br><br><br><code>libcostmap_2d.so</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add_library(  costmap_2d</span><br><span class="line"></span><br><span class="line">  src/array_parser.cpp</span><br><span class="line">  src/costmap_2d.cpp</span><br><span class="line">  src/observation_buffer.cpp</span><br><span class="line">  src/layer.cpp</span><br><span class="line">  src/layered_costmap.cpp</span><br><span class="line">  src/costmap_2d_ros.cpp</span><br><span class="line">  src/costmap_2d_publisher.cpp</span><br><span class="line">  src/costmap_math.cpp</span><br><span class="line">  src/footprint.cpp</span><br><span class="line">  src/costmap_layer.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br><br><br><code>liblayers.so</code>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add_library( layers  </span><br><span class="line"></span><br><span class="line">  plugins/inflation_layer.cpp</span><br><span class="line">  plugins/obstacle_layer.cpp</span><br><span class="line">  plugins/static_layer.cpp</span><br><span class="line">  plugins/voxel_layer.cpp</span><br><span class="line">  src/observation_buffer.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/路径规划/move_base分析/代价地图(二)/">代价地图(二)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/move-base分析/">move_base分析</a></span><div class="content"><p><img src="https://i.loli.net/2020/11/01/qzrJhU1VK3D7RLI.png" alt><br>二维costmap地图示例如图上所示。红色单元表示代价地图中的障碍物，蓝色单元表示由机器人内切半径来计算膨胀的障碍物，红色多边形表示机器人的垂直投影（footprint），浅灰色代表已知且未被占用的区域，深灰色代表未知区域。为了避免机器人与障碍碰撞，机器人的垂直投影（footprint）不能与红色单元相交，机器人的中心不能穿过蓝色单元</p><p><code>Inflation</code> is the process of propagating cost values out from occupied cells that decrease with distance. 定义了5个具体的值衡量机器人的状态</p><p><img src="https://i.loli.net/2020/11/01/I79j3x5FytE8ePY.png" alt></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> NO_INFORMATION = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> LETHAL_OBSTACLE = <span class="number">254</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> INSCRIBED_INFLATED_OBSTACLE = <span class="number">253</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> FREE_SPACE = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>注意252和127没有定义</p><br><ul><li><p><code>cost_lethal</code> 代价值254，机器人中心在一个cell里，这肯定发生碰撞</p></li><li><p><code>cost_inscribed</code> 代价值253，机器人中心所在的cell与障碍物的距离小于机器人的内切圆半径，还是肯定碰撞，cell的代价值大于等于<code>inscribed cost</code></p></li><li><p><code>cost_possibly_circumscribed</code> 使用机器人的外接圆半径作为 <strong>cutoff distance</strong>. 机器人中心所在cell到障碍物距离小于机器人外切圆半径，但是大于内切圆半径。 如果机器人中心所在的cell大于等于这个值，是否碰撞要取决于机器人的朝向</p></li></ul><p><strong>possibly</strong>这个词表示不一定真是一个obstacle cell，而是用户自定义一个代价值的情况。比如，如果用户想让机器人应对避开一段特定的区域，应当向那段区域的代价地图插入自定义的代价值，而不考虑任何障碍物。</p><p>尽管128也在上图中，但真实的代价值受内切圆半径和外接圆半径的影响，对于源码在<code>InflationLayer::computeCost</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @brief  Given a distance, compute a cost.</span></span><br><span class="line"><span class="comment"> * @param  distance The distance from an obstacle in cells</span></span><br><span class="line"><span class="comment"> * @return A cost value for the distance */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">computeCost</span><span class="params">(<span class="keyword">double</span> distance)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> cost = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (distance == <span class="number">0</span>)</span><br><span class="line">    cost = LETHAL_OBSTACLE;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (distance * resolution_ &lt;= inscribed_radius_)</span><br><span class="line">    cost = INSCRIBED_INFLATED_OBSTACLE;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// make sure cost falls off by Euclidean distance</span></span><br><span class="line">    <span class="keyword">double</span> euclidean_distance = distance * resolution_;</span><br><span class="line">    <span class="keyword">double</span> factor = <span class="built_in">exp</span>(<span class="number">-1.0</span> * weight_ * (euclidean_distance - inscribed_radius_));</span><br><span class="line">    cost = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)((INSCRIBED_INFLATED_OBSTACLE - <span class="number">1</span>) * factor);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="障碍层-膨胀层"><a href="#障碍层-膨胀层" class="headerlink" title="障碍层  膨胀层"></a>障碍层 膨胀层</h2><p>Obstacle Map Layer：障碍层，用于动态的记录传感器感知到的障碍物信息。</p><p>Inflation Layer：膨胀层，在以上两层地图上进行膨胀（向外扩张），以避免机器人的撞上障碍物。膨胀是一个从占用cell向外传播代价的过程，距离cell越远代价越小，膨胀层会把障碍物代价膨胀直到该半径为止</p><ul><li>cost_scaling_factor:膨胀过程中应用到代价值的比例因子，代价地图中到实际障碍物距离<strong>在内切圆半径到膨胀半径之间的所有cell</strong>可以使用如下公式来计算膨胀代价：<br><code>exp(-1.0 * cost_scaling_factor * (distance_from_obstacle - inscribed_radius)) * (costmap_2d::INSCRIBED_INFLATED_OBSTACLE - 1)</code><br>所以在上面的图里，代价值从252-127是按这个公式减小。</li></ul><p><code>costmap_2d::INSCRIBED_INFLATED_OBSTACLE</code>目前指定为254，注意： 由于在公式中cost_scaling_factor被乘了一个负数，所以增大比例因子反而会降低代价<br><img src="https://i.loli.net/2020/11/06/rS6ov8nGOR32iZw.png" alt="内切圆半径0.255，不同代价系数对应的代价曲线.png"></p><ul><li>inflation_radius:膨胀半径，膨胀层会把障碍物代价膨胀直到该半径为止，一般将该值设置为机器人底盘的直径大小。如果机器人经常撞到障碍物就需要增大该值，若经常无法通过狭窄地方就减小该值。</li></ul><p><img src="https://i.loli.net/2020/11/03/bygjtSlNdmzBYqJ.png" alt="增大膨胀半径 cost_scaling_factor=0.7.png"><br><img src="https://i.loli.net/2020/11/03/g1pjA7ioTEcwlZG.png" alt="cost_scaling_factor=65.png"><br><img src="https://i.loli.net/2020/11/03/CJtobcx9YniNFRK.png" alt="cost_scaling_factor=1.png"><br><img src="https://i.loli.net/2020/11/03/jpzMG6ZHhNxvQEd.png" alt="cost_scaling_factor=25.png"><br><img src="https://i.loli.net/2020/11/03/9IDVZ5aY1WPOFjE.png" alt="默认cost_scaling_factor=10.png"></p><p>减小<code>cost_scaling_factor</code>，使代价值增大，rviz里的膨胀层变为红色。还可以查看话题<code>/move_base/local_ctmap/costmap_updates</code>，会发现一些数值变大</p><p><strong>全局代价地图一般膨胀较多，使机器人转弯顺利。局部代价地图膨胀较少，使机器人能穿过窄通道。</strong> 但是局部代价可以不用膨胀层，这是因为TEB已有障碍物膨胀功能</p><br><p>添加了静态层、障碍层、膨胀层的代价地图是这样的：<br><img src="https://i.loli.net/2020/11/01/aGEMh27qtwVm5PB.png" alt="11-01__172228.png"></p><p>如果代价地图不添加膨胀层，结果是这样：<br><img src="https://i.loli.net/2020/11/01/i3o4MFUwGJhOLZY.png" alt="11-01__172326.png"></p><p>但是加不加障碍层，看上去没有变化</p><p>目前无法在rviz里直接可视化每一层</p><h2 id="Costmap2DROS类的源码"><a href="#Costmap2DROS类的源码" class="headerlink" title="Costmap2DROS类的源码"></a>Costmap2DROS类的源码</h2><p><code>Costmap2DROS</code>对象提供了纯二维接口，meaning that queries about obstacles can only be made in columns.</p><ul><li><code>bool getRobotPose(tf::Stamped&lt;tf::Pose&gt;&amp; global_pose) const</code> 获取机器人在代价地图的<code>global frame</code>中的位姿</li></ul><p><a href="https://blog.csdn.net/u011608180/article/details/106549423" target="_blank" rel="noopener">Costmap2DROS::getRobotPose函数调用分析</a></p><ul><li><code>base_local_planner::OdometryHelperRos odom_helper_;</code> //提供给用户获取当前机器人速度的接口</li></ul><br><ul><li><p><code>geometry_msgs::Polygon getRobotFootprintPolygon()</code> 获取机器人边界（在机器人坐标系下，包含padding）</p></li><li><p><code>std::vector&lt;geometry_msgs::Point&gt; getRobotFootprint()</code> 获取机器人边界（在机器人坐标系下，包含padding）</p></li><li><p><code>std::vector&lt;geometry_msgs::Point&gt;getUnpaddedRobotFootprint()</code> 获取机器人边界（在机器人坐标系下，不包含padding）</p></li><li><p><code>void getOrientedFootprint(std::vector&lt;geometry_msgs::Point&gt;&amp; oriented_footprint) const</code> 获取机器人边界（在地图全局坐标系下，包含padding）</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return a pointer to the "master" costmap which receives updates from all the layers.  Same as calling getLayeredCostmap()-&gt;getCostmap() */</span></span><br><span class="line"><span class="function">Costmap2D* <span class="title">getCostmap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> layered_costmap_-&gt;getCostmap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/ROS/ROS机器人/stage的使用心得/">stage的使用心得</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS机器人/">ROS机器人</a></span><div class="content"><p>stage的使用心得</p><p>Stage can simulate noisy odometry</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun stage_ros stageros /opt/ros/melodic/share/stage_ros/world/willow-erratic.world</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/Matlab/将多个函数曲线在同一张图显示/">将多个函数曲线在同一张图显示</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Matlab/">Matlab</a></span><div class="content"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">x=0:0.01:4;  % x从1到4，绘图采样间隔为0.01</span><br><span class="line">y1=252*exp(-10*(x-radius));</span><br><span class="line">y1=10*x+3;</span><br><span class="line">y2=exp(2*x);</span><br><span class="line">y3=sin(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plot(x,y1,<span class="string">'o-'</span>,<span class="string">'color'</span>,<span class="string">'r'</span>);   %画出图形</span><br><span class="line">hold on;  	%继续画图</span><br><span class="line">plot(x,y2,<span class="string">'s-'</span>,<span class="string">'color'</span>,<span class="string">'k'</span>);</span><br><span class="line">hold on;  	%继续画图</span><br><span class="line">plot(x,y3,<span class="string">'*-'</span>,<span class="string">'color'</span>,<span class="string">'y'</span>);</span><br><span class="line"></span><br><span class="line">grid on;     % 添加网格，这是用默认的最小标度画出的网格</span><br><span class="line">axis([-5 10 -10 50]);     % x轴的范围是[-5, 10], y轴范围[-10,50]</span><br><span class="line"></span><br><span class="line">xlabel(<span class="string">'时间'</span>);     %设置X轴含义：时间</span><br><span class="line">ylabel(<span class="string">'目标'</span>);   %设置X轴含义：零件数</span><br><span class="line"></span><br><span class="line">legend(<span class="string">'y1'</span>,<span class="string">'y2'</span>,<span class="string">'y3'</span>);</span><br></pre></td></tr></table></figure><p>一个图中画多个曲线记得使用hold on，否则之前画的曲线将会被覆盖掉！</p><p>标识号曲线有两种方法：(1)通过不同的颜色；(2)通过不同的线形；</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">颜色          定义符  </span><br><span class="line"></span><br><span class="line">红色          R（red）</span><br><span class="line"></span><br><span class="line">绿色          G(green)</span><br><span class="line"></span><br><span class="line">兰色          b(blue)</span><br><span class="line"></span><br><span class="line">青色          c(cyan)</span><br><span class="line"></span><br><span class="line">品红          M(magenta)</span><br><span class="line"></span><br><span class="line">黄色          y(yellow)</span><br><span class="line"></span><br><span class="line">黑色          k(black)</span><br><span class="line"></span><br><span class="line">白色          w(white)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">线形            符号</span><br><span class="line"></span><br><span class="line">实线             -</span><br><span class="line"></span><br><span class="line">圈圈             o</span><br><span class="line"></span><br><span class="line">星星             *</span><br><span class="line"></span><br><span class="line">正方形           s</span><br><span class="line"></span><br><span class="line">正六角星         h</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/ROS/ROS Kinetic知识/常用的tf命令/">常用的tf命令</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic知识/">ROS Kinetic知识</a></span><div class="content"><ol><li>rosrun tf view_frames</li></ol><p>当启动ROS程序后，如果想查看存在的所有坐标系转换关系，可以使用命令<code>rosrun tf view_frames</code>，结果会在当前目录生成pdf文件：<br><img src="https://c2.staticflickr.com/8/7850/46490602034_1924870de3_b.jpg" alt><br>顺便说一下，打开pdf的命令为<code>evince frames.pdf</code></p><ol start="2"><li>rosrun rqt_tf_tree rqt_tf_tree</li></ol><p>跟上一个命令差不多，区别是直接打开一个pdf文件，但不会保存</p><p>在仿真环境下，使用<code>rostopic hz tf</code>，发现tf的频率是40Hz左右，这个数值是各个tf变化叠加的结果，使用<code>rqt_tf_tree</code>可以看到<br><img src="https://i.loli.net/2020/11/01/ZdnNrFjezJoAtay.png" alt="11-01__105511.png"></p><p>有些转换可能显示average rate有数值，但是buffer 和 recent transform都是0，这种其实没有发生tf，所以不能算数。</p><br>左上角还有一个`clear buffer`按钮，`Buffer length`会清零 `Buffer length`表示`tf buffer`中有几秒的数据可使用，`rqt_tf_tree`中是10秒，`view frames`大约5秒<ol start="3"><li>tf_echo</li></ol><p>本命令用来查看两个坐标系之间的实时转换，需要5秒钟：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun tf tf_echo /turtle1 /turtle2  　//turtle1是parent坐标系, turtle2是child</span><br></pre></td></tr></table></figure><p><img src="https://c2.staticflickr.com/8/7834/40261688443_57d3ca29b1_b.jpg" alt></p><ol start="4"><li>rqt_tf_tree</li></ol><p><code>rosrun rqt_tf_tree rqt_tf_tree</code>显示一个带界面的tf图显示工具，不必等待，然后可以另存为svg,png等格式<br>结果发现刷新按钮不好用，当tf树改变后，刷新有时没有改变显示，有时工具无法响应了</p><ol start="5"><li>launch文件中的应用</li></ol><p>如果要让两个坐标系建立转换关系，常常在launch文件中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">args</span>=<span class="string">"-0.24 0 0.295 1.571 0 -1.571 /base_link /camera 10"</span> <span class="attr">pkg</span>=<span class="string">"tf"</span> <span class="attr">name</span>=<span class="string">"base_link_to_camera"</span> <span class="attr">type</span>=<span class="string">"static_transform_publisher"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这个节点就是以<code>base_link</code>为parent坐标系，向<code>camera</code>转换的欧拉角形式。前三个参数是x,y,z三个方向的位移，之后的三个参数是yaw,pitch,roll，然后是parent坐标系和child坐标系，最后是隔多长时间发送一次变换，一般取100(ms)。另一种形式就是四元数形式，也就是将第4~6参数换为qx,qy,qz,qw。</p></div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/46/">46</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image:url(https://i.loli.net/2020/07/13/QgyrefaLDxhBWSZ.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>