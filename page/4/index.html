<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG={root:"/",algolia:{appId:"RI90VLL69D",apiKey:"20c535e9a1424a7913210eb747d6e67b",indexName:"HexoBlog",hits:{per_page:10},languages:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}.",hits_stats:"${hits} results found in ${time} ms"}},localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">465</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">52</span></a></div></div></div><nav id="nav" style="background-image:url(https://i.loli.net/2020/07/13/QgyrefaLDxhBWSZ.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div><div id="site-social-icons"><a class="social-icon" href="https://github.com/charon-cheung"><i class="fa-github fa"></i></a><a class="social-icon search"><i class="fa fa-search"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/路径规划/单通道/">one_way_layer</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/其他/">其他</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2020/11/15/路径规划/单通道/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/路径规划/问题累计/">问题累计</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/其他/">其他</a></span><div class="content"><h2 id="roslaunch-move-base-出错"><a href="#roslaunch-move-base-出错" class="headerlink" title="roslaunch move_base 出错"></a>roslaunch move_base 出错</h2><p><img src="https://i.loli.net/2020/10/29/48kJ1pXONBv5Qus.png" alt="roslaunch 不识别move_base.png"></p><p>其他launch没问题，使用<code>file</code>命令，原来它真是个shell脚本<br><img src="https://i.loli.net/2020/10/29/Y1Mdw2aU4HWsG7P.png" alt="xml被识别为shell脚本.png"><br>但是新建一个launch，类型正常了，但是仍然失败。</p><p>结果发现是虚拟机关闭时，是直接关标签，不是正常关机<br><img src="https://i.loli.net/2020/10/29/Na2HqlwQvirIJ4Y.png" alt=".so文件损坏.png"><br><img src="https://i.loli.net/2020/10/29/UubkI3VXChzn2Lj.png" alt=".so文件损坏 1.png"><br>只好重新编译了</p><h2 id="occupied-thresh"><a href="#occupied-thresh" class="headerlink" title="occupied_thresh"></a>occupied_thresh</h2><p>occupied_thresh：大于这个阀值的占用率的像素被认为occupied。</p><p>free_thresh：小于这个阀值的占用率的像素被认为是free。</p><p>如果<code>occupied_thresh</code>设置的比较大，有些障碍物会没有障碍层和膨胀层。<br><img src="https://i.loli.net/2020/11/01/o2GKIMYJlDAT9aj.png" alt="occupied_thresh=0.85.png"><br>结果会使机器人导航时出错</p><p>如果建图时，障碍的边缘不够明显，也可能出现此问题，此时可以降低<code>occupied_thresh</code></p><p>其实还可以降低参数<code>cost_scaling_factor</code>，不过可能影响较大。</p><h2 id="echo话题没有结果"><a href="#echo话题没有结果" class="headerlink" title="echo话题没有结果"></a>echo话题没有结果</h2><p><code>ech /clicked_point</code>，结果报错:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: no messages received and simulated time is active.</span><br><span class="line">Is /clock being published?</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/路径规划/move_base分析/move_base相关工具和命令/">move_base相关工具和命令</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/move-base分析/">move_base分析</a></span><div class="content"><h2 id="发导航命令"><a href="#发导航命令" class="headerlink" title="发导航命令"></a>发导航命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rostopic pub /move_base_simple/goal geometry_msgs/PoseStamped <span class="string">"header:</span></span><br><span class="line"><span class="string">  seq: 0</span></span><br><span class="line"><span class="string">  stamp:</span></span><br><span class="line"><span class="string">    secs: 0</span></span><br><span class="line"><span class="string">    nsecs: 0</span></span><br><span class="line"><span class="string">  frame_id: 'map'</span></span><br><span class="line"><span class="string">pose:</span></span><br><span class="line"><span class="string">  position:</span></span><br><span class="line"><span class="string">    x: 60.0</span></span><br><span class="line"><span class="string">    y: -6.0</span></span><br><span class="line"><span class="string">    z: 0.0</span></span><br><span class="line"><span class="string">  orientation:</span></span><br><span class="line"><span class="string">    x: 0.0</span></span><br><span class="line"><span class="string">    y: 0.0</span></span><br><span class="line"><span class="string">    z: 0.0</span></span><br><span class="line"><span class="string">    w: 1.0"</span></span><br></pre></td></tr></table></figure><h2 id="停止导航"><a href="#停止导航" class="headerlink" title="停止导航"></a>停止导航</h2><p>一句话命令：<code>rostopic pub /move_base/cancel actionlib_msgs/GoalID -- {}</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ros::Publisher cancle_pub_ = nh_.advertise(<span class="string">"move_base/cancel"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">actionlib_msgs::GoalID first_goal;</span><br><span class="line"></span><br><span class="line">cancle_pub_.publish(first_goal);</span><br><span class="line"></span><br><span class="line">ros/move_base终止正在进行的导航navigation</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/27/xCA47pHcQZOEIDu.png" alt="停止导航.png"></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/cmake qmake/cmake教程（七）CMAKE_INSTALL_PREFIX/">cmake教程（七）CMAKE_INSTALL_PREFIX</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cmake-qmake/">cmake/qmake</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/编译调试/">编译调试</a></span><div class="content"><h2 id="CMAKE-INSTALL-PREFIX"><a href="#CMAKE-INSTALL-PREFIX" class="headerlink" title="CMAKE_INSTALL_PREFIX"></a>CMAKE_INSTALL_PREFIX</h2><p><code>CMAKE_INSTALL_PREFIX</code>变量类似于configure脚本的<code>–prefix</code>，常见的使用方法是在build文件夹里执行<code>cmake -DCMAKE_INSTALL_PREFIX=/usr ..</code></p><p>INSTALL指令用于定义安装规则，安装的内容可以包括目标二进制、动态库、静态库以及<br>文件、目录、脚本等。</p><p>检查CMakelist文件发现路径是<code>include_directories(&quot;/usr/include/eigen3&quot;)</code></p><p>检查eigen3的路径，发现我的是<code>/usr/local/include/eigen3/Eigen</code>，可以链接对应的文件，即进行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/include/eigen3/Eigen /usr/include/Eigen</span><br></pre></td></tr></table></figure><p><code>sudo ln -s 源文件 目标文件</code>是一个常用的linux命令，功能是为源文件在目标文件的位置建立一个同步的链接，当二者建立联系后即可在源文件中访问目标文件。</p><p>链接有两种，一种被称为硬链接(Hard Link)，另一种被称为符号链接(Symbolic Link). 建立硬链接时，链接文件和被链接文件必须位于同一个文件系统中，并且不能建立指向目录的硬链接。默认情况下，ln产生硬链接。如果给ln命令加上- s选项，则建立符号链接。</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/路径规划/move_base分析/OdometryHelperRos 解析/">OdometryHelperRos 解析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/move-base分析/">move_base分析</a></span><div class="content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OdometryHelperRos</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** @brief Constructor.</span></span><br><span class="line"><span class="comment">   * @param odom_topic The topic on which to subscribe to Odometry</span></span><br><span class="line"><span class="comment">   *        messages.  If the empty string is given (the default), no</span></span><br><span class="line"><span class="comment">   *        subscription is done. */</span></span><br><span class="line">  OdometryHelperRos(<span class="built_in">std</span>::<span class="built_in">string</span> odom_topic = <span class="string">""</span>)</span><br><span class="line">  &#123; </span><br><span class="line">    setOdomTopic( odom_topic ); </span><br><span class="line">  &#125;</span><br><span class="line">  ~OdometryHelperRos() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">odomCallback</span><span class="params">(<span class="keyword">const</span> nav_msgs::Odometry::ConstPtr&amp; msg)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getOdom</span><span class="params">(nav_msgs::Odometry&amp; base_odom)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getRobotVel</span><span class="params">(tf::Stamped&lt;tf::Pose&gt;&amp; robot_vel)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** @brief Set the odometry topic.  This overrides what was set in the constructor, if anything.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * This unsubscribes from the old topic (if any) and subscribes to the new one (if any).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * If odom_topic is the empty string, this just unsubscribes from the previous topic. */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setOdomTopic</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> odom_topic)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getOdomTopic</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> odom_topic_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> odom_topic_;</span><br><span class="line">  <span class="comment">// we listen on odometry on the odom topic</span></span><br><span class="line">  ros::Subscriber odom_sub_;</span><br><span class="line">  nav_msgs::Odometry base_odom_;</span><br><span class="line">  boost::mutex odom_mutex_;</span><br><span class="line">  <span class="comment">// global tf frame id</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> frame_id_; <span class="comment">///&lt; The frame_id associated this data</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是base_local_planner局部规划器里起辅助功能的一个类,主要作用就是从/odom的topic中获取机器人的速度状态(包括线速度(x,y),和角速度z)</p><p>TrajectoryPlannerROS局部规划器初始化的时候便调用这个类初始化/odom topic</p><p>要使用，首先<code>#include &lt;base_local_planner/odometry_helper_ros.h&gt;</code>，</p><p>OdometryHelperRos()在初始化的时候,新建了NodeHandle并设置关注的topic的名称odom_topic;<br>并在回调函数odomCallback()中, 取出速度信息</p><h2 id="和Teb算法的关系"><a href="#和Teb算法的关系" class="headerlink" title="和Teb算法的关系"></a>和Teb算法的关系</h2><p>类<code>TrajectoryPlannerROS</code>中定义： <code>base_local_planner::OdometryHelperRos odom_helper_;</code></p><p>move_base的yaml中，对局部路径规划配置：<code>teb_local_planner/TebLocalPlannerROS</code></p><p>MoveBase中有一段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private_nh.param(<span class="string">"base_local_planner"</span>, local_planner, <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"base_local_planner/TrajectoryPlannerROS"</span>));</span><br><span class="line">tc_ = blp_loader_.createInstance(local_planner);</span><br><span class="line">tc_-&gt;initialize(blp_loader_.getName(local_planner), &amp;tf_, controller_costmap_ros_);</span><br></pre></td></tr></table></figure><h2 id="base-local-planner-stopped"><a href="#base-local-planner-stopped" class="headerlink" title="base_local_planner::stopped"></a>base_local_planner::stopped</h2><p>这是一个类似的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">stopped</span><span class="params">(<span class="keyword">const</span> nav_msgs::Odometry&amp; base_odom, </span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="keyword">double</span>&amp; rot_stopped_velocity, <span class="keyword">const</span> <span class="keyword">double</span>&amp; trans_stopped_velocity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(base_odom.twist.twist.angular.z) &lt;= rot_stopped_velocity </span><br><span class="line">      &amp;&amp; <span class="built_in">fabs</span>(base_odom.twist.twist.linear.x) &lt;= trans_stopped_velocity</span><br><span class="line">      &amp;&amp; <span class="built_in">fabs</span>(base_odom.twist.twist.linear.y) &lt;= trans_stopped_velocity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/xinmei4275/article/details/87863686" target="_blank" rel="noopener">OdometryHelperRos类</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/路径规划/move_base分析/CostmapModel/">CostmapModel</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/move-base分析/">move_base分析</a></span><div class="content"><p>CostmapModel类则能够获取点、连线、多边形轮廓的cost，是局部规划器与costmap间的一个桥梁。一般如下使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">world_model_ = <span class="keyword">new</span> base_local_planner::CostmapModel(*(planner_costmap_ros_ -&gt;getCostmap()) ); </span><br><span class="line"><span class="comment">//costmap_2d::Costmap2DROS*  planner_costmap_ros_</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;geometry_msgs::Point&gt; footprint = planner_costmap_ros_-&gt;getRobotFootprint();</span><br><span class="line"><span class="keyword">double</span> footprint_cost = world_model_-&gt;footprintCost(x_i, y_i, theta_i, footprint);</span><br><span class="line"></span><br><span class="line"><span class="comment">// footprint.size() 16</span></span><br></pre></td></tr></table></figure><p><code>CostmapModel</code>类帮助local planner在Costmap上进行计算, <code>footprintCost</code>, <code>lineCost</code>, <code>pointCost</code>三个类方法分别能通过Costmap计算出机器人足迹范围、两个cell连线、单个cell的代价，并将值返回给局部规划器。</p><p>若预设的足迹点数&lt;3，考虑足迹的形状没有意义，只计算机器人位置点在costmap上的代价。<br>若预设的足迹点数≥3，把足迹视为多边形，循环调用<code>lineCost</code>计算多边形各边的cell，注意首尾闭合，最后返回代价。对于圆形底盘，足迹点数是16,也就是在costmap里把圆形按16边形处理。</p><p>返回值:</p><ul><li>-1.0 ：覆盖至少一个障碍cell</li><li>-2.0 ：覆盖至少一个未知cell</li><li>-3.0 ：不在地图上</li><li>其他: a positive value for traversable space</li></ul><p>其实没有撞障碍时，返回值是0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> CostmapModel::footprintCost(<span class="keyword">const</span> geometry_msgs::Point&amp; position, </span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;geometry_msgs::Point&gt;&amp;  footprint,</span><br><span class="line">    <span class="keyword">double</span> inscribed_radius,  <span class="keyword">double</span> circumscribed_radius )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//used to put things into grid coordinates</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cell_x, cell_y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the cell coord of the center point of the robot</span></span><br><span class="line">    <span class="keyword">if</span>(!costmap_.worldToMap(position.x, position.y, cell_x, cell_y))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-3.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//footprint的点少于3个，只取点位置的代价</span></span><br><span class="line">    <span class="keyword">if</span>(footprint.size() &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">char</span> cost = costmap_.getCost(cell_x, cell_y);</span><br><span class="line">      <span class="keyword">if</span>(cost == NO_INFORMATION)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2.0</span>;</span><br><span class="line">      <span class="keyword">if</span>(cost == LETHAL_OBSTACLE || cost == INSCRIBED_INFLATED_OBSTACLE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">      <span class="keyword">return</span> cost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//now we really have to lay down the footprint in the costmap grid</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> x0, x1, y0, y1;</span><br><span class="line">    <span class="keyword">double</span> line_cost = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">double</span> footprint_cost = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">//we need to rasterize each line in the footprint</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; footprint.size() - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//get the cell coord of the first point</span></span><br><span class="line">      <span class="keyword">if</span>(!costmap_.worldToMap(footprint[i].x, footprint[i].y, x0, y0))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3.0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//get the cell coord of the second point</span></span><br><span class="line">      <span class="keyword">if</span>(!costmap_.worldToMap(footprint[i + <span class="number">1</span>].x, footprint[i + <span class="number">1</span>].y, x1, y1))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3.0</span>;</span><br><span class="line"></span><br><span class="line">      line_cost = lineCost(x0, x1, y0, y1);</span><br><span class="line">      footprint_cost = <span class="built_in">std</span>::max(line_cost, footprint_cost);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//if there is an obstacle that hits the line... we know that we can return false right away</span></span><br><span class="line">      <span class="keyword">if</span>(line_cost &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> line_cost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//we also need to connect the first point in the footprint to the last point</span></span><br><span class="line">    <span class="comment">//get the cell coord of the last point</span></span><br><span class="line">    <span class="keyword">if</span>(!costmap_.worldToMap(footprint.back().x, footprint.back().y, x0, y0))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-3.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the cell coord of the first point</span></span><br><span class="line">    <span class="keyword">if</span>(!costmap_.worldToMap(footprint.front().x, footprint.front().y, x1, y1))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-3.0</span>;</span><br><span class="line"></span><br><span class="line">    line_cost = lineCost(x0, x1, y0, y1);</span><br><span class="line">    footprint_cost = <span class="built_in">std</span>::max(line_cost, footprint_cost);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(line_cost &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> line_cost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if all line costs are legal... then we can return that the footprint is legal</span></span><br><span class="line">    <span class="keyword">return</span> footprint_cost;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://blog.csdn.net/Neo11111/article/details/104720103" target="_blank" rel="noopener">CostmapModel::footprintCost</a><br><a href="https://my.oschina.net/u/4324682/blog/3457091" target="_blank" rel="noopener">ObstacleCostFunction类，继承自Trajectory类</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/激光SLAM/Cartographer/原理和配置/扩展建图 - 在现有地图基础上继续建图/">扩展建图 - 在现有地图基础上继续建图</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/激光SLAM/Cartographer/原理和配置/">原理和配置</a></span><div class="content"><p>There is currently no way to “resume mapping” when using gmapping. Basically, the map image and yaml file do not have enough information for GMapping to resume from. The occupancy grid representation of the map (for example, the pgm bitmap) doesn’t contain enough state to resume mapping. Internally, gmapping is estimating a distribution over maps and robot trajectories, using a particle filter. To resume mapping, you’d have to save all of that internal state. In principle, it’s possible to do that, but it’s not currently implemented, and I would guess it would take quite a bit of work.</p><p>For long-term mapping, including pause-and-resume abilities, I’d go for a constraint-graph SLAM algorithm, instead of a particle filter algorithm.</p><p><a href="https://github.com/cartographer-project/cartographer/issues/1633" target="_blank" rel="noopener">https://github.com/cartographer-project/cartographer/issues/1633</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/路径规划/move_base分析/公司机器人的注意事项/">公司机器人的注意事项</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/move-base分析/">move_base分析</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2020/11/15/路径规划/move_base分析/公司机器人的注意事项/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/路径规划/move_base分析/机器人footprint的研究/">机器人footprint的研究</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/move-base分析/">move_base分析</a></span><div class="content"><p>目前所用的机器人模型是圆形,在通用代价地图里定义:<code>robot_radius: 0.26</code>,而不是<code>footprint</code>参数. 但是注意TEB里用的是Point类型.</p><p>指定<code>footprint</code>的数组元素时,点如果太多，可以换行。机器人的轮廓可能是不规则的polygon,但它的运动中心永远是(0, 0),顺时针和逆时针规范都支持。这应该是局部坐标系决定的<br><img src="https://i.loli.net/2020/11/01/JTegObBvfoEYw5n.png" alt="footprint setting.png"></p><p>现在分析源码中对这个参数的处理,<code>Costmap2DROS</code>的构造函数里有一句： <code>setUnpaddedRobotFootprint(makeFootprintFromParams(private_nh));</code>,先看括号里的函数</p><h2 id="makeFootprintFromParams"><a href="#makeFootprintFromParams" class="headerlink" title="makeFootprintFromParams"></a>makeFootprintFromParams</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;geometry_msgs::Point&gt; makeFootprintFromParams(ros::NodeHandle&amp; nh)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> full_param_name;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> full_radius_param_name;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;geometry_msgs::Point&gt; points;</span><br><span class="line">  <span class="comment">// 优先读footprint参数的值</span></span><br><span class="line">  <span class="keyword">if</span> (nh.searchParam(<span class="string">"footprint"</span>, full_param_name))</span><br><span class="line">  &#123;</span><br><span class="line">    XmlRpc::XmlRpcValue footprint_xmlrpc;</span><br><span class="line">    nh.getParam(full_param_name, footprint_xmlrpc);</span><br><span class="line">    <span class="keyword">if</span> (footprint_xmlrpc.getType() == XmlRpc::XmlRpcValue::TypeString &amp;&amp;</span><br><span class="line">        footprint_xmlrpc != <span class="string">""</span> &amp;&amp; footprint_xmlrpc != <span class="string">"[]"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (makeFootprintFromString(<span class="built_in">std</span>::<span class="built_in">string</span>(footprint_xmlrpc), points))</span><br><span class="line">      &#123;</span><br><span class="line">        writeFootprintToParam(nh, points);</span><br><span class="line">        <span class="keyword">return</span> points;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一般是这个，因为我们定义的是数组</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (footprint_xmlrpc.getType() == XmlRpc::XmlRpcValue::TypeArray)</span><br><span class="line">    &#123;</span><br><span class="line">      points = makeFootprintFromXMLRPC(footprint_xmlrpc, full_param_name);</span><br><span class="line">      writeFootprintToParam(nh, points);</span><br><span class="line">      <span class="keyword">return</span> points;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 没有 footprint再读robot_radius</span></span><br><span class="line">  <span class="keyword">if</span> (nh.searchParam(<span class="string">"robot_radius"</span>, full_radius_param_name))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">double</span> robot_radius;</span><br><span class="line">    nh.param(full_radius_param_name, robot_radius, <span class="number">1.234</span>);</span><br><span class="line">    points = makeFootprintFromRadius(robot_radius);</span><br><span class="line">    nh.setParam(<span class="string">"robot_radius"</span>, robot_radius);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Else neither param was found anywhere this knows about, so</span></span><br><span class="line">  <span class="comment">// defaults will come from dynamic_reconfigure stuff, set in</span></span><br><span class="line">  <span class="comment">// cfg/Costmap2D.cfg and read in this file in reconfigureCB().</span></span><br><span class="line">  <span class="keyword">return</span> points;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数检查通用代价地图的yaml里是否定义了<code>footprint</code>和<code>robot_radius</code>参数.前者优先,如果<code>footprint</code>已经定义了,就把它做轮廓,不再处理<code>robot_radius</code>. 我目前用的是<code>robot_radius</code>,所以再看<code>makeFootprintFromRadius</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;geometry_msgs::Point&gt; makeFootprintFromRadius(<span class="keyword">double</span> radius)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;geometry_msgs::Point&gt; points;</span><br><span class="line">  <span class="comment">// Loop over 16 angles around a circle making a point each time</span></span><br><span class="line">  <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line">  geometry_msgs::Point pt;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">double</span> angle = i * <span class="number">2</span> * M_PI / N;</span><br><span class="line">    pt.x = <span class="built_in">cos</span>(angle) * radius;</span><br><span class="line">    pt.y = <span class="built_in">sin</span>(angle) * radius;</span><br><span class="line"></span><br><span class="line">    points.push_back(pt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> points;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实是把圆形处理成了一个正十六边形,把顶点的坐标都放到容器里. 这个容器最终就是<code>setUnpaddedRobotFootprint</code>的参数<br><img src="https://i.loli.net/2020/10/24/cU9vqX6PhMEYdp4.png" alt="正十六边形"></p><p>正十六边形的外接圆半径是内接圆半径的<strong>1.01959</strong>倍</p><h2 id="setUnpaddedRobotFootprint"><a href="#setUnpaddedRobotFootprint" class="headerlink" title="setUnpaddedRobotFootprint"></a>setUnpaddedRobotFootprint</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Costmap2DROS::setUnpaddedRobotFootprint(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;geometry_msgs::Point&gt;&amp; points)</span><br><span class="line">&#123;</span><br><span class="line">  unpadded_footprint_ = points;</span><br><span class="line">  padded_footprint_ = points;</span><br><span class="line">  padFootprint(padded_footprint_, footprint_padding_);</span><br><span class="line"></span><br><span class="line">  layered_costmap_-&gt;setFootprint(padded_footprint_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setUnpaddedRobotFootprint</code>主要是对<code>padded_footprint_</code>赋值,和<code>setFootprint</code>函数</p><p><code>footprint_padding_</code>只用于<code>reconfigureCB</code>,可以不看. <code>padFootprint</code>就是处理padding的情况,但我们的<code>footprint_padding</code>参数为0, 所以也不看了.</p><p>当话题上收到footprint时，回调函数会将接收到的footprint根据参数<code>footprint_padding_</code>的值进行“膨胀”，得到“膨胀”后的padded_footprint_，传递给各级地图。</p><p>调用了这个函数的还有<code>setUnpaddedRobotFootprintRadius</code>回调函数 和 <code>setUnpaddedRobotFootprintPolygon</code>回调函数,前者对应<code>footprint_radius</code><strong>参数值</strong>做的话题, 后者对应<code>footprint_topic</code><strong>参数值</strong>做的话题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> LayeredCostmap::setFootprint(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;geometry_msgs::Point&gt;&amp; footprint_spec)</span><br><span class="line">&#123;</span><br><span class="line">  footprint_ = footprint_spec;</span><br><span class="line">  costmap_2d::calculateMinAndMaxDistances(footprint_spec, inscribed_radius_, circumscribed_radius_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;boost::<span class="built_in">shared_ptr</span>&lt;Layer&gt; &gt;::iterator plugin = plugins_.begin(); plugin != plugins_.end();</span><br><span class="line">      ++plugin)</span><br><span class="line">  &#123;</span><br><span class="line">    (*plugin)-&gt;onFootprintChanged();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>calculateMinAndMaxDistances</code>很重要,它可求得<code>robot_inscribed_radius_: 0.255004</code> 和 <code>robot_circumscribed_radius: 0.26</code></p><p>这里的plugin就是全局和局部代价地图里定义的<code>plugins</code>成员,别忘了MoveBase里有两个代价地图,对plugin的添加在<code>Costmap2DROS</code>的构造函数里.</p><p>每一层都调用了<code>onFootprintChanged</code>,但是只有膨胀层覆盖了基类函数,也就是<code>InflationLayer::onFootprintChanged()</code>,这个在另一篇文章分析. 其它层没有覆盖，还是调用的Layer类的空函数<code>virtual void onFootprintChanged() {}</code></p><p>机器人轮廓之所以能在导航时也行走,原因在<code>updateMap</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Costmap2DROS::updateMap()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (!stop_updates_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// get pose in global frame of costmap</span></span><br><span class="line">    tf::Stamped &lt; tf::Pose &gt; pose;</span><br><span class="line">    <span class="keyword">if</span> (getRobotPose (pose))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">double</span> x = pose.getOrigin().x(),</span><br><span class="line">             y = pose.getOrigin().y(),</span><br><span class="line">             yaw = tf::getYaw(pose.getRotation());</span><br><span class="line"></span><br><span class="line">      layered_costmap_-&gt;updateMap(x, y, yaw);</span><br><span class="line"></span><br><span class="line">      geometry_msgs::PolygonStamped footprint;</span><br><span class="line">      footprint.header.frame_id = global_frame_;</span><br><span class="line">      footprint.header.stamp = ros::Time::now();</span><br><span class="line">      transformFootprint(x, y, yaw, padded_footprint_, footprint);</span><br><span class="line">      footprint_pub_.publish(footprint);</span><br><span class="line"></span><br><span class="line">      initialized_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑不复杂,<code>padded_footprint_</code>就是上面的十六变形的Point容器,<code>transformFootprint</code>是更新机器人行走时的轮廓,原理和里程计解算类似.</p><p><code>footprint_pub_</code>发布的话题是<code>/move_base/local_costmap/footprint</code>,对应机器人的形状，打开rviz放大，会看到它是一个十六边形。</p><h2 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h2><h3 id="参数-footprint-padding"><a href="#参数-footprint-padding" class="headerlink" title="参数 footprint_padding"></a>参数 footprint_padding</h3><p><code>Padding</code>为机器人和障碍物之间提供了额外的距离, 打开<code>rqt_reconfigure</code>调整全局代价地图的参数<code>footprint_padding</code>，膨胀层和障碍层会变化。调整局部代价地图的<code>footprint_padding</code>，机器人轮廓会成比例放大和缩小。如果确实需要改变这个参数，两个代价地图的都要改变。</p><p><a href="https://www.youtube.com/watch?v=sCpVcY2a8G8&feature=youtu.be" target="_blank" rel="noopener">调整的过程</a></p><h3 id="话题-footprint-radius-和-polygon-footprint"><a href="#话题-footprint-radius-和-polygon-footprint" class="headerlink" title="话题 footprint_radius 和 polygon_footprint"></a>话题 footprint_radius 和 polygon_footprint</h3><p>这个和padding是不同的机制，用话题的方式在线更改机器人的轮廓，原因在源码中的这一段，<code>footprint_radius</code>是自己加的，注意全局和局部代价地图的相应话题都只发布一次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private_nh.param(topic_param, topic, <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"footprint"</span>));</span><br><span class="line"></span><br><span class="line">footprint_sub_ = private_nh.subscribe(topic, <span class="number">1</span>, &amp;Costmap2DROS::setUnpaddedRobotFootprintPolygon, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private_nh.param(<span class="string">"footprint_radius"</span>, footprint_radius_topic_, <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"footprint_radius"</span>));</span><br><span class="line"></span><br><span class="line">radius_sub_ = private_nh.subscribe(footprint_radius_topic_, <span class="number">1</span>, &amp;Costmap2DROS::setUnpaddedRobotFootprintRadius, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>两个回调函数都是调用函数<code>setUnpaddedRobotFootprint</code>,对于<code>radius</code>的情况，也就是圆形底盘，还是把圆按正十六边形处理。</p><p>可以用命令测试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rostopic pub -1 /move_base/local_costmap/footprint_radius std_msgs/Float32 <span class="string">'0.34'</span></span><br><span class="line">rostopic pub -1 /move_base/global_costmap/footprint_radius std_msgs/Float32 <span class="string">'0.34'</span></span><br><span class="line"></span><br><span class="line">rostopic pub -1 /move_base/local_costmap/polygon_footprint geometry_msgs/Polygon <span class="string">'[ [-0.3, 0.3], [0.3,0.3], [0.3,-0.3], [-0.3,-0.3] ]'</span></span><br><span class="line"></span><br><span class="line">rostopic pub -1 /move_base/global_costmap/polygon_footprint geometry_msgs/Polygon <span class="string">'[ [-0.3, 0.3], [0.3,0.3], [0.3,-0.3], [-0.3,-0.3] ]'</span></span><br></pre></td></tr></table></figure><h2 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h2><p>Take in mind, that each additional edge significantly increases the required computation time! You may copy your footprint model from your costmap common parameter file.</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>robot_radius为0.26时，16边形的顶点坐标如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">x:0.260000,  y:0.000000</span><br><span class="line">x:0.240209,  y:0.099498</span><br><span class="line">x:0.183848,  y:0.183848</span><br><span class="line">x:0.099498,  y:0.240209</span><br><span class="line">x:0.000000,  y:0.260000</span><br><span class="line">x:-0.099498, y:0.240209</span><br><span class="line">x:-0.183848, y:0.183848</span><br><span class="line">x:-0.240209, y:0.099498</span><br><span class="line">x:-0.260000, y:0.000000</span><br><span class="line">x:-0.240209, y:-0.099498</span><br><span class="line">x:-0.183848, y:-0.183848</span><br><span class="line">x:-0.099498, y:-0.240209</span><br><span class="line">x:-0.000000, y:-0.260000</span><br><span class="line">x:0.099498,  y:-0.240209</span><br><span class="line">x:0.183848,  y:-0.183848</span><br><span class="line">x:0.240209,  y:-0.099498</span><br></pre></td></tr></table></figure><h2 id="计算footprint的内切圆半径和外切圆半径"><a href="#计算footprint的内切圆半径和外切圆半径" class="headerlink" title="计算footprint的内切圆半径和外切圆半径"></a>计算footprint的内切圆半径和外切圆半径</h2><p>计算<code>footprint</code>的内切圆半径和外切圆半径，用到点到线段的距离，计算方法是两个向量的点积等于一个向量在另一个向量的投影乘以另一个向量的模</p><p>点到线段的三种情况如下:</p><p>/*作用：计算点到线段的距离<br>*参数：pX，pY 是中心点坐标</p><ul><li>x0，y0，x1，y2 线段两端的坐标，求点到线段的距离</li><li>用向量点乘 来计算</li><li>/<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distanceToLine</span><span class="params">(<span class="keyword">double</span> pX, <span class="keyword">double</span> pY, <span class="keyword">double</span> x0, <span class="keyword">double</span> y0, <span class="keyword">double</span> x1, <span class="keyword">double</span> y1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> A = pX - x0; <span class="comment">//向量AP的x值</span></span><br><span class="line">  <span class="keyword">double</span> B = pY - y0; <span class="comment">//向量AP 的y中</span></span><br><span class="line">  <span class="keyword">double</span> C = x1 - x0; <span class="comment">//向量AB的x值</span></span><br><span class="line">  <span class="keyword">double</span> D = y1 - y0; <span class="comment">//向量AB的y值</span></span><br><span class="line">  <span class="comment">//向量AP与向量AB的点积</span></span><br><span class="line">  <span class="keyword">double</span> dot = A * C + B * D;</span><br><span class="line">  <span class="comment">//向量AB的模的平方</span></span><br><span class="line">  <span class="keyword">double</span> len_sq = C * C + D * D;</span><br><span class="line">  <span class="comment">//r 的值</span></span><br><span class="line">  <span class="keyword">double</span> param = dot / len_sq;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">double</span> xx, yy;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (param &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    xx = x0;</span><br><span class="line">    yy = y0;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (param &gt; <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    xx = x1;</span><br><span class="line">    yy = y1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//向量AC=r*向量AB</span></span><br><span class="line">    xx = x0 + param * C;</span><br><span class="line">    yy = y0 + param * D;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//计算AC的距离即可</span></span><br><span class="line">  <span class="keyword">return</span> distance(pX, pY, xx, yy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/路径规划/move_base分析/导航相关的节点和动态库之间的关系/">导航相关的节点和动态库之间的关系</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/路径规划/move-base分析/">move_base分析</a></span><div class="content"><p>注意<code>devel/lib</code>里的so文件权限是<code>rwxrwxr-x</code>，<code>install/lib</code>里的so文件权限是<code>rw-r--r--</code></p><p>节点move_base由很多库链接,一部分是<code>/opt/ros/kinetic</code>目录的ROS基本库文件,另一部分是<code>/usr/lib/x86_64-linux-gnu</code>的系统库文件,除此之外的重要库文件只有:</p><ul><li>libmove_base.so</li><li>libbase_local_planner.so</li><li>libcostmap_2d.so</li><li>libvoxel_grid.so</li><li>libteb_local_planner.so</li></ul><p>同理,<code>libmove_base.so</code>的重要链接库:</p><ul><li>libbase_local_planner.so</li><li>libcostmap_2d.so</li><li>libvoxel_grid.so</li></ul><p>依次检查其他库文件,由于<code>base_local_planner</code>一般不修改,所以重要的其实就是<code>libmove_base.so</code>, <code>libcostmap_2d.so</code>, <code>libvoxel_grid.so</code></p><h2 id="libteb-local-planner-so"><a href="#libteb-local-planner-so" class="headerlink" title="libteb_local_planner.so"></a>libteb_local_planner.so</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">add_library( teb_local_planner</span><br><span class="line"></span><br><span class="line">   src/timed_elastic_band.cpp</span><br><span class="line">   src/optimal_planner.cpp</span><br><span class="line">   src/obstacles.cpp</span><br><span class="line">   src/visualization.cpp</span><br><span class="line">   src/recovery_behaviors.cpp</span><br><span class="line">   src/teb_config.cpp</span><br><span class="line">   src/homotopy_class_planner.cpp</span><br><span class="line">   src/teb_local_planner_ros.cpp</span><br><span class="line">   src/graph_search.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>更新teb算法的so文件，不能只更新<code>libteb_local_planner.so</code>，而是包含以下文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libbase_local_planner.so libmove_base.so libcostmap_2d.so libvoxel_grid.so liblayers.so libteb_local_planner.so</span><br></pre></td></tr></table></figure><p><br><br><br><code>libcostmap_2d.so</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add_library(  costmap_2d</span><br><span class="line"></span><br><span class="line">  src/array_parser.cpp</span><br><span class="line">  src/costmap_2d.cpp</span><br><span class="line">  src/observation_buffer.cpp</span><br><span class="line">  src/layer.cpp</span><br><span class="line">  src/layered_costmap.cpp</span><br><span class="line">  src/costmap_2d_ros.cpp</span><br><span class="line">  src/costmap_2d_publisher.cpp</span><br><span class="line">  src/costmap_math.cpp</span><br><span class="line">  src/footprint.cpp</span><br><span class="line">  src/costmap_layer.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br><br><br><code>liblayers.so</code>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add_library( layers  </span><br><span class="line"></span><br><span class="line">  plugins/inflation_layer.cpp</span><br><span class="line">  plugins/obstacle_layer.cpp</span><br><span class="line">  plugins/static_layer.cpp</span><br><span class="line">  plugins/voxel_layer.cpp</span><br><span class="line">  src/observation_buffer.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/47/">47</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image:url(https://i.loli.net/2020/07/13/QgyrefaLDxhBWSZ.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>