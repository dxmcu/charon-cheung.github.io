<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>Nobody can go back and start a new beginning, but anyone can start today and make a new ending | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG={root:"/",algolia:{appId:"RI90VLL69D",apiKey:"20c535e9a1424a7913210eb747d6e67b",indexName:"HexoBlog",hits:{per_page:10},languages:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}.",hits_stats:"${hits} results found in ${time} ms"}},localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">280</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">29</span></a></div></div></div><nav id="nav" style="background-image:url(https://live.staticflickr.com/65535/48055510011_577ff62eaf_b.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">Nobody can go back and start a new beginning, but anyone can start today and make a new ending</div><div id="site-social-icons"><a class="social-icon" href="https://github.com/charon-cheung"><i class="fa-github fa"></i></a><a class="social-icon search"><i class="fa fa-search"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/17/ROS Kinetic知识/catkin_make及cmakelists分析/">catkin_make及cmakelists分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS-Kinetic知识/">ROS Kinetic知识</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/编译调试/">编译调试</a></span><div class="content"><p><code>catkin_make</code>编译时，对工作空间所有packages的编译顺序是按拓扑遍历的，不是按字母也不是按创建时间。修改任意一个<code>CMakeLists.txt</code>或者<code>package.xml</code>后，执行<code>catkin_make</code>会将工作空间的所有package的CMakeLists重新处理一遍</p><h3 id="单独编译某个package"><a href="#单独编译某个package" class="headerlink" title="单独编译某个package"></a>单独编译某个package</h3><p>以前一直认为单独编译某个package的命令是<code>catkin_make --pkg package1</code>，结果这样仍然会将工作空间中所有package的CMakeLists全检查一遍，花费时间相当长，实际的命令是这个:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_make -DCATKIN_WHITELIST_PACKAGES=&quot;package1;package2&quot;</span><br></pre></td></tr></table></figure><p>可以编译一个或多个package，但是执行这个命令之后再<code>catkin_make</code>回发现它仍然只编译上次的package。恢复成编译所有package去掉引号里面的内容就行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_make -DCATKIN_WHITELIST_PACKAGES=&quot;&quot;</span><br></pre></td></tr></table></figure><p><code>build</code>文件夹存放<code>cmake</code>和<code>make</code>相关的文件，<code>devel</code>文件夹存放编译生成的文件和目标，包括<code>setup.sh</code>。</p><h3 id="clean命令"><a href="#clean命令" class="headerlink" title="clean命令"></a>clean命令</h3><p>跟<code>make clean</code>类似，也有个<code>catkin_make clean</code>命令，它会删除所有编译的可执行文件或库文件，但是不会删除删除头文件，例如msg和srv生成的头文件</p><h3 id="INSTALL"><a href="#INSTALL" class="headerlink" title="INSTALL"></a>INSTALL</h3><p>现在执行<code>INSTALL</code>命令不再是<code>sudo make install</code>了，而是<code>catkin_make install</code>，它相当于:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd ~/catkin_ws/build</span><br><span class="line"># If cmake hasn&apos;t already been called</span><br><span class="line">cmake ../src -DCMAKE_INSTALL_PREFIX=../install -DCATKIN_DEVEL_PREFIX=../devel</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>这样执行完以后，工作空间会出现一个<code>install</code>文件夹，里面存放着编译生成的库文件，问题是它会把所有package的install都进行处理，如果想改变这个目录的位置，执行<code>catkin_make -DCMAKE_INSTALL_PREFIX=path install</code>。另外在CMakeLists中指定安装目录用<code>SET(CMAKE_INSTALL_PREFIX &lt; install_path &gt;)</code></p><p>结果会在<code>share/status_panel/cmake</code>中生成两个cmake文件<br><img src="https://c1.staticflickr.com/5/4838/32572958638_8bc5783aa6.jpg" alt><br>这两个文件是做依赖包时必需的，比如roscpp就有相应的文件<br><img src="https://c1.staticflickr.com/5/4912/32572957958_47a65642b4_b.jpg" alt></p><h3 id="链接ROS库"><a href="#链接ROS库" class="headerlink" title="链接ROS库"></a>链接ROS库</h3><p>如果想使用ROS的头文件，必须在CMakeLists里加入下面内容，也就是链接ROS的头文件和库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include_directories(</span><br><span class="line"># include</span><br><span class="line"> $&#123;catkin_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br><span class="line">find_package(roscpp)</span><br><span class="line">target_link_libraries(foo</span><br><span class="line">   $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>别忘了target_link_libraries在add_excutable之后。用message函数可以看到<code>include</code>文件夹和<code>libraries</code>文件夹如下:<br><img src="https://c1.staticflickr.com/5/4884/44358737780_3b4e27d5ce_b.jpg" alt></p><p><img src="https://c1.staticflickr.com/5/4841/44358737940_078f8896ab_b.jpg" alt></p><p>在CMakeLists中加入<code>catkin_package()</code>才能在执行<code>catkin_make</code>后，才能在<code>devel/lib</code>中生成可执行文件</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/17/cmake qmake/cmake教程（一）基本使用规则/">cmake教程（一）基本使用规则</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cmake-qmake/">cmake/qmake</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/编译调试/">编译调试</a></span><div class="content"><p>cmake和qmake都用于产生Makefile，然后执行<code>make</code>命令进行编译，make还有其他参数，叫做make目标</p><h3 id="常见的make目标"><a href="#常见的make目标" class="headerlink" title="常见的make目标"></a>常见的make目标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">make all：编译程序、库、文档等（等同于make）</span><br><span class="line"></span><br><span class="line">make install：安装已经编译好的程序，会默认把程序安装至 /usr/local/bin</span><br><span class="line"></span><br><span class="line">make unistall：卸载已经安装的程序。</span><br><span class="line"></span><br><span class="line">make clean：删除由make命令产生的文件(例如object file，*.o)</span><br><span class="line"></span><br><span class="line">make distclean：删除由./configure产生的文件</span><br><span class="line"></span><br><span class="line">make check：测试刚刚编译的软件（某些程序可能不支持，有时会测试很长时间，这就没有必要）</span><br><span class="line"></span><br><span class="line">make installcheck：检查安装的库和程序（某些程序可能不支持）</span><br><span class="line"></span><br><span class="line">make dist：重新打包成packname-version.tar.gz</span><br></pre></td></tr></table></figure><p><strong>注释方法</strong>： CMake 3.0以上版本的多行注释：从<code>#[[</code>开始，在块注释的另一端以<code>]]</code>结束。</p><h3 id="configure命令"><a href="#configure命令" class="headerlink" title="./configure命令"></a>./configure命令</h3><p>一般第三方库里都有个<code>configure</code>文件，它是个Shell脚本，内容很多．./configure 是用来检测你的安装平台的目标特征的，比如它会检测你是不是有CC或GCC。主要功能是生成 Makefile，为下一步的编译做准备，你可以通过在<code>./configure</code>后加上参数来对安装进行控制，比如<code>./configure --prefix=/usr</code>是将该软件安装在 /usr 下面，执行文件就会安装在<code>/usr/bin</code>（而不是默认的 <code>/usr/local/bin</code>)，资源文件就会安装在 <code>/usr/share</code>（而不是默认的/usr/local/share）</p><h3 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h3><p>预定义变量，可以用message函数查看：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PROJECT_NAME   <span class="comment">#通过PROJECT指令定义的项目名称</span></span><br><span class="line">PROJECT_SOURCE_DIR   <span class="comment">#工程的根目录</span></span><br><span class="line">PROJECT_BINARY_DIR   <span class="comment">#运行cmake命令的目录,通常是$&#123;PROJECT_SOURCE_DIR&#125;/build</span></span><br><span class="line">CMAKE_CURRENT_SOURCE_DIR <span class="comment">#当前处理的CMakeLists.txt所在的路径</span></span><br><span class="line">EXECUTABLE_OUTPUT_PATH <span class="comment">#目标可执行文件的存放位置</span></span><br><span class="line">LIBRARY_OUTPUT_PATH <span class="comment">#目标链接库文件的存放位置</span></span><br><span class="line"></span><br><span class="line">CMAKE_MAJOR_VERSION <span class="comment">#cmake主版本号,如2.8.6中的2</span></span><br><span class="line">CMAKE_MINOR_VERSION <span class="comment">#cmake次版本号,如2.8.6中的8</span></span><br><span class="line">CMAKE_PATCH_VERSION <span class="comment">#cmake补丁等级,如2.8.6中的6</span></span><br><span class="line">CMAKE_SYSTEM  			<span class="comment">#系统名称，包含内核版本，例如Linux-2.6.22</span></span><br><span class="line">CAMKE_SYSTEM_NAME 		<span class="comment">#不包含版本的系统名,如Linux</span></span><br><span class="line">UNIX   <span class="comment">#在所有的类UNIX平台为TRUE,包括OS X和cygwin</span></span><br><span class="line">WIN32  <span class="comment">#在所有的win32平台为TRUE,包括cygwin</span></span><br><span class="line"></span><br><span class="line">BUILD_SHARED_LIBS  <span class="comment">#控制默认的库编译方式,默认编译生成的库都是静态库</span></span><br><span class="line">CMAKE_C_COMPILER/CMAKE_CXX_COMPILER    <span class="comment">#指定C/C++编译器</span></span><br><span class="line">CMAKE_CXX_FLAGS   <span class="comment">#设置C++编译选项</span></span><br><span class="line">CMAKE_BUILD_TYPE  <span class="comment">#编译类型(Debug,Release)</span></span><br><span class="line">BUILD_SHARED_LIBS   <span class="comment">#编译动态链接库(ON,OFF)</span></span><br></pre></td></tr></table></figure><br>**块注释**： CMake多行注释: `#[[` 开始块注释,在块注释的一端以`]]`结束<br>语法规则：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量使用$&#123;&#125;方式取值,但是在IF控制语句中是直接使用变量名</span><br><span class="line">环境变量使用$ENV&#123;&#125;方式取值,使用SET(ENV&#123;VAR&#125; VALUE)赋值</span><br><span class="line">指令(参数1 参数2...) 参数使用括弧括起,参数之间使用空格或分号分开</span><br></pre></td></tr></table></figure><br>使用message函数，一般是:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message(STATUS  &quot;12345&quot;)   #如果不加STATUS，不会在前面加--标志</span><br><span class="line">message(STATUS &quot; include dirs:　$&#123;catkin_INCLUDE_DIRS&#125;&quot;　)     #有一个--开头</span><br><span class="line">message(STATUS &quot; include dirs:&quot;　$&#123;catkin_INCLUDE_DIRS&#125;　)     # 同上面等价</span><br></pre></td></tr></table></figure><p><strong>指令最好全用大写</strong><br>*<em>路径名中不要用\，而是用/ *</em>，例如<code>include_directories(F:/Eigen)</code></p><br>常用命令：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这必须是CMakeLists的第一行，限定cmake版本，Catkin需要2.8.3或更高版本</span></span><br><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">3.3</span>)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">PROJECT</span>		<span class="comment">#指定工程名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_compile_options</span>(-std=c++<span class="number">11</span>)		<span class="comment"># 支持C++ 11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>			<span class="comment">#定义变量,可定义多个变量，例如:set(SRC_FILES main.cpp mainwindow.cpp mainwindow.h)</span></span><br><span class="line"><span class="keyword">MESSAGE</span> 	<span class="comment">#输出用户定义的信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>   	<span class="comment">#指定头文件的搜索路径</span></span><br><span class="line"><span class="keyword">link_directories</span>      	<span class="comment">#指定动态链接库的搜索路径</span></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(bin_file_name <span class="variable">$&#123;SRC_FILES&#125;</span>)   	<span class="comment">#生成可执行文件</span></span><br><span class="line"><span class="keyword">add_definitions</span>   	<span class="comment">#添加编译参数 add_definitions("-Wall -g")</span></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>   		<span class="comment">#生成动态库或静态库</span></span><br><span class="line"><span class="keyword">link_libraries</span>(lib1 lib2)   <span class="comment">#所有编译目标链接相同的库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>  		<span class="comment">#设置输出的名称,设置动态库的版本和API版本</span></span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>   			<span class="comment">#向当前工程添加存放源文件的子目录</span></span><br></pre></td></tr></table></figure><h3 id="获取环境变量"><a href="#获取环境变量" class="headerlink" title="获取环境变量"></a>获取环境变量</h3><p>获取bash.rc中的环境变量，通过ENV前缀来访问环境变量，读取环境变量使用<code>$ENV{JAVA_HOME}</code>，查看环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message(STATUS &quot; java home:　$ENV&#123;JAVA_HOME&#125;&quot;　)</span><br></pre></td></tr></table></figure><p>写环境变量如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set( ENV&#123;PATH&#125; /home/martink )</span><br></pre></td></tr></table></figure><h3 id="cmake判断操作系统"><a href="#cmake判断操作系统" class="headerlink" title="cmake判断操作系统:"></a>cmake判断操作系统:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MESSAGE(STATUS &quot;operation system is $&#123;CMAKE_SYSTEM&#125;&quot;)         #输出系统内核版本</span><br><span class="line"></span><br><span class="line">IF (WIN32)</span><br><span class="line">    MESSAGE(STATUS &quot;Now is windows&quot;)</span><br><span class="line">ELSEIF (UNIX)</span><br><span class="line">    MESSAGE(STATUS &quot;Now is UNIX-like OS&apos;s.&quot;)</span><br><span class="line">ENDIF ()</span><br></pre></td></tr></table></figure><h3 id="指定生成文件的输出路径"><a href="#指定生成文件的输出路径" class="headerlink" title="指定生成文件的输出路径"></a>指定生成文件的输出路径</h3><p>使用SET命令重新定义<code>EXECUTABLE_OUTPUT_PATH</code>和<code>LIBRARY_OUTPUT_PATH</code>变量来指定最终的二进制文件的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin)</span><br><span class="line">SET(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/lib)</span><br></pre></td></tr></table></figure><p>上面的两条命令通常紧跟<code>ADD_EXECUTABLE</code>和<code>ADD_LIBRARY</code>,与其写在同一个CMakeLists.txt即可</p><p>参考：<br><a href="https://blog.csdn.net/hgl868/article/details/72236547" target="_blank" rel="noopener">CMake基本教程</a><br><a href="https://qtdream.com/topic/1056/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95qt-creator%E6%9E%84%E5%BB%BAcmake%E9%A1%B9%E7%9B%AE-%E5%9B%9B" target="_blank" rel="noopener">子工程和链接静态库</a><br><a href="https://linghutf.github.io/2016/06/16/cmake/#" target="_blank" rel="noopener">CMake使用进阶</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/16/ROS机器人/ROS串口通信（一）/">ROS串口通信（一）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS机器人/">ROS机器人</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2018/09/16/ROS机器人/ROS串口通信（一）/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/13/ROS Kinetic知识/用于ROS开发的Qt插件/">用于ROS开发的ROS Qt Creator Plugin</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS-Kinetic知识/">ROS Kinetic知识</a></span><div class="content"><p>ROS Qt Creator Plugin 4.5是一个Qt的第三方插件，可以使用Qt方便地在ROS环境编程，比使用VIM或先在Windows下编程再去Ubuntu环境更新程序方便的多。因为工控机装在机器人上，机器人不能配显示器，所以比较好的方法是先在工控机上配置好这个环境，然后用另一台电脑SSH连接到工控机上，再打开工控机的ROS Qt plugin.</p><ol><li><p>无需安装Qt Creator，直接安装Qt的插件<code>Xenial Offline Installer</code>，链接在<a href="https://ros-industrial.github.io/ros_qtc_plugin/_source/How-to-Install-Users.html" target="_blank" rel="noopener">这里下载</a></p></li><li><p>装好以后，启动桌面的<code>Qt Creator (4.5.1)</code>，注意不是原来的Creator。打开后建新工程，选择<code>ROS Workspace</code><br><img src="https://c1.staticflickr.com/2/1856/43747865335_dd34923db1_b.jpg" alt><br>命名为<code>catkin_ws_test</code></p></li><li><p>向src添加新文件，选择Package，命名为trial，依赖项里添加<code>roscpp</code><br><img src="https://c2.staticflickr.com/2/1857/43747865505_e95e586474_z.jpg" alt><br><img src="https://c2.staticflickr.com/2/1848/30786502038_f45fe75e2a_b.jpg" alt></p></li><li><p>向<code>trial/src</code>添加文件，这次选<code>Basic Node</code>，添加一个cpp文件<br><img src="https://c2.staticflickr.com/2/1885/43747866605_cbeb37fc55_b.jpg" alt><br>最终的工程是这样的<br><img src="https://c2.staticflickr.com/2/1850/43747866265_d1c9138778_m.jpg" alt></p></li><li><p>工程构建完成了，但是CMakeList.txt还需要自己修改，默认的是有错误的，主要有<code>catkin_package</code>,<code>add_executable</code>,<code>target_link_libraries</code>,也许有<code>add_compile_options</code>。 注意<code>devel</code>下的<code>setup.bash</code>还得手动source。</p></li><li><p>完成以上步骤后，build程序，如果未报错。先运行<code>roscore</code>，再用命令行运行工程，也就是这个插件不能用于运行。</p></li></ol><p>直接用这个插件不能打开现有的工作空间，会不识别catkin。先在工作空间根目录新建一个文件<code>Qt-ROS.workspace</code>后就能打开所有package了，内容如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Workspace</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Distribution</span> <span class="attr">name</span>=<span class="string">"kinetic"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DefaultBuildSystem</span> <span class="attr">value</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">WatchDirectories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Directory</span>&gt;</span>src<span class="tag">&lt;/<span class="name">Directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">WatchDirectories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Workspace</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="带界面的程序"><a href="#带界面的程序" class="headerlink" title="带界面的程序"></a>带界面的程序</h3><p>创建带界面的程序可以使用命令<code>catkin_create_qt_pkg robot_status roscpp std_msgs</code>，格式跟创建一般package是一样的。这个命令需要安装：<code>sudo apt-get install ros-kinetic-qt-create</code></p><p>package创建以后，程序目录是这样的:<br><img src alt></p><p>本插件是基于Qt4的，如果安装Qt5，用于界面开发时，默认的一些编译配置会出错，需要修改。<br><code>package.xml</code>关键部分:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>robot_status<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>catkin<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>qt_build<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>roscpp<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>libqt5-dev<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>qt_build<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>roscpp<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>libqt5-dev<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>roscpp<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>roscpp<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>CMakeLists</code>是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 2.8.0)</span><br><span class="line">project(robot_status)</span><br><span class="line"></span><br><span class="line"># Catkin</span><br><span class="line"></span><br><span class="line">find_package(catkin REQUIRED COMPONENTS qt_build roscpp)</span><br><span class="line">include_directories($&#123;catkin_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line">catkin_package()</span><br><span class="line"></span><br><span class="line"># Qt Environment</span><br><span class="line">set(CMAKE_INCLUDE_CURRENT_DIR ON)</span><br><span class="line">set(CMAKE_AUTOMOC ON)</span><br><span class="line"></span><br><span class="line"># this comes from qt_build&apos;s qt-ros.cmake which is automatically included via the dependency call in package.xml</span><br><span class="line">find_package(Qt5 COMPONENTS Core Gui Widgets REQUIRED)</span><br><span class="line">include_directories($&#123;CMAKE_CURRENT_SOURCE_DIR&#125; $&#123;Qt5Core_INCLUDE_DIRS&#125; $&#123;Qt5Gui_INCLUDE_DIRS&#125; $&#123;Qt5Widgets_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># Sections</span><br><span class="line">file(GLOB QT_FORMS RELATIVE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125; ui/*.ui)</span><br><span class="line">file(GLOB QT_RESOURCES RELATIVE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125; resources/*.qrc)</span><br><span class="line">file(GLOB_RECURSE QT_MOC RELATIVE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125; FOLLOW_SYMLINKS include/robot_status/*.hpp)</span><br><span class="line"></span><br><span class="line">QT5_WRAP_UI(QT_FORMS_HPP $&#123;QT_FORMS&#125;)</span><br><span class="line">QT5_ADD_RESOURCES(QT_RESOURCES_CPP $&#123;QT_RESOURCES&#125;)</span><br><span class="line">QT5_WRAP_CPP(QT_MOC_HPP $&#123;QT_MOC&#125;)</span><br><span class="line"></span><br><span class="line"># Sources</span><br><span class="line">file(GLOB_RECURSE QT_SOURCES RELATIVE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125; FOLLOW_SYMLINKS src/*.cpp)</span><br><span class="line"></span><br><span class="line"># Binaries</span><br><span class="line">add_executable(robot_status $&#123;QT_SOURCES&#125; $&#123;QT_RESOURCES_CPP&#125; $&#123;QT_FORMS_HPP&#125; $&#123;QT_MOC_HPP&#125;)</span><br><span class="line">target_link_libraries(robot_status $&#123;QT_LIBRARIES&#125; $&#123;catkin_LIBRARIES&#125; Qt5::Widgets)</span><br><span class="line">install(TARGETS robot_status RUNTIME DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;)</span><br></pre></td></tr></table></figure><p>这样就可以编译运行了，默认程序是一个连接ROS后，以回调函数形式写日志的程序，以后会专门分析。</p><p><strong>注意</strong> :</p><ul><li><p>如果修改ui文件，切换到xml模式保存，然后<code>catkin_make</code>，运行后生效</p></li><li><p><code>find_package(qt_build)</code>报错，安装即可:<code>sudo apt-get install ros-kinetic-qt-build</code><br>不要用Qt-ROS-plugin运行或编译，否则再使用<code>catkin_make</code>会又检查一遍所有package的CMakeLists</p></li></ul></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/04/C++  面向对象/运算符重载(二)/">运算符重载</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C-面向对象/">C++ 面向对象</a></span><div class="content"><p>以一个Point类，重载几个运算符，代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> x=<span class="number">0</span>,<span class="keyword">int</span> y=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = x;</span><br><span class="line">        arr[<span class="number">1</span>] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"x: "</span>&lt;&lt;arr[<span class="number">0</span>]&lt;&lt;<span class="string">" y: "</span>&lt;&lt;arr[<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> num)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(num==<span class="number">1</span> || num==<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> arr[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Point&amp; <span class="keyword">operator</span> -()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(-arr[<span class="number">0</span>],-arr[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    Point&amp; <span class="keyword">operator</span> --()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(arr[<span class="number">0</span>]<span class="number">-1</span>,arr[<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Point&amp; <span class="keyword">operator</span> ++()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(arr[<span class="number">0</span>]+<span class="number">1</span>,arr[<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Point&amp; <span class="keyword">operator</span> +(Point&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(arr[<span class="number">0</span>]+p.arr[<span class="number">0</span>],  arr[<span class="number">1</span>]+p.arr[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    Point&amp; <span class="keyword">operator</span> -(Point&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(arr[<span class="number">0</span>] - p.arr[<span class="number">0</span>],  arr[<span class="number">1</span>] - p.arr[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> Point&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((arr[<span class="number">0</span>]==p.arr[<span class="number">0</span>]) &amp;&amp; (arr[<span class="number">1</span>]==p.arr[<span class="number">1</span>]) )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有一个数组做成员变量，构造函数给数组赋值。<br>首先是一元运算符<code>-</code> <code>--</code> <code>++</code>，显然是无参数的。返回值应当是<code>Point&amp;</code>，函数也容易理解。<br>二元运算符加法和减法及相等也简单，有一个参数而已。其实这三个运算符最好按友元重载。</p><p>下标运算符重载的声明必须是<code>返回类型&amp; operator [](参数)</code>，只能作为类成员函数，不能做友元。</p><p>调用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">p</span><span class="params">(<span class="number">1</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="comment">//改变 p</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">7</span>;</span><br><span class="line">p[<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line">Point p1 = -p;</span><br><span class="line"><span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">4</span>,<span class="number">12</span>)</span></span>;</span><br><span class="line">Point p3 = p - p2;</span><br><span class="line"><span class="keyword">if</span>(p2==p3)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"equal"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"not equal"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">Point p4 = ++p3;</span><br><span class="line">Point p5 = --p3;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.zfl9.com/cpp-operator-overload.html#comments" target="_blank" rel="noopener">C++ 运算符重载</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/08/29/C++  基础/随机数/">C++中的随机数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C-基础/">C++ 基础</a></span><div class="content"><p>rand()函数可以用来产生随机数，但是这不是真正意义上的随机数，是一个伪随机数，是根据一个数（我们可以称它为种子）为基准以某个递推公式推算出来的一系列数，当这系列数很大的时候，就符合正态公布，从而相当于产生了随机数，但这不是真正的随机数，当计算机正常开机后，这个种子的值是定了的，除非你破坏了系统。</p><p>常用的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	srand(time(<span class="literal">NULL</span>));  </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++ )  </span><br><span class="line">	   <span class="built_in">cout</span> &lt;&lt; rand() &lt;&lt; <span class="string">'\t'</span>;  </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>srand()用来设置rand()产生随机数时的随机数种子。参数seed必须是个整数，如果每次seed都设相同值，rand()所产生的随机数值每次就会一样。所以常用<code>time(NULL)</code>为参数(当前的UTC时间)，这样每次生成的随机数就不同。</p><p>Qt中的qrand和qsrand用法一样，就不重复了。</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/08/29/Linux系统编程/基于信号量的生产者-消费者/">基于信号量的生产者-消费者</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux系统编程/">Linux系统编程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/多线程/">多线程</a></span><div class="content"><p>信号量是进化版的互斥锁，互斥锁只能供一个线程使用，信号量可以供多个线程使用。如果希望在多个线程之间对某对象的部分数据共享，互斥锁无法实现，只能将整个数据锁住，这样导致线程并发性下降。<br>信号量既能保持同步，数据又不混乱，又能提高线程并发。</p><p>主要函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int sem_int(sem_t* sem, int pshared, unsigned int value);	//初始化信号量</span><br><span class="line">int sem_destroy(sem_t* sem);	//销毁信号量</span><br></pre></td></tr></table></figure><p>sem是信号量；pshared取0用于线程间，取非0值(一般为1)用于进程间；value指定信号量初值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int sem_wait(sem_t *sem)	//相当于加锁，信号量&gt;0，则信号量--(产品减少)。信号量=0(没有产品)，则线程阻塞</span><br><span class="line">int sem_post(sem_t *sem)	//相当于解锁，信号量++(空位增加)，唤醒阻塞在信号量上的线程</span><br></pre></td></tr></table></figure><p>sem_t类型仍是结构体，但可看做整数，忽略细节，类似文件描述符。<br>规定信号量不能小于0，sem_t的实现对用户隐藏，所谓++和–是通过函数实现，<strong>信号量的初值，决定了占用信号量的线程个数。</strong></p><p><a href="https://github.com/rjosodtssp/Learning-UNP-APUE/blob/master/Produce_Consumer_Semaphore.cpp" target="_blank" rel="noopener">示例代码</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/08/28/笔试面试/C++面试/">C++面试</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/面试笔试/">面试笔试</a></span><div class="content"><h3 id="堆与栈的区别"><a href="#堆与栈的区别" class="headerlink" title="堆与栈的区别"></a>堆与栈的区别</h3><ol><li>在内存中的位置不同，栈由系统自动分配和释放，堆由程序员动态分配和释放</li><li>栈有大小限制，根据编译器的不同最多可分配1M或2M，堆可达到4G</li><li>栈空间在内存中从高地址向低地址增长，堆是从低地址向高地址增长</li><li>栈是先进后出，不存在内存空间不连续的情况。堆会出现这种情况，造成大量碎片，使程序效率降低</li><li>栈有动态和静态两种分配方式，动态的也不用手动释放内存。堆只有一种</li><li>栈是有计算机底层支持，堆是基于C++的</li></ol><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>之前对内联函数的理解不够深，内联函数是在<strong>编译阶段</strong>将函数展开，而不用将函数地址压入堆栈,避免被调用的开销来提高效率，但增大了可执行程序的体积。如果在类体内定义实现，那么就是内联函数；也可以在类内用inline声明，在体外实现。函数一般比较小，用于大量调用的场合。</p><p>其实上面这些还没触及到本质，还有以下几条:</p><ol><li>inline只是我们对编译器提出的一个申请，是否真按内联函数处理取决于编译器。函数不能有循环和递归，不能太大，否则仍是普通函数。</li><li>编译器的内联看起来就像是代码的复制与粘贴，这与预处理宏是很不同的：宏是强制的内联展开，可能将会污染所有的命名空间与代码，将为程序的调试带来困难，所以最好用内联函数代替宏。</li><li>虚函数与内联：要多态时不能内联，不要多态可以内联</li><li>如果一个内联函数会在多个源文件中被用到，那么最好把它定义在头文件中，否则必须在调用该函数的每个文件中定义。</li><li>构造函数和析构函数不适合做内联函数，编译器在编译期间会给你的构造函数和析构函数额外加入很多的代码，像成员函数的构造和析构等代码，所以通常构造和析构函数比表面上看起来的要多，并不适合作为内联函数。</li><li>内联函数无法随程序库升级而升级，比如修改了一个内联函数，那么所有用到它的地方都要重新编译，而普通函数做修改后，程序只需要重新链接它，效率比重新编译高</li></ol><p>内联函数和宏的区别：</p><ol><li>内联函数展开在编译阶段，宏在预处理阶段</li><li>内联函数运行时可调试，宏定义不可以</li><li>内联函数经编译器安全检查。宏定义的参数没有类型的概念，只有在宏展开以后，才由编译器检查语法，这就存在很多的安全隐患。</li></ol><p>详细内容看《Effective C++》条款30</p><h3 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h3><p>至少含有一个纯虚函数的类为抽象类，无法实例化对象，抽象类可以有非虚函数，抽象类的子类也可以是抽象类。<br>C++中似乎没有接口这个概念，又似乎接口就是抽象类，与java中的接口不同。<br>只含有纯虚函数的类为接口类，接口类不含有非虚函数和成员变量，也无需自定义构造函数和析构函数。接口类的子类必须实现相应的纯虚函数。</p><h3 id="class与struct的异同"><a href="#class与struct的异同" class="headerlink" title="class与struct的异同"></a>class与struct的异同</h3><p>相同：struct可以有成员变量和函数，有构造函数、析构函数、this指针和虚函数概念，能继承结构体，也可以继承类。<br>不同：</p><ol><li>类的默认访问权限是Private，结构体默认是public。</li><li>类的继承默认private，结构体默认public</li><li>类的关键字class能作为template模板的关键字，<code>template&lt;class T&gt; class A{};</code>，但struct不可以。</li></ol><p>另外，同一文件中，二者不能有同样变量名，<code>struct Node</code>和<code>class Node</code>不能同时出现。<br>补充：C中的结构体和C++的结构体不同，前者只能有数据不能有函数，没有多态、继承的概念，访问权限只有public。</p><h3 id="构造函数成员初始化列表和内部初始化"><a href="#构造函数成员初始化列表和内部初始化" class="headerlink" title="构造函数成员初始化列表和内部初始化"></a>构造函数成员初始化列表和内部初始化</h3><p>对于普通类型，二者的初始化效率相同．对于类类型，前者的效率更高．因为前者只调用了拷贝构造函数，而后者先调用默认构造函数，又调用赋值运算符．</p><h3 id="类实例化时加不加括号"><a href="#类实例化时加不加括号" class="headerlink" title="类实例化时加不加括号"></a>类实例化时加不加括号</h3><p>这种情况针对的是无参构造函数，看如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BTree&lt;<span class="keyword">int</span>&gt; tree();</span><br><span class="line">tree.insert(<span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>结果报错：error: request for member ‘insert’ in ‘tree’, which is of non-class type ‘BTree<int>()’tree.insert(12);<br>^<br>声明类的对象时，如果相应的构造函数没有参数，是不需要加上括号的，如果加了括号，就不是定义一个对象了,编译器会认为我们声明了一个函数，结果会无法调用其他成员函数．</int></p><p>上面说的是实例化，但是用new初始化类的指针时，对无参构造函数，加不加括号的效果一样，因为此时编译器判断它是指针</p><h3 id="函数重载和覆盖"><a href="#函数重载和覆盖" class="headerlink" title="函数重载和覆盖"></a>函数重载和覆盖</h3><p>重载：返回类型可相同也可不同，参数列表必须不同（个数和类型至少有一种不同）<br>覆盖：子类中的方法可以与父类中的某个方法完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中的那个方法给覆盖</p><h3 id="链表和数组的区别"><a href="#链表和数组的区别" class="headerlink" title="链表和数组的区别"></a>链表和数组的区别</h3><ol><li>数组初始化必须指定大小，不能动态增加元素，有越界问题。链表可以动态插入删除元素，没有越界问题</li><li>数组从stack分配内存，内存地址连续。链表从heap分配内存，内存地址不连续。</li><li>数组可以利用下标随机访问，链表只能线性访问，效率较低</li><li>链表由节点数据和指向下一个节点的指针构成</li></ol><h3 id="设计一个不能被继承的类"><a href="#设计一个不能被继承的类" class="headerlink" title="设计一个不能被继承的类"></a>设计一个不能被继承的类</h3><p>C++11环境，类声明时加final关键字。析构函数为私有函数，若构造函数也为private，则类无法使用了。</p><h3 id="C-11特性"><a href="#C-11特性" class="headerlink" title="C++ 11特性"></a>C++ 11特性</h3><p>final：类声明关键字，类不能被继承<br>delete：用于禁止拷贝构造函数<br>override：用于显式表示函数的覆盖，如果派生类的形参与基类不同，会报错<br>线程库<br>lambda</p><p>参考：<a href="https://blog.csdn.net/liyuanbhu/article/details/43816371" target="_blank" rel="noopener">Qt环境解析override</a></p><h3 id="定义一个只能在栈或堆上定义对象的类"><a href="#定义一个只能在栈或堆上定义对象的类" class="headerlink" title="定义一个只能在栈或堆上定义对象的类"></a>定义一个只能在栈或堆上定义对象的类</h3><p>只能在堆：析构函数声明为private<br>只能在栈：把new和delete操作符定义为private</p><h3 id="常引用传递优于值传递"><a href="#常引用传递优于值传递" class="headerlink" title="常引用传递优于值传递"></a>常引用传递优于值传递</h3><p>简单类型和STL在函数中用值传递，类类型用常引用传递．后者可以节省开销，主要是对象和其成员的拷贝构造函数和析构函数．对于模板类，也应当用常引用传递．另外，常引用传递可以避免对象切割问题。对于一般类型和STL迭代器、函数对象，最好用值传递</p><h3 id="extern-“C”-关键字"><a href="#extern-“C”-关键字" class="headerlink" title="extern “C” 关键字"></a>extern “C” 关键字</h3></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/08/27/网络/apache安装和配置/">window下apache安装和配置</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/网络编程/">网络编程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/工具/">工具</a></span><div class="content"><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>32位： <a href="http://httpd.apache.org/" target="_blank" rel="noopener">http://httpd.apache.org/</a><br>64位： <a href="http://www.apachelounge.com/download/" target="_blank" rel="noopener">http://www.apachelounge.com/download/</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>解压Apache2.4到<code>F:\Apache2.4</code><br>修改文件<code>F：\Apache2.4\conf\httpd.conf</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务根目录：ServerRoot的参数改为F:\Apache2.4</span><br><span class="line">服务端口号：Listen 80 修改为需要的端口号</span><br></pre></td></tr></table></figure><p>进入bin目录，打开命令行，执行<code>httpd -k install</code>，完成安装服务</p><p>启动服务器<code>httpd -k start</code></p><p>打开浏览器访问 <code>http://localhost</code> 测试是否启动成功，可以在<code>F:\Apache2.4\htdocs</code>添加文件。</p><p>在浏览器里按F12可查看http的内容：<br><img src="https://c2.staticflickr.com/2/1878/42492214260_9c088016de_b.jpg" alt></p><p>常用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">关闭Apache        httpd -k stop</span><br><span class="line">重启Apache        httpd -k restart</span><br><span class="line">卸载Apache        httpd -k uninstall</span><br><span class="line">查看Apache版本     httpd -V</span><br><span class="line">命令帮助           httpd -h</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/08/25/Linux系统编程/互斥锁与读写锁/">互斥锁，读写锁，条件变量，自旋锁</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux系统编程/">Linux系统编程</a></span><div class="content"><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>在多线程的情况下，当一个变量可以被多个线程修改时，就需要考虑多线程同步问题。线程A修改变量前，先加锁，修改结束再解锁，然后线程B获取同样的锁，修改结束再解锁，如果不是同一把锁，同步是无效的。</p><p>在C++中使用pthread的互斥量接口实现数据同步，线程A对互斥量mutex加锁后，其他尝试加锁的线程都会阻塞，等线程A解锁后，其他线程从阻塞变为运行态，第一个抢到CPU的线程加锁成功，其他线程再次阻塞，这样每次只有一个线程能加锁。这里存在规则统一的问题，就是线程可以在不加锁情况下访问变量，此时即使另一个线程加了锁，还是会出现不同步的问题，所以不能有的线程需要加锁，有的线程不需要加锁，必须统一化。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>存在两种常见的死锁情况，第一种是对同一把锁连续加锁，结果第二次加锁时因为自己已经加了锁，会导致线程阻塞无法运行。<br><img src="https://c1.staticflickr.com/2/1864/42441530880_4d95e301bd_z.jpg" alt></p><p>第二种是两个线程各自加了一把锁之后，还未解锁就去获取对方的锁。<br><img src="https://c1.staticflickr.com/2/1867/42441530650_e5a52ac4e4_c.jpg" alt><br>线程t1加了锁A，t2加了锁B，两个线程都未解锁，然后t1去获取锁B，此时t1会阻塞；同样t2去获取锁A，也会阻塞。两个线程都阻塞也就无法解锁，程序无法再运行。此时可以将两个线程都杀死。为防止这种情况可以用trylock函数。<br><img src="https://c1.staticflickr.com/2/1894/42441530710_b43fa9e44d_b.jpg" alt></p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>读写锁是一种较一般化的互斥锁，主要用于读操作比较多、写操作少的多线程情况。读写锁有三种状态：读锁、写锁、不锁。遵循<strong>写互斥，读共享，写优先</strong>的原则。</p><p>常见的有下面几种情况：</p><ol><li>多个线程可以同时占有读锁</li><li>每次只能有一个写线程，一个线程加了写锁，其他线程无论读写都要等待，解锁后，优先唤醒占有写锁的线程</li><li>一个线程加读锁，此时来了一个占写锁的线程和一个读锁的线程，则二者皆阻塞，解锁后，写锁的线程优先。</li></ol><p>读写锁在使用前要初始化，释放底层内存前要销毁。</p></div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/17/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/19/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image:url(https://live.staticflickr.com/65535/48055510011_577ff62eaf_b.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>