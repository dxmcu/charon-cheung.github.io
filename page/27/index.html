<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG={root:"/",algolia:{appId:"RI90VLL69D",apiKey:"20c535e9a1424a7913210eb747d6e67b",indexName:"HexoBlog",hits:{per_page:10},languages:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}.",hits_stats:"${hits} results found in ${time} ms"}},localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">416</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">49</span></a></div></div></div><nav id="nav" style="background-image:url(https://i.loli.net/2020/07/13/QgyrefaLDxhBWSZ.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div><div id="site-social-icons"><a class="social-icon" href="https://github.com/charon-cheung"><i class="fa-github fa"></i></a><a class="social-icon search"><i class="fa fa-search"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/23/ROS/ROS机器人/使用OpenMV摄像头(三)/">探究OpenMV摄像头(三) 摄像头与ROS通信</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS机器人/">ROS机器人</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/摄像头/">摄像头</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2019/01/23/ROS/ROS机器人/使用OpenMV摄像头(三)/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/23/ROS/ROS机器人/使用OpenMV摄像头(二)/">探究OpenMV摄像头(二) 识别AprilTag</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS机器人/">ROS机器人</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/摄像头/">摄像头</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2019/01/23/ROS/ROS机器人/使用OpenMV摄像头(二)/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/23/ROS/ROS机器人/使用OpenMV摄像头(一)/">探究OpenMV摄像头(一) 初步使用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS机器人/">ROS机器人</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/摄像头/">摄像头</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2019/01/23/ROS/ROS机器人/使用OpenMV摄像头(一)/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/22/ROS/ROS程序和源码分析/解读Qt ROS Package源码/">解读Qt ROS Package源码</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS程序和源码分析/">ROS程序和源码分析</a></span><div class="content"><p>根据这个Qt插件创建的package实际是对ROS官方的发布主题程序的扩展，将发布的内容显示在一个QListView里面，并且带有下拉效果。运行结果如下:<br><img src alt><br><img src alt></p><p>我们新建一个名为robot的package，目录结构如下图:<br><img src="https://farm8.staticflickr.com/7845/32556213687_29131c15ca.jpg" alt><br>有三个源文件: main.cpp, main_window.cpp, qnode.cpp。除了普通的ROS Package文件，还有一个Qt资源文件和ui文件。<code>mainpage.dox</code>是个说明性的文件，可以不用管。</p><p>CMakeLists.txt和package.xml在之前解释过了，直接看源代码。main.cpp中没什么可解释的，只有一句<code>app.connect(&amp;app, SIGNAL(lastWindowClosed()), &amp;app, SLOT(quit()));</code>，这句的意思是当最后一个窗口关闭时，信号QApplication::lastWindowClosed() 被发射，此时退出程序。这是为了防止窗口关闭但进程没有退出的情况。</p><h3 id="main-window类"><a href="#main-window类" class="headerlink" title="main_window类"></a>main_window类</h3><p><code>main_window.hpp</code>主要内容如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> robot &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  MainWindow(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv, QWidget *parent = <span class="number">0</span>);</span><br><span class="line">  ~MainWindow();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReadSettings</span><span class="params">()</span></span>; <span class="comment">// Load up qt program settings at startup</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">WriteSettings</span><span class="params">()</span></span>; <span class="comment">// Save qt program settings when closing</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">closeEvent</span><span class="params">(QCloseEvent *event)</span></span>; <span class="comment">// Overloaded function</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">showNoMasterMessage</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> Q_SLOTS:</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">on_actionAbout_triggered</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">on_button_connect_clicked</span><span class="params">(<span class="keyword">bool</span> check )</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">on_checkbox_use_environment_stateChanged</span><span class="params">(<span class="keyword">int</span> state)</span></span>;</span><br><span class="line">  <span class="comment">/******************************************</span></span><br><span class="line"><span class="comment">    ** Manual connections</span></span><br><span class="line"><span class="comment">    *******************************************/</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">updateLoggingView</span><span class="params">()</span></span>; <span class="comment">// no idea why this can't connect automatically</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Ui::MainWindowDesign ui;</span><br><span class="line">  QNode qnode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看头文件会发现创建package时定义了一个命名空间，名称与package相同。然后派生了QMainWindow类，类中有4个比较简单的公有函数: <code>ReadSettings</code>, <code>WriteSettings</code>, <code>closeEvent</code>, <code>showNoMasterMessage</code>。前两个是打开程序时加载配置和关闭程序时保存配置，使用了QSetting和QWidget的一些函数。<code>closeEvent</code>是重载关闭事件的处理函数，最后是ROS通信失败时显示对话框。</p><p>然后是4个槽函数，on_actionAbout_triggered是显示<strong>关于</strong>对话框，<code>on_checkbox_use_environment_stateChanged</code>实际没有被调用，<code>updateLoggingView</code>是响应QNode的<code>loggingUpdated</code>信号，下拉加载日志的QListView。下面重点来看构造函数和<code>on_button_connect_clicked</code>函数。构造函数的内容如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">connect(ui.actionAbout_Qt, SIGNAL(triggered(<span class="keyword">bool</span>)), qApp, SLOT(aboutQt())); </span><br><span class="line">ReadSettings();</span><br><span class="line">setWindowIcon(QIcon(<span class="string">":/images/icon.png"</span>));</span><br><span class="line">ui.tab_manager-&gt;setCurrentIndex(<span class="number">0</span>); </span><br><span class="line">connect(&amp;qnode, SIGNAL(loggingUpdated()), <span class="keyword">this</span>, SLOT(updateLoggingView()));</span><br><span class="line"></span><br><span class="line">connect(&amp;qnode, SIGNAL(rosShutdown()), <span class="keyword">this</span>, SLOT(close()));</span><br><span class="line">ui.view_logging-&gt;setModel(qnode.loggingModel());</span><br><span class="line"><span class="keyword">if</span> ( ui.checkbox_remember_settings-&gt;isChecked() ) </span><br><span class="line">&#123;</span><br><span class="line">  on_button_connect_clicked(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前几行不用解释了，后面三个涉及到QNode类，稍后再回来分析。第二个connect是将QNode的<code>rosShutdown</code>信号连接到关闭窗口的槽函数。</p><h3 id="QNode类"><a href="#QNode类" class="headerlink" title="QNode类"></a>QNode类</h3><p>qnode.hpp如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QNode</span> :</span> <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  QNode(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv );</span><br><span class="line">  <span class="keyword">virtual</span> ~QNode();</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;master_url, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;host_url)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">enum</span> LogLevel &#123;</span><br><span class="line">    Debug,</span><br><span class="line">    Info,</span><br><span class="line">    Warn,</span><br><span class="line">    Error,</span><br><span class="line">    Fatal</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function">QStringListModel* <span class="title">loggingModel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &amp;logging_model; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">( <span class="keyword">const</span> LogLevel &amp;level, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;msg)</span></span>;</span><br><span class="line">  </span><br><span class="line">Q_SIGNALS:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">loggingUpdated</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rosShutdown</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> init_argc;</span><br><span class="line">  <span class="keyword">char</span>** init_argv;</span><br><span class="line">  ros::Publisher chatter_publisher;</span><br><span class="line">  QStringListModel logging_model;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>QNode继承了QThread，也就是一个线程，因为在UI线程发布主题会阻塞界面，订阅也要另用一个线程。</p><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>构造函数是空的，析构函数如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> if(ros::isStarted())</span><br><span class="line">&#123;</span><br><span class="line">   ros::shutdown();        // explicitly needed since we use ros::start();</span><br><span class="line">   ros::waitForShutdown();</span><br><span class="line"> &#125;</span><br><span class="line"> wait();</span><br></pre></td></tr></table></figure><p><code>ros::isStarted()</code>判断节点是否已经通过<code>ros::start()</code>启动，若启动则用<code>ros::shutdown()</code>用于断开从ros master的连接，也就是打断<code>spin()</code>循环。<code>ros::waitForShutdown ()</code>是等待节点关闭。最后是<code>QThread::wait()</code></p><h4 id="QNode-init"><a href="#QNode-init" class="headerlink" title="QNode::init"></a>QNode::init</h4><p>然后比较重要的是两个init函数重载，先看init():</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ros::init(init_argc,init_argv,<span class="string">"robot"</span>);</span><br><span class="line"><span class="keyword">if</span> ( ! ros::master::check() )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">ros::start(); <span class="comment">// explicitly needed since our nodehandle is going out of scope.</span></span><br><span class="line">ros::NodeHandle n;</span><br><span class="line">chatter_publisher = n.advertise&lt;std_msgs::String&gt;(<span class="string">"chatter"</span>, <span class="number">1000</span>);</span><br><span class="line">start();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h4 id="QNode-run"><a href="#QNode-run" class="headerlink" title="QNode::run"></a>QNode::run</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> QNode::run()</span><br><span class="line">&#123;</span><br><span class="line">  ros::<span class="function">Rate <span class="title">loop_rate</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( ros::ok() )</span><br><span class="line">  &#123;</span><br><span class="line">    std_msgs::String msg;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">"hello world "</span> &lt;&lt; count;</span><br><span class="line">    msg.data = ss.str();</span><br><span class="line">    chatter_publisher.publish(msg);</span><br><span class="line">    <span class="built_in">log</span>(Info,<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"I sent: "</span>)+msg.data);</span><br><span class="line">    ros::spinOnce();</span><br><span class="line">    loop_rate.sleep();</span><br><span class="line">    ++count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Ros shutdown, proceeding to close the gui."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="function">Q_EMIT <span class="title">rosShutdown</span><span class="params">()</span></span>; <span class="comment">// used to signal the gui for a shutdown (useful to roslaunch)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/22/ROS/ROS程序和源码分析/ROS常用的核心接口/">ROS常用的核心接口</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS程序和源码分析/">ROS程序和源码分析</a></span><div class="content"><h4 id="ros-start"><a href="#ros-start" class="headerlink" title="ros::start ()"></a>ros::start ()</h4><p>Actually starts the internals of the node (spins up threads, starts the network polling and xmlrpc loops, connects to internal subscriptions like /clock, starts internal service servers, etc.).</p><h4 id="ros-shutdown"><a href="#ros-shutdown" class="headerlink" title="ros::shutdown()"></a>ros::shutdown()</h4><p>关闭节点并且从主节点登出，会终结所有的订阅、发布、服务，连<code>ROS_INFO</code>也不能再用。一般不用调用此函数，当所有的<strong>NodeHandle</strong>销毁时，就会自动关闭节点。默认的roscpp也会安装<code>SIGINT</code>句柄用来检测<code>Ctrl-C</code>，并自动为你关闭节点。</p><h4 id="ros-waitForShutdown"><a href="#ros-waitForShutdown" class="headerlink" title="ros::waitForShutdown ()"></a>ros::waitForShutdown ()</h4><p>等待节点关闭，无论时通过<code>Ctrl-C</code>还是<code>ros::shutdown()</code></p><h4 id="ros-isShuttingDown"><a href="#ros-isShuttingDown" class="headerlink" title="ros::isShuttingDown()"></a>ros::isShuttingDown()</h4><p>一旦<code>ros::shutdown()</code>被调用（注意是刚开始调用，而不是调用完毕）就返回true。一般建议用ros::ok()，特殊情况可以用ros::isShuttingDown()</p><h4 id="ros-NodeHandle"><a href="#ros-NodeHandle" class="headerlink" title="ros::NodeHandle"></a>ros::NodeHandle</h4><p>获取节点的句柄，<code>ros::init</code>是初始化节点，这个是启动节点。<br>如果不想通过对象的生命周期来管理节点的开始和结束，可以通过<code>ros::start()</code>和<code>ros::shutdown()</code>来自己管理节点。</p><h4 id="ros-ok"><a href="#ros-ok" class="headerlink" title="ros::ok()"></a>ros::ok()</h4><p>判断是否退出节点，如果返回false，说明可能发生了以下事件</p><ul><li>SIGINT被触发(Ctrl-C)调用了<code>ros::shutdown()</code></li><li>被另一同名节点踢出ROS网络</li><li><code>ros::shutdown()</code>被程序的另一部分调用</li><li>节点中的所有<code>ros::NodeHandles</code>都已经被销毁</li></ul><h3 id="ROS-INFO"><a href="#ROS-INFO" class="headerlink" title="ROS_INFO"></a>ROS_INFO</h3><p>源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ROS_INFO不能直接输出<code>std::string</code>，应该这样用:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">ROS_INFO(s.c_str());</span><br></pre></td></tr></table></figure><h3 id="ros-Rate"><a href="#ros-Rate" class="headerlink" title="ros::Rate"></a>ros::Rate</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ros::<span class="function">Rate <span class="title">rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span>(ros::ok())</span><br><span class="line">&#123;</span><br><span class="line">    ros::spinOnce();</span><br><span class="line">    rate.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rate类的构造函数参数是频率，不是时间。rate(10)对应时间间隔为<code>1/10</code>秒，也就是100毫秒。<code>Rate::sleep()</code>是进行睡眠，实际调用<code>Duration::sleep()</code>，间隔就是从构造函数开始计算，源码处理比较复杂。</p><h3 id="获得当前运行的所有节点名"><a href="#获得当前运行的所有节点名" class="headerlink" title="获得当前运行的所有节点名"></a>获得当前运行的所有节点名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ros::V_string</span><br><span class="line"><span class="comment">// Retreives the currently-known list of nodes from the master. 放入</span></span><br><span class="line"><span class="function">ROSCPP_DECL <span class="keyword">bool</span>   <span class="title">getNodes</span> <span class="params">(V_string &amp;nodes)</span></span></span><br></pre></td></tr></table></figure><p>用这个函数很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; nodes;</span><br><span class="line">ros::master::getNodes(nodes);	<span class="comment">// bool</span></span><br><span class="line"><span class="keyword">int</span> len = nodes.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"node: "</span>&lt;&lt;nodes.at(i)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获得当前运行的所有话题名"><a href="#获得当前运行的所有话题名" class="headerlink" title="获得当前运行的所有话题名"></a>获得当前运行的所有话题名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ros</span>:</span>:master::TopicInfo</span><br><span class="line">&#123;</span><br><span class="line">	TopicInfo ()</span><br><span class="line"> 	TopicInfo (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;_name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;_datatype)</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> 	datatype    <span class="comment">// Datatype of the topic. </span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> 	name        <span class="comment">// Name of the topic. </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TopicInfo&gt; ros::master::V_TopicInfo</span><br><span class="line"></span><br><span class="line"><span class="function">ROSCPP_DECL <span class="keyword">bool</span>    <span class="title">getTopics</span> <span class="params">(V_TopicInfo &amp;topics)</span></span></span><br></pre></td></tr></table></figure><p>使用是类似的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ros::master::TopicInfo&gt; topics;</span><br><span class="line">ros::master::getTopics(topics);</span><br><span class="line"><span class="keyword">int</span> len = topics.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"topic: "</span>&lt;&lt;topics.at(i).name&lt;&lt;<span class="string">"   type: "</span>&lt;&lt;topics.at(i).datatype&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他可能用到的函数"><a href="#其他可能用到的函数" class="headerlink" title="其他可能用到的函数"></a>其他可能用到的函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ros::isInitialized ()    <span class="comment">// 判断ros::init()是否被调用</span></span><br><span class="line"></span><br><span class="line">ros::isStarted ()	　<span class="comment">// 判断节点是否已经通过ros::start()启动</span></span><br><span class="line"></span><br><span class="line">ros::requestShutdown ()　　<span class="comment">// 在节点的一个线程内要求ROS关闭</span></span><br><span class="line"></span><br><span class="line">ros::this_node::getName       <span class="comment">// 返回当前节点的名称</span></span><br><span class="line"></span><br><span class="line">getAdvertisedTopics()　　<span class="comment">//返回此节点注册的话题</span></span><br><span class="line">	</span><br><span class="line">getName()	<span class="comment">//返回节点名称</span></span><br><span class="line"></span><br><span class="line">getNamespace()	<span class="comment">//返回节点的命名空间</span></span><br><span class="line"></span><br><span class="line">getSubscribedTopics()   <span class="comment">//返回节点订阅的主题</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Get the hostname where the master runs. </span></span><br><span class="line">ROSCPP_DECL <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> &amp;     <span class="title">getHost</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Get the port where the master runs. </span></span></span><br><span class="line"><span class="function">ROSCPP_DECL uint32_t    <span class="title">getPort</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Get the full URI to the master (eg. http://host:port/) </span></span></span><br><span class="line">ROSCPP_DECL const std::string &amp;     getURI ()</span><br><span class="line"></span><br><span class="line">ROS_ASSERT(a&lt;b)			<span class="comment">//同assert()，若条件不满足，程序会终止</span></span><br><span class="line">ROS_BREAK()				<span class="comment">//直接终止程序，报警FATAL</span></span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://blog.csdn.net/wuguangbin1230/article/details/76889753" target="_blank" rel="noopener">ros 初始化和关闭</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/22/ROS/ROS程序和源码分析/解析ros init（一）/">解析ros::init（一）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS程序和源码分析/">ROS程序和源码分析</a></span><div class="content"><p>在ROS程序中，初始化ROS节点是函数<code>ros::init()</code>，启动节点是实例化类<code>ros::NodeHandle</code>，这两步是ROS程序必不可少的，先后顺序不能变，否则会报错：<br><img src="https://farm8.staticflickr.com/7847/47368088421_b9e44e7b9a_b.jpg" alt><br>本篇分析ros::init，另一篇分析NodeHandle。</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>使用任何roscpp函数前，必须调用<code>ros::init()</code>，一般有两种形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ros::init(argc, argv, <span class="string">"my_node_name"</span>);</span><br><span class="line">ros::init(argc, argv, <span class="string">"my_node_name"</span>,   ros::init_options::AnonymousName);</span><br><span class="line">ros::init(argc, argv, <span class="string">"my_node_name"</span>,   ros::init_options::NoSigintHandler);</span><br></pre></td></tr></table></figure><p>argc和argv用于处理remapping参数，使用这种形式后，在命令行中使用参数就无效了。如果还想在命令行中处理，需要在<code>ros::init</code>之后调用<code>ros::removeROSArgs()</code></p><p>一般只能有一个同名节点在运行，如果再运行一个，前一个节点会自动关闭。使用第二种重载就可以同时运行多个同名节点，比如<code>rviz</code>和<code>rostopic</code>就是如此，ROS会在节点名后面加上UTC时间以示区别。</p><p><strong>运行同一个节点还有更好的方法</strong>，比如已经运行了一个名为Pub的节点：<code>rosrun pub Pub</code>，我们指定参数<code>__name</code>可以运行同一个可执行文件，但是节点名不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun pub Pub __name:=newPub</span><br></pre></td></tr></table></figure><p>默认发SIGINT信号会终结节点，也就是Ctral+C会退出节点，但也可以自定义信号处理函数，前提是使用第三种重载的<code>ros::init</code>。</p><h3 id="ros-init-源码"><a href="#ros-init-源码" class="headerlink" title="ros::init 源码"></a>ros::init 源码</h3><p><code>ros::init</code>有三种重载形式，以最简单的一种为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> M_string&amp; remappings, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">uint32_t</span> options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!g_atexit_registered)</span><br><span class="line">  &#123;</span><br><span class="line">    g_atexit_registered = <span class="literal">true</span>;   <span class="comment">// 状态</span></span><br><span class="line">    <span class="comment">// 注册终止函数，在调用exit()或终止main函数时关闭shutdown()函数</span></span><br><span class="line">    atexit(atexitCallback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!g_global_queue)</span><br><span class="line">  &#123;</span><br><span class="line">    g_global_queue.reset(<span class="keyword">new</span> CallbackQueue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//上面做了一些预处理，主要部分在下面：</span></span><br><span class="line">  <span class="keyword">if</span> (!g_initialized)   <span class="comment">// 若未初始化</span></span><br><span class="line">  &#123;</span><br><span class="line">    g_init_options = options;</span><br><span class="line">    g_ok = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    ROSCONSOLE_AUTOINIT; <span class="comment">//在console.h中的一段宏定义：Initializes the rosconsole library. </span></span><br><span class="line">    <span class="comment">// Disable SIGPIPE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIN32     <span class="comment">// 如果不是windows系统，执行</span></span></span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 重点是5个init</span></span><br><span class="line">    network::init(remappings);<span class="comment">//初始化网络,实现在network.cpp中</span></span><br><span class="line">    master::init(remappings); <span class="comment">//初始化master</span></span><br><span class="line">    <span class="comment">// names:: namespace is initialized by this_node</span></span><br><span class="line">    this_node::init(name, remappings, options); <span class="comment">//初始化当前节点</span></span><br><span class="line">    file_log::init(remappings);</span><br><span class="line">    param::init(remappings);</span><br><span class="line">    g_initialized = <span class="literal">true</span>;<span class="comment">//置上初始化标记</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析一下代码，首先是注册终止函数，也就是调用exit函数时执行的回调函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atexitCallback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ok() &amp;&amp; !isShuttingDown())</span><br><span class="line">  &#123;</span><br><span class="line">    ROSCPP_LOG_DEBUG(<span class="string">"shutting down due to exit() or end of main() without cleanup of all NodeHandles"</span>);</span><br><span class="line">    g_started = <span class="literal">false</span>; <span class="comment">// don't shutdown singletons, because they are already destroyed</span></span><br><span class="line">    shutdown();         <span class="comment">// 关闭节点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>g_global_queue</code>的定义是<code>CallbackQueuePtr g_global_queue;</code>，再查发现类型其实是一个boost共享指针：<code>typedef boost::shared_ptr&lt;CallbackQueue&gt; CallbackQueuePtr;</code>，这里是共享指针丢弃原来的指向对象，销毁掉，重新指向新new的对象</p><p>再往下是一个宏ROSCONSOLE_AUTOINIT，内容不必太详细看，功能就是初始化rosconsole库。</p><p>然后执行<code>signal(SIGPIPE, SIG_IGN);</code>，功能是收到RST包后，不要关闭节点。</p><p>最后就是很重要的5个init，我们一一分析</p><h4 id="network-init"><a href="#network-init" class="headerlink" title="network:init()"></a>network:init()</h4><p>这个函数主要就是给g_host和g_tcpros_server_port赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> M_string&amp; remappings)</span> <span class="comment">//该函数在init.cpp中被调用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//模块1：</span></span><br><span class="line">  M_string::const_iterator it = remappings.find(<span class="string">"__hostname"</span>);</span><br><span class="line">  <span class="keyword">if</span> (it != remappings.end())</span><br><span class="line">  &#123;</span><br><span class="line">    g_host = it-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    it = remappings.find(<span class="string">"__ip"</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != remappings.end())</span><br><span class="line">    &#123;</span><br><span class="line">      g_host = it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//模块2</span></span><br><span class="line">  it = remappings.find(<span class="string">"__tcpros_server_port"</span>);</span><br><span class="line">  <span class="keyword">if</span> (it != remappings.end())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;           <span class="comment">//  尝试将对应元素的值（std::string）转化成uint16_t类型，boost 转化</span></span><br><span class="line">                <span class="comment">//  g_tcpros_server_port初始值为0</span></span><br><span class="line">      g_tcpros_server_port = boost::lexical_cast&lt;<span class="keyword">uint16_t</span>&gt;(it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (boost::bad_lexical_cast &amp; )        <span class="comment">// 如果上述类型转化发生异常，捕捉</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> ros::InvalidPortException(<span class="string">"__tcpros_server_port ["</span> + it-&gt;second + <span class="string">"] was not specified as a number within the 0-65535 range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//模块3，如果上面未能赋值，调用函数determineHost赋值</span></span><br><span class="line">  <span class="keyword">if</span> (g_host.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    g_host = determineHost();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>M_string</code>其实是<code>std::map&lt;std::string, std::string&gt;</code>，也就是标准map容器。</p><p><code>boost::lexical_cast</code>用于string 和数值之间的转换比如：将一个字符串”712”转换成整数712，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"712"</span>;  </span><br><span class="line"><span class="keyword">int</span> a = lexical_cast&lt;<span class="keyword">int</span>&gt;(s); </span><br><span class="line"></span><br><span class="line">s=<span class="string">"1523408.78"</span>;</span><br><span class="line"><span class="keyword">float</span> num = boost::lexical_cast&lt;<span class="keyword">float</span>&gt;(s);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>浮点数比较大时，会四舍五入用科学计数法表示．<br>这种方法的好处是：如果转换发生了意外，lexical_cast会抛出一个bad_lexical_cast异常，可以在程序中进行捕捉。</p><p>最后，如果之前未能给g_host成功赋值，会调用<code>determineHost</code>函数，它依次获取环境变量<code>ROS_HOSTNAME</code>和<code>ROS_IP</code>，如果没有设置这两个环境变量，就调用<code>gethostname</code>函数获取主机名，但不能取<code>localhost</code>，如果这样还不能获取到，只好返回127.0.0.1</p><h4 id="master-init"><a href="#master-init" class="headerlink" title="master::init()"></a>master::init()</h4><p>这个是处理主机节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> M_string&amp; remappings)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//构建迭代器，查找remappings中键为"__master"的节点。</span></span><br><span class="line">  M_string::const_iterator it = remappings.find(<span class="string">"__master"</span>);</span><br><span class="line">  <span class="keyword">if</span> (it != remappings.end())</span><br><span class="line">  &#123;</span><br><span class="line">    g_uri = it-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果g_uri没有被赋值（即刚刚没找到相应节点）</span></span><br><span class="line">  <span class="keyword">if</span> (g_uri.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">char</span> *master_uri_env = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER     <span class="comment">// 根据编译器使用不同函数</span></span></span><br><span class="line">      _dupenv_s(&amp;master_uri_env, <span class="literal">NULL</span>, <span class="string">"ROS_MASTER_URI"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      master_uri_env = getenv(<span class="string">"ROS_MASTER_URI"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!master_uri_env)</span><br><span class="line">    &#123;</span><br><span class="line">      ROS_FATAL( <span class="string">"ROS_MASTER_URI is not defined in the environment. Either "</span> \</span><br><span class="line">                 <span class="string">"type the following or (preferrably) add this to your "</span> \</span><br><span class="line">                 <span class="string">"~/.bashrc file in order set up your "</span> \</span><br><span class="line">                 <span class="string">"local machine as a ROS master:\n\n"</span> \</span><br><span class="line">                 <span class="string">"export ROS_MASTER_URI=http://localhost:11311\n\n"</span> \</span><br><span class="line">                 <span class="string">"then, type 'roscore' in another shell to actually launch "</span> \</span><br><span class="line">                 <span class="string">"the master program."</span>);</span><br><span class="line">      ROS_BREAK();</span><br><span class="line">    &#125;</span><br><span class="line">    g_uri = master_uri_env;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">    <span class="built_in">free</span>(master_uri_env);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对g_uri进行解析，把g_uri中去掉协议部分赋值给g_host，并将端口赋值给g_port。</span></span><br><span class="line">  <span class="keyword">if</span> (!network::splitURI(g_uri, g_host, g_port))</span><br><span class="line">  &#123;</span><br><span class="line">    ROS_FATAL( <span class="string">"Couldn't parse the master URI [%s] into a host:port pair."</span>, g_uri.c_str());</span><br><span class="line">    ROS_BREAK();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有获得环境变量<code>ROS_MASTER_URI</code>，那么节点报错退出，可见这个环境变量必不可少，最后把值赋给<code>g_uri</code>。最后的<code>splitURI</code>函数显然是一个字符串的处理函数，过程比较复杂，我们知道功能即可</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/22/ROS/ROS Kinetic知识/spin与spinOnce/">spin与spinOnce</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic知识/">ROS Kinetic知识</a></span><div class="content"><p>在主题发布和订阅中，消息订阅器一旦知道主题上面有消息发布，就会将消息的值作为参数传入回调函数中，把回调函数放到了一个回调函数队列中，它们的函数名一样，只是实参不一样，这就是subscribe函数的作用。但是此时还没有执行callback函数，当spinOnce函数被调用时，spinOnce就会调用回调函数队列中第一个callback函数，此时回调函数才被执行，然后等到下次spinOnce函数又被调用时，回调函数队列中第二个回调函数就会被调用，以此类推。</p><p>注意：因为回调函数队列的长度是有限的，如果发布数据的速度太快，spinOnce函数调用的频率太少，就会导致队列溢出，一些回调函数就会被挤掉，导致没被执行。</p><p>对于spin函数，一旦进入spin函数，它就不会返回了，相当于它在自己的函数里阻塞。只要回调函数队列里面有回调函数在，它就会马上去执行。如果没有的话，它就会阻塞，不会占用CPU。</p><p>spin()的目的是启动一个新的线程去获取队列中的回调函数并调用它。有单线程，同步多线程和异步多线程等情况，这些都有内置的语句。所有用户的调用程序将从 ros::spin()开始调用。只到节点关闭（ros::shutdown() 或者 Ctrl-C），ros::spin()才有返回值。</p><p><code>ros::spin</code>其实就相当于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(ros::ok())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Do Something</span></span><br><span class="line">    ros::spinOnce();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发布和订阅话题都不一定要使用spinOnce()，什么时候用ros::spin()和ros::spinOnce()呢，如果仅仅只是响应topic，就用ros::spin()。当程序中除了响应回调函数还有其他重复性工作的时候，那就在循环中做那些工作，然后调用ros::spinOnce()</p><h2 id="spinOnece的注意"><a href="#spinOnece的注意" class="headerlink" title="spinOnece的注意"></a>spinOnece的注意</h2><p><font size="4" color="blue">我仔细试验了这几个参数，没有发现缺失回调函数的情况，一般不需要太注意</font></p><p>ros::spinOnce()的用法相对来说很灵活，但往往需要考虑调用消息的时机，调用频率，以及消息池的大小。</p><p>比如下面的程序，消息送达频率为10Hz，<code>ros::spinOnce()</code>的调用频率为5Hz，那么消息池的大小就一定要大于2，才能保证数据不丢失，无延迟，跟这里的发布消息池容量无关</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送频率为10Hz(1秒发10次)  消息池最大容量1000。</span></span><br><span class="line">ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;(<span class="string">"chatter"</span>, <span class="number">1000</span>);</span><br><span class="line">ros::<span class="function">Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (ros::ok())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 发布消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ros::Subscriber sub = n.subscribe(<span class="string">"chatter"</span>, <span class="number">2</span>, chatterCallback);</span><br><span class="line">ros::<span class="function">Rate <span class="title">loop_rate</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (ros::ok())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*...TODO...*/</span> </span><br><span class="line">    ros::spinOnce();</span><br><span class="line">    loop_rate.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spinOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  g_global_queue-&gt;callAvailable(ros::WallDuration());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用队列中的所有回调函数，如果一个回调还没有准备好调用，再推回队列</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/16/ROS/ROS Kinetic知识/发布和订阅/">发布和订阅</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic知识/">ROS Kinetic知识</a></span><div class="content"><p>话题通信的媒介是消息，消息的产生和消费是解偶的，二者之间没有强行绑定的关系，ROS节点不在乎是谁在发布Topic，哪个节点在订阅Topic，它只关心topic的名字以及当前的消息类型时候和要求的匹配。所以说话题通信是<strong>多对多</strong>的方式</p><p>publisher注册时的消息类型,如果和发布时的消息类型不一致,编译不报错,运行报错</p><p>消息是以Boost共享指针的形式传输，我们可以存储它而又不需要复制数据。回调函数最常用的原型是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> std_msgs::StringConstPtr&amp; str)</span></span></span><br></pre></td></tr></table></figure><p>其实它就是<code>void callback(const boost::shared_ptr&lt;std_msgs::String const&gt;&amp;);</code>，还有以下几种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(boost::<span class="built_in">shared_ptr</span>&lt;std_msgs::String <span class="keyword">const</span>&gt;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(std_msgs::StringConstPtr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(std_msgs::String::ConstPtr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> std_msgs::String&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(std_msgs::String)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> ros::MessageEvent&lt;std_msgs::String <span class="keyword">const</span>&gt;&amp;)</span></span>;</span><br></pre></td></tr></table></figure><p>MessageEvent类允许你在订阅的回调函数内获取信息的元数据。</p><p>其他常用的ros::Subscriber函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> 	getNumPublishers () <span class="keyword">const</span>    <span class="comment">//获得连接订阅者的发布者个数</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> 	<span class="title">getTopic</span> <span class="params">()</span> <span class="keyword">const</span>	<span class="comment">//获得所订阅的话题</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">uint32_t 	<span class="title">getNumSubscribers</span> <span class="params">()</span> <span class="keyword">const</span>　　<span class="comment">//获得连接发布者的订阅者个数</span></span></span><br></pre></td></tr></table></figure><p>订阅话题后，回调函数的参数类型必须是对应话题的消息类型，否则能订阅成功但不运行回调。</p><h2 id="发布者的回调函数"><a href="#发布者的回调函数" class="headerlink" title="发布者的回调函数"></a>发布者的回调函数</h2><p>用于检测是否有订阅者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ros::Publisher pub = nh.advertise&lt;std_msgs::Int8&gt;(<span class="string">"topic"</span>, <span class="number">50</span>, connectCb,disconnectCb);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数如下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectCb</span><span class="params">(<span class="keyword">const</span> ros::SingleSubscriberPublisher&amp; pub)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ROS_INFO(<span class="string">"topic Name: %s"</span>, pub.getTopic().c_str());</span><br><span class="line">    ROS_INFO(<span class="string">"Subscriber Name: %s"</span>, pub.getSubscriberName().c_str());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disconnectCb</span><span class="params">(<span class="keyword">const</span> ros::SingleSubscriberPublisher&amp; pub)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ROS_INFO(<span class="string">"disconnectCb"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特殊需求"><a href="#特殊需求" class="headerlink" title="特殊需求"></a>特殊需求</h2><p>有时需要在订阅者的回调函数中发布消息,而且只发布一次,这时没必要用service混合topic,用static变量就可以做到:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ros::Publisher *pubPtr;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> published = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> std_msgs::Int8ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = msg-&gt;data;</span><br><span class="line">    ROS_INFO(<span class="string">"msg: %d"</span>, num);</span><br><span class="line">    std_msgs::String str;</span><br><span class="line">    str.data = <span class="built_in">std</span>::<span class="built_in">string</span>(to_string(num) );</span><br><span class="line">    <span class="keyword">if</span>(!published &amp;&amp; num&gt;<span class="number">8</span>)   <span class="comment">// 在num&gt;8时发布一次,以后再也不发布</span></span><br><span class="line">    &#123;</span><br><span class="line">      pubPtr-&gt;publish(str);</span><br><span class="line">      published = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::init(argc,argv, <span class="string">"Sub"</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">    ros::Subscriber sub = nh.subscribe&lt;std_msgs::Int8&gt;(<span class="string">"topic"</span>,<span class="number">20</span>,callback);</span><br><span class="line">    ros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(<span class="string">"new"</span>,<span class="number">50</span>,<span class="literal">false</span>);</span><br><span class="line">    pubPtr = &amp;pub;</span><br><span class="line">    ros::spin();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="让订阅者停止订阅"><a href="#让订阅者停止订阅" class="headerlink" title="让订阅者停止订阅"></a>让订阅者停止订阅</h3><p>ROS官方有这么一段话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function   subscribe() 　returns a Subscriber object that you must hold on to until you want to unsubscribe. When all copies of the Subscriber object go out of scope, this callback will automatically be unsubscribed from this topic.</span><br><span class="line"></span><br><span class="line">function  shutdown()   Unsubscribe the callback associated with this Subscriber.</span><br><span class="line">This method usually does not need to be explicitly called, as automatic shutdown happens when all copies of this Subscriber go out of scope</span><br><span class="line">This method overrides the automatic reference counted unsubscribe, and immediately unsubscribes the callback associated with this Subscriber</span><br></pre></td></tr></table></figure><p>根据说明，有以下三种方法：</p><ol><li><p>一般让订阅者停止订阅的方法是等<code>subscribe()</code>生成的订阅者对象出作用域．</p></li><li><p>另一种方法就是explicitly调用<code>shutdown()</code>，典型方法是声明订阅者对象为全局变量，在回调函数中满足某条件时，对此对象调用<code>shutdown()</code>，但这样会直接退出程序，并不好</p></li><li><p>第三种方法其实与第二种类似，声明一个bool全局变量ok，订阅时执行</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!ok)</span><br><span class="line">&#123;</span><br><span class="line">    ros::spinOnce();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在回调函数中满足某条件时，让ok=true</p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/16/ROS/ROS Kinetic知识/ROS定时器/">ROS定时器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic知识/">ROS Kinetic知识</a></span><div class="content"><p>roscpp的定时器会计划在某一速率下执行一次回调操作，在订阅或服务中的回调函数队列机制中使用。</p><h3 id="创建定时器"><a href="#创建定时器" class="headerlink" title="创建定时器"></a>创建定时器</h3><p>通过ros::NodeHandle::createTimer()创建: <code>ros::Timer timer = nh.createTimer(ros::Duration(0.1), timerCallback);</code> 其实有多个重载，这是用的比较多的一种。</p><p>回调函数只能是这种形式: <code>void callback(const ros::TimerEvent&amp;);</code><br>ros::TimerEvent结构体作为参数传入，它提供时间的相关信息，对于调试和配置非常有用。ros::TimerEvent结构体说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ros::Time last_expected 上次回调期望发生的时间</span><br><span class="line">ros::Time last_real 上次回调实际发生的时间</span><br><span class="line">ros::Time current_expected 本次回调期待发生的时间</span><br><span class="line">ros::Time current_real 本次回调实际发生的时间</span><br><span class="line">ros::WallTime profile.last_duration 上次回调的时间间隔（结束时间-开始时间），是wall-clock时间。</span><br></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>比如某些情况下，我们需要一直监视机器人的里程计数据状态，并在某个界面上显示出来。这种情况下可以用到定时器，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void odomTimerCb(const ros::TimerEvent&amp; e);</span><br><span class="line">void odomSubCb(const nav_msgs::OdometryConstPtr&amp; m);</span><br><span class="line">ros::Timer　odomTimer ;</span><br><span class="line">riki_msgs::HealthStatus msg;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    ros::init(argc,argv,&quot;healthStatus&quot;);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    odomTimer = nh.createTimer(ros::Duration(5), odomTimerCb);</span><br><span class="line">    ros::Subscriber odomSub = nh.subscribe(&quot;odom&quot;, 1000, odomSubCb);</span><br><span class="line"></span><br><span class="line">    ros::Publisher pub = nh.advertise&lt;riki_msgs::HealthStatus&gt;(&quot;healthStatus&quot;, 1000);</span><br><span class="line">    ros::Rate loop_rate(1);</span><br><span class="line">    while(ros::ok())</span><br><span class="line">    &#123;</span><br><span class="line">        pub.publish(msg);</span><br><span class="line">        ros::spinOnce();</span><br><span class="line">        loop_rate.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void odomTimerCb(const ros::TimerEvent&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    msg.odomData = false;</span><br><span class="line">&#125;</span><br><span class="line">void odomSubCb(const nav_msgs::OdometryConstPtr&amp; m)</span><br><span class="line">&#123;</span><br><span class="line">    msg.odomData = true;</span><br><span class="line">    odomTimer.stop();</span><br><span class="line">    odomTimer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未发布odom主题时，不会进入订阅者的回调函数<code>odomSubCb</code>，只进入定时器的回调<code>odomTimerCb</code>，此时消息成员<code>odomData</code>一直是false。<br>发布odom后，进入订阅者回调，此时<code>odomData</code>成为true，此时需要先停止计时器再打开。如果不停止，还会进入计时器回调，让消息成员赋值为false，实际造成赋值混乱。但是还得打开，因为一旦<code>odom</code>话题关闭了，就不会再进入订阅者回调，需要设法调用计时器回调，赋值false。订阅<code>odom</code>话题成功再打开计时器后，不会进入计时器回调。</p><p>参考: <a href="https://www.ncnynl.com/archives/201702/1296.html" target="_blank" rel="noopener">ROS与C++入门教程-Timers</a></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/16/ROS/ROS Kinetic知识/只发布和订阅一次消息/">ROS只发布和订阅一次消息</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic知识/">ROS Kinetic知识</a></span><div class="content"><h3 id="只发布一次消息"><a href="#只发布一次消息" class="headerlink" title="只发布一次消息"></a>只发布一次消息</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ros::init(argc,argv,<span class="string">"op_motor"</span>);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">ros::Publisher pub = nh.advertise&lt;std_msgs::Bool&gt;(<span class="string">"Switch"</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//不必判断订阅者，直接等待１秒钟，只发布一次</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">pub.publish(msg);</span><br></pre></td></tr></table></figure><p>只发布一次消息就简单了，不必用while循环，直接发布就可以，但是最好也延时一次，防止订阅者的网络状况不好，当然如果不考虑有没有订阅者就不必延时了，不过这样没什么意义。</p><br><h3 id="ROS只订阅一次消息"><a href="#ROS只订阅一次消息" class="headerlink" title="ROS只订阅一次消息"></a>ROS只订阅一次消息</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ros::init(argc,argv,<span class="string">"node"</span>);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">boost::<span class="built_in">shared_ptr</span>&lt;riki_msgs::Battery <span class="keyword">const</span>&gt; batEdge;    <span class="comment">// 必须有const</span></span><br><span class="line">batEdge = ros::topic::waitForMessage&lt;riki_msgs::Battery&gt;(<span class="string">"BMS"</span>,ros::Duration(<span class="number">3</span>));</span><br><span class="line"><span class="keyword">if</span>(batEdge != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    riki_msgs::Battery  bat = *batEdge;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"battery:"</span>&lt;&lt;  bat.Ah  &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"battery:"</span>&lt;&lt;  batEdge-&gt;Ah  &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"no topic BMS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>这里用到的函数是<code>ros::topic::waitForMessage</code>，没有涉及回调函数，它有4个重载，常用的是两个:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">M</span>&gt; <span class="title">boost</span>:</span>:<span class="built_in">shared_ptr</span>&lt; M <span class="keyword">const</span> &gt;   waitForMessage (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;topic, ros::Duration timeout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">M</span>&gt; <span class="title">boost</span>:</span>:<span class="built_in">shared_ptr</span>&lt; M <span class="keyword">const</span> &gt;  waitForMessage (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;topic, ros::NodeHandle &amp;nh)</span><br></pre></td></tr></table></figure><p>第一个是订阅话题topic，假如没有发布话题，那么等待时间timeout，超时后程序继续执行；第二个是如果没有发现话题topic，会一直阻塞，不能向下运行，除非执行<code>rosnode kill</code>。前一个用的比较多，注意时间不要设置太短，否则可能因为网络状况不好而订阅失败。</p><p>返回类型一看就知道是模板类的Boost共享指针，从这里就可以看出， <font color="blue"><font size="3">消息是以Boost共享指针的形式传输，我们可以存储它而又不需要复制数据</font> </font>，<code>waitForMessage</code>就是返回了订阅到的消息，取指向就可以获得消息成员，也可以直接用指针获得消息成员。<br><strong>注意模板类型有const</strong>，否则不符合重载声明</p><p>参考:<br><a href="https://answers.ros.org/question/11167/how-do-i-publish-exactly-one-message/" target="_blank" rel="noopener">How do I publish exactly one message</a><br><a href="http://docs.ros.org/jade/api/roscpp/html/namespaceros_1_1topic.html" target="_blank" rel="noopener">ros::topic Namespace</a></p></div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/26/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><span class="page-number current">27</span><a class="page-number" href="/page/28/">28</a><span class="space">&hellip;</span><a class="page-number" href="/page/42/">42</a><a class="extend next" rel="next" href="/page/28/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image:url(https://i.loli.net/2020/07/13/QgyrefaLDxhBWSZ.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>